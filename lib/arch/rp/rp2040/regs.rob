
/*
 * Part of the Robotics Language Standard Library, under the
 * Apache License v2.0.
 *
 * This file was machine generated from rp/rp2040/rp2040.svd. Don't edit.
 */

/*
	vendor: Raspberry Pi
	name: RP2040
	series: RP
	version: 0.1
	description: 
        Dual-core Arm Cortex-M0+ processor, flexible clock running up to 133 MHz
        264KB on-chip SRAM
        2 x UART, 2 x SPI controllers, 2 x I2C controllers, 16 x PWM channels
        1 x USB 1.1 controller and PHY, with host and device support
        8 x Programmable I/O (PIO) state machines for custom peripheral support
        Supported input power 1.8-5.5V DC
        Operating temperature -20C to +85C
        Drag-and-drop programming using mass storage over USB
        Low-power sleep and dormant modes
        Accurate on-chip clock
        Temperature sensor
        Accelerated integer and floating-point libraries on-chip
    
*/

/* Types and registers for RESETS  */

 type RESET_t {
	ADC        = false;              // 
	BUSCTRL    = false;              // 
	DMA        = false;              // 
	I2C0       = false;              // 
	I2C1       = false;              // 
	IO_BANK0   = false;              // 
	IO_QSPI    = false;              // 
	JTAG       = false;              // 
	PADS_BANK0 = false;              // 
	PADS_QSPI  = false;              // 
	PIO0       = false;              // 
	PIO1       = false;              // 
	PLL_SYS    = false;              // 
	PLL_USB    = false;              // 
	PWM        = false;              // 
	RTC        = false;              // 
	SPI0       = false;              // 
	SPI1       = false;              // 
	SYSCFG     = false;              // 
	SYSINFO    = false;              // 
	TBMAN      = false;              // 
	TIMER      = false;              // 
	UART0      = false;              // 
	UART1      = false;              // 
	USBCTRL    = false;              // 
 }

 // Reset control. If a bit is set it means the peripheral is in reset. 0 means the peripheral's reset is deasserted.
 register RESET_t RESET at 0x4000c000;

 type RESETS_WDSEL_t {
	ADC        = false;              // 
	BUSCTRL    = false;              // 
	DMA        = false;              // 
	I2C0       = false;              // 
	I2C1       = false;              // 
	IO_BANK0   = false;              // 
	IO_QSPI    = false;              // 
	JTAG       = false;              // 
	PADS_BANK0 = false;              // 
	PADS_QSPI  = false;              // 
	PIO0       = false;              // 
	PIO1       = false;              // 
	PLL_SYS    = false;              // 
	PLL_USB    = false;              // 
	PWM        = false;              // 
	RTC        = false;              // 
	SPI0       = false;              // 
	SPI1       = false;              // 
	SYSCFG     = false;              // 
	SYSINFO    = false;              // 
	TBMAN      = false;              // 
	TIMER      = false;              // 
	UART0      = false;              // 
	UART1      = false;              // 
	USBCTRL    = false;              // 
 }

 // Watchdog select. If a bit is set then the watchdog will reset this peripheral when the watchdog fires.
 register RESETS_WDSEL_t RESETS_WDSEL at 0x4000c004;

 type RESET_DONE_t {
	ADC        = false;              // 
	BUSCTRL    = false;              // 
	DMA        = false;              // 
	I2C0       = false;              // 
	I2C1       = false;              // 
	IO_BANK0   = false;              // 
	IO_QSPI    = false;              // 
	JTAG       = false;              // 
	PADS_BANK0 = false;              // 
	PADS_QSPI  = false;              // 
	PIO0       = false;              // 
	PIO1       = false;              // 
	PLL_SYS    = false;              // 
	PLL_USB    = false;              // 
	PWM        = false;              // 
	RTC        = false;              // 
	SPI0       = false;              // 
	SPI1       = false;              // 
	SYSCFG     = false;              // 
	SYSINFO    = false;              // 
	TBMAN      = false;              // 
	TIMER      = false;              // 
	UART0      = false;              // 
	UART1      = false;              // 
	USBCTRL    = false;              // 
 }

 // Reset done. If a bit is set then a reset done signal has been returned by the peripheral. This indicates that the peripheral's registers are ready to be accessed.
 register RESET_DONE_t RESET_DONE at 0x4000c008;


/* Types and registers for PSM  */

 type FRCE_ON_t {
	ROSC                = false;              // 
	XOSC                = false;              // 
	CLOCKS              = false;              // 
	RESETS              = false;              // 
	BUSFABRIC           = false;              // 
	ROM                 = false;              // 
	SRAM0               = false;              // 
	SRAM1               = false;              // 
	SRAM2               = false;              // 
	SRAM3               = false;              // 
	SRAM4               = false;              // 
	SRAM5               = false;              // 
	XIP                 = false;              // 
	VREG_AND_CHIP_RESET = false;              // 
	SIO                 = false;              // 
	PROC0               = false;              // 
	PROC1               = false;              // 
 }

 // Force block out of reset (i.e. power it on)
 register FRCE_ON_t FRCE_ON at 0x40010000;

 type FRCE_OFF_t {
	ROSC                = false;              // 
	XOSC                = false;              // 
	CLOCKS              = false;              // 
	RESETS              = false;              // 
	BUSFABRIC           = false;              // 
	ROM                 = false;              // 
	SRAM0               = false;              // 
	SRAM1               = false;              // 
	SRAM2               = false;              // 
	SRAM3               = false;              // 
	SRAM4               = false;              // 
	SRAM5               = false;              // 
	XIP                 = false;              // 
	VREG_AND_CHIP_RESET = false;              // 
	SIO                 = false;              // 
	PROC0               = false;              // 
	PROC1               = false;              // 
 }

 // Force into reset (i.e. power it off)
 register FRCE_OFF_t FRCE_OFF at 0x40010004;

 type PSM_WDSEL_t {
	ROSC                = false;              // 
	XOSC                = false;              // 
	CLOCKS              = false;              // 
	RESETS              = false;              // 
	BUSFABRIC           = false;              // 
	ROM                 = false;              // 
	SRAM0               = false;              // 
	SRAM1               = false;              // 
	SRAM2               = false;              // 
	SRAM3               = false;              // 
	SRAM4               = false;              // 
	SRAM5               = false;              // 
	XIP                 = false;              // 
	VREG_AND_CHIP_RESET = false;              // 
	SIO                 = false;              // 
	PROC0               = false;              // 
	PROC1               = false;              // 
 }

 // Set to 1 if this peripheral should be reset when the watchdog fires.
 register PSM_WDSEL_t PSM_WDSEL at 0x40010008;

 type DONE_t {
	ROSC                = false;              // 
	XOSC                = false;              // 
	CLOCKS              = false;              // 
	RESETS              = false;              // 
	BUSFABRIC           = false;              // 
	ROM                 = false;              // 
	SRAM0               = false;              // 
	SRAM1               = false;              // 
	SRAM2               = false;              // 
	SRAM3               = false;              // 
	SRAM4               = false;              // 
	SRAM5               = false;              // 
	XIP                 = false;              // 
	VREG_AND_CHIP_RESET = false;              // 
	SIO                 = false;              // 
	PROC0               = false;              // 
	PROC1               = false;              // 
 }

 // Indicates the peripheral's registers are ready to access.
 register DONE_t DONE at 0x4001000c;


/* Types and registers for CLOCKS  */

 type CLK_GPOUT0_CTRL_t {
	_res1  = uint5(0);           // Reserved, 5 bits
	AUXSRC = uint4(0);           // Selects the auxiliary clock source, will glitch when switching
	_res2  = false;              // Reserved, 1 bits
	KILL   = false;              // Asynchronously kills the clock generator
	ENABLE = false;              // Starts and stops the clock generator cleanly
	DC50   = false;              // Enables duty cycle correction for odd divisors
	_res3  = uint3(0);           // Reserved, 3 bits
	PHASE  = uint2(0);           // This delays the enable signal by up to 3 cycles of the input clock This must be set before the clock is enabled to have any effect
	_res4  = uint2(0);           // Reserved, 2 bits
	NUDGE  = false;              // An edge on this signal shifts the phase of the output by 1 cycle of the input clock This can be done at any time
 }

 // Clock control, can be changed on-the-fly (except for auxsrc)
 register CLK_GPOUT0_CTRL_t CLK_GPOUT0_CTRL at 0x40008000;

 type CLK_GPOUT0_DIV_t {
	FRAC = uint8(0);           // Fractional component of the divisor
	INT  = uint24(0);          // Integer component of the divisor, 0 -> divide by 2^16
 }

 // Clock divisor, can be changed on-the-fly
 register CLK_GPOUT0_DIV_t CLK_GPOUT0_DIV at 0x40008004;

 type CLK_GPOUT0_SELECTED_t {
	CLK_GPOUT0_SELECTED = uint32(0);          // This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.
 }

 // Indicates which SRC is currently selected by the glitchless mux (one-hot).
 register CLK_GPOUT0_SELECTED_t CLK_GPOUT0_SELECTED at 0x40008008;

 type CLK_GPOUT1_CTRL_t {
	_res1  = uint5(0);           // Reserved, 5 bits
	AUXSRC = uint4(0);           // Selects the auxiliary clock source, will glitch when switching
	_res2  = false;              // Reserved, 1 bits
	KILL   = false;              // Asynchronously kills the clock generator
	ENABLE = false;              // Starts and stops the clock generator cleanly
	DC50   = false;              // Enables duty cycle correction for odd divisors
	_res3  = uint3(0);           // Reserved, 3 bits
	PHASE  = uint2(0);           // This delays the enable signal by up to 3 cycles of the input clock This must be set before the clock is enabled to have any effect
	_res4  = uint2(0);           // Reserved, 2 bits
	NUDGE  = false;              // An edge on this signal shifts the phase of the output by 1 cycle of the input clock This can be done at any time
 }

 // Clock control, can be changed on-the-fly (except for auxsrc)
 register CLK_GPOUT1_CTRL_t CLK_GPOUT1_CTRL at 0x4000800c;

 type CLK_GPOUT1_DIV_t {
	FRAC = uint8(0);           // Fractional component of the divisor
	INT  = uint24(0);          // Integer component of the divisor, 0 -> divide by 2^16
 }

 // Clock divisor, can be changed on-the-fly
 register CLK_GPOUT1_DIV_t CLK_GPOUT1_DIV at 0x40008010;

 type CLK_GPOUT1_SELECTED_t {
	CLK_GPOUT1_SELECTED = uint32(0);          // This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.
 }

 // Indicates which SRC is currently selected by the glitchless mux (one-hot).
 register CLK_GPOUT1_SELECTED_t CLK_GPOUT1_SELECTED at 0x40008014;

 type CLK_GPOUT2_CTRL_t {
	_res1  = uint5(0);           // Reserved, 5 bits
	AUXSRC = uint4(0);           // Selects the auxiliary clock source, will glitch when switching
	_res2  = false;              // Reserved, 1 bits
	KILL   = false;              // Asynchronously kills the clock generator
	ENABLE = false;              // Starts and stops the clock generator cleanly
	DC50   = false;              // Enables duty cycle correction for odd divisors
	_res3  = uint3(0);           // Reserved, 3 bits
	PHASE  = uint2(0);           // This delays the enable signal by up to 3 cycles of the input clock This must be set before the clock is enabled to have any effect
	_res4  = uint2(0);           // Reserved, 2 bits
	NUDGE  = false;              // An edge on this signal shifts the phase of the output by 1 cycle of the input clock This can be done at any time
 }

 // Clock control, can be changed on-the-fly (except for auxsrc)
 register CLK_GPOUT2_CTRL_t CLK_GPOUT2_CTRL at 0x40008018;

 type CLK_GPOUT2_DIV_t {
	FRAC = uint8(0);           // Fractional component of the divisor
	INT  = uint24(0);          // Integer component of the divisor, 0 -> divide by 2^16
 }

 // Clock divisor, can be changed on-the-fly
 register CLK_GPOUT2_DIV_t CLK_GPOUT2_DIV at 0x4000801c;

 type CLK_GPOUT2_SELECTED_t {
	CLK_GPOUT2_SELECTED = uint32(0);          // This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.
 }

 // Indicates which SRC is currently selected by the glitchless mux (one-hot).
 register CLK_GPOUT2_SELECTED_t CLK_GPOUT2_SELECTED at 0x40008020;

 type CLK_GPOUT3_CTRL_t {
	_res1  = uint5(0);           // Reserved, 5 bits
	AUXSRC = uint4(0);           // Selects the auxiliary clock source, will glitch when switching
	_res2  = false;              // Reserved, 1 bits
	KILL   = false;              // Asynchronously kills the clock generator
	ENABLE = false;              // Starts and stops the clock generator cleanly
	DC50   = false;              // Enables duty cycle correction for odd divisors
	_res3  = uint3(0);           // Reserved, 3 bits
	PHASE  = uint2(0);           // This delays the enable signal by up to 3 cycles of the input clock This must be set before the clock is enabled to have any effect
	_res4  = uint2(0);           // Reserved, 2 bits
	NUDGE  = false;              // An edge on this signal shifts the phase of the output by 1 cycle of the input clock This can be done at any time
 }

 // Clock control, can be changed on-the-fly (except for auxsrc)
 register CLK_GPOUT3_CTRL_t CLK_GPOUT3_CTRL at 0x40008024;

 type CLK_GPOUT3_DIV_t {
	FRAC = uint8(0);           // Fractional component of the divisor
	INT  = uint24(0);          // Integer component of the divisor, 0 -> divide by 2^16
 }

 // Clock divisor, can be changed on-the-fly
 register CLK_GPOUT3_DIV_t CLK_GPOUT3_DIV at 0x40008028;

 type CLK_GPOUT3_SELECTED_t {
	CLK_GPOUT3_SELECTED = uint32(0);          // This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.
 }

 // Indicates which SRC is currently selected by the glitchless mux (one-hot).
 register CLK_GPOUT3_SELECTED_t CLK_GPOUT3_SELECTED at 0x4000802c;

 type CLK_REF_CTRL_t {
	SRC    = uint2(0);           // Selects the clock source glitchlessly, can be changed on-the-fly
	_res1  = uint3(0);           // Reserved, 3 bits
	AUXSRC = uint2(0);           // Selects the auxiliary clock source, will glitch when switching
 }

 // Clock control, can be changed on-the-fly (except for auxsrc)
 register CLK_REF_CTRL_t CLK_REF_CTRL at 0x40008030;

 type CLK_REF_DIV_t {
	_res1 = uint8(0);           // Reserved, 8 bits
	INT   = uint2(0);           // Integer component of the divisor, 0 -> divide by 2^16
 }

 // Clock divisor, can be changed on-the-fly
 register CLK_REF_DIV_t CLK_REF_DIV at 0x40008034;

 type CLK_REF_SELECTED_t {
	CLK_REF_SELECTED = uint32(0);          // The glitchless multiplexer does not switch instantaneously (to avoid glitches), so software should poll this register to wait for the switch to complete. This register contains one decoded bit for each of the clock sources enumerated in the CTRL SRC field. At most one of these bits will be set at any time, indicating that clock is currently present at the output of the glitchless mux. Whilst switching is in progress, this register may briefly show all-0s.
 }

 // Indicates which SRC is currently selected by the glitchless mux (one-hot).
 register CLK_REF_SELECTED_t CLK_REF_SELECTED at 0x40008038;

 type CLK_SYS_CTRL_t {
	SRC    = false;              // Selects the clock source glitchlessly, can be changed on-the-fly
	_res1  = uint4(0);           // Reserved, 4 bits
	AUXSRC = uint3(0);           // Selects the auxiliary clock source, will glitch when switching
 }

 // Clock control, can be changed on-the-fly (except for auxsrc)
 register CLK_SYS_CTRL_t CLK_SYS_CTRL at 0x4000803c;

 type CLK_SYS_DIV_t {
	FRAC = uint8(0);           // Fractional component of the divisor
	INT  = uint24(0);          // Integer component of the divisor, 0 -> divide by 2^16
 }

 // Clock divisor, can be changed on-the-fly
 register CLK_SYS_DIV_t CLK_SYS_DIV at 0x40008040;

 type CLK_SYS_SELECTED_t {
	CLK_SYS_SELECTED = uint32(0);          // The glitchless multiplexer does not switch instantaneously (to avoid glitches), so software should poll this register to wait for the switch to complete. This register contains one decoded bit for each of the clock sources enumerated in the CTRL SRC field. At most one of these bits will be set at any time, indicating that clock is currently present at the output of the glitchless mux. Whilst switching is in progress, this register may briefly show all-0s.
 }

 // Indicates which SRC is currently selected by the glitchless mux (one-hot).
 register CLK_SYS_SELECTED_t CLK_SYS_SELECTED at 0x40008044;

 type CLK_PERI_CTRL_t {
	_res1  = uint5(0);           // Reserved, 5 bits
	AUXSRC = uint3(0);           // Selects the auxiliary clock source, will glitch when switching
	_res2  = uint2(0);           // Reserved, 2 bits
	KILL   = false;              // Asynchronously kills the clock generator
	ENABLE = false;              // Starts and stops the clock generator cleanly
 }

 // Clock control, can be changed on-the-fly (except for auxsrc)
 register CLK_PERI_CTRL_t CLK_PERI_CTRL at 0x40008048;

 type CLK_PERI_DIV_t {
	FRAC = uint8(0);           // Fractional component of the divisor
	INT  = uint24(0);          // Integer component of the divisor, 0 -> divide by 2^16
 }

 // Clock divisor, can be changed on-the-fly
 register CLK_PERI_DIV_t CLK_PERI_DIV at 0x4000804c;

 type CLK_PERI_SELECTED_t {
	CLK_PERI_SELECTED = uint32(0);          // This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.
 }

 // Indicates which SRC is currently selected by the glitchless mux (one-hot).
 register CLK_PERI_SELECTED_t CLK_PERI_SELECTED at 0x40008050;

 type CLK_USB_CTRL_t {
	_res1  = uint5(0);           // Reserved, 5 bits
	AUXSRC = uint3(0);           // Selects the auxiliary clock source, will glitch when switching
	_res2  = uint2(0);           // Reserved, 2 bits
	KILL   = false;              // Asynchronously kills the clock generator
	ENABLE = false;              // Starts and stops the clock generator cleanly
	_res3  = uint4(0);           // Reserved, 4 bits
	PHASE  = uint2(0);           // This delays the enable signal by up to 3 cycles of the input clock This must be set before the clock is enabled to have any effect
	_res4  = uint2(0);           // Reserved, 2 bits
	NUDGE  = false;              // An edge on this signal shifts the phase of the output by 1 cycle of the input clock This can be done at any time
 }

 // Clock control, can be changed on-the-fly (except for auxsrc)
 register CLK_USB_CTRL_t CLK_USB_CTRL at 0x40008054;

 type CLK_USB_DIV_t {
	_res1 = uint8(0);           // Reserved, 8 bits
	INT   = uint2(0);           // Integer component of the divisor, 0 -> divide by 2^16
 }

 // Clock divisor, can be changed on-the-fly
 register CLK_USB_DIV_t CLK_USB_DIV at 0x40008058;

 type CLK_USB_SELECTED_t {
	CLK_USB_SELECTED = uint32(0);          // This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.
 }

 // Indicates which SRC is currently selected by the glitchless mux (one-hot).
 register CLK_USB_SELECTED_t CLK_USB_SELECTED at 0x4000805c;

 type CLK_ADC_CTRL_t {
	_res1  = uint5(0);           // Reserved, 5 bits
	AUXSRC = uint3(0);           // Selects the auxiliary clock source, will glitch when switching
	_res2  = uint2(0);           // Reserved, 2 bits
	KILL   = false;              // Asynchronously kills the clock generator
	ENABLE = false;              // Starts and stops the clock generator cleanly
	_res3  = uint4(0);           // Reserved, 4 bits
	PHASE  = uint2(0);           // This delays the enable signal by up to 3 cycles of the input clock This must be set before the clock is enabled to have any effect
	_res4  = uint2(0);           // Reserved, 2 bits
	NUDGE  = false;              // An edge on this signal shifts the phase of the output by 1 cycle of the input clock This can be done at any time
 }

 // Clock control, can be changed on-the-fly (except for auxsrc)
 register CLK_ADC_CTRL_t CLK_ADC_CTRL at 0x40008060;

 type CLK_ADC_DIV_t {
	_res1 = uint8(0);           // Reserved, 8 bits
	INT   = uint2(0);           // Integer component of the divisor, 0 -> divide by 2^16
 }

 // Clock divisor, can be changed on-the-fly
 register CLK_ADC_DIV_t CLK_ADC_DIV at 0x40008064;

 type CLK_ADC_SELECTED_t {
	CLK_ADC_SELECTED = uint32(0);          // This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.
 }

 // Indicates which SRC is currently selected by the glitchless mux (one-hot).
 register CLK_ADC_SELECTED_t CLK_ADC_SELECTED at 0x40008068;

 type CLK_RTC_CTRL_t {
	_res1  = uint5(0);           // Reserved, 5 bits
	AUXSRC = uint3(0);           // Selects the auxiliary clock source, will glitch when switching
	_res2  = uint2(0);           // Reserved, 2 bits
	KILL   = false;              // Asynchronously kills the clock generator
	ENABLE = false;              // Starts and stops the clock generator cleanly
	_res3  = uint4(0);           // Reserved, 4 bits
	PHASE  = uint2(0);           // This delays the enable signal by up to 3 cycles of the input clock This must be set before the clock is enabled to have any effect
	_res4  = uint2(0);           // Reserved, 2 bits
	NUDGE  = false;              // An edge on this signal shifts the phase of the output by 1 cycle of the input clock This can be done at any time
 }

 // Clock control, can be changed on-the-fly (except for auxsrc)
 register CLK_RTC_CTRL_t CLK_RTC_CTRL at 0x4000806c;

 type CLK_RTC_DIV_t {
	FRAC = uint8(0);           // Fractional component of the divisor
	INT  = uint24(0);          // Integer component of the divisor, 0 -> divide by 2^16
 }

 // Clock divisor, can be changed on-the-fly
 register CLK_RTC_DIV_t CLK_RTC_DIV at 0x40008070;

 type CLK_RTC_SELECTED_t {
	CLK_RTC_SELECTED = uint32(0);          // This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1.
 }

 // Indicates which SRC is currently selected by the glitchless mux (one-hot).
 register CLK_RTC_SELECTED_t CLK_RTC_SELECTED at 0x40008074;

 type CLK_SYS_RESUS_CTRL_t {
	TIMEOUT = uint8(0);           // This is expressed as a number of clk_ref cycles and must be >= 2x clk_ref_freq/min_clk_tst_freq
	ENABLE  = false;              // Enable resus
	_res1   = uint3(0);           // Reserved, 3 bits
	FRCE    = false;              // Force a resus, for test purposes only
	_res2   = uint3(0);           // Reserved, 3 bits
	CLEAR   = false;              // For clearing the resus after the fault that triggered it has been corrected
 }

 // 
 register CLK_SYS_RESUS_CTRL_t CLK_SYS_RESUS_CTRL at 0x40008078;

 type CLK_SYS_RESUS_STATUS_t {
	RESUSSED = false;              // Clock has been resuscitated, correct the error then send ctrl_clear=1
 }

 // 
 register CLK_SYS_RESUS_STATUS_t CLK_SYS_RESUS_STATUS at 0x4000807c;

 type FC0_REF_KHZ_t {
	FC0_REF_KHZ = uint20(0);          // 
 }

 // Reference clock frequency in kHz
 register FC0_REF_KHZ_t FC0_REF_KHZ at 0x40008080;

 type FC0_MIN_KHZ_t {
	FC0_MIN_KHZ = uint25(0);          // 
 }

 // Minimum pass frequency in kHz. This is optional. Set to 0 if you are not using the pass/fail flags
 register FC0_MIN_KHZ_t FC0_MIN_KHZ at 0x40008084;

 type FC0_MAX_KHZ_t {
	FC0_MAX_KHZ = uint25(0);          // 
 }

 // Maximum pass frequency in kHz. This is optional. Set to 0x1ffffff if you are not using the pass/fail flags
 register FC0_MAX_KHZ_t FC0_MAX_KHZ at 0x40008088;

 type FC0_DELAY_t {
	FC0_DELAY = uint3(0);           // 
 }

 // Delays the start of frequency counting to allow the mux to settle Delay is measured in multiples of the reference clock period
 register FC0_DELAY_t FC0_DELAY at 0x4000808c;

 type FC0_INTERVAL_t {
	FC0_INTERVAL = uint4(0);           // 
 }

 // The test interval is 0.98us * 2**interval, but let's call it 1us * 2**interval The default gives a test interval of 250us
 register FC0_INTERVAL_t FC0_INTERVAL at 0x40008090;

 type FC0_SRC_t {
	FC0_SRC = uint8(0);           // 
 }

 // Clock sent to frequency counter, set to 0 when not required Writing to this register initiates the frequency count
 register FC0_SRC_t FC0_SRC at 0x40008094;

 type FC0_STATUS_t {
	PASS    = false;              // Test passed
	_res1   = uint3(0);           // Reserved, 3 bits
	DONE    = false;              // Test complete
	_res2   = uint3(0);           // Reserved, 3 bits
	RUNNING = false;              // Test running
	_res3   = uint3(0);           // Reserved, 3 bits
	WAITING = false;              // Waiting for test clock to start
	_res4   = uint3(0);           // Reserved, 3 bits
	FAIL    = false;              // Test failed
	_res5   = uint3(0);           // Reserved, 3 bits
	SLOW    = false;              // Test clock slower than expected, only valid when status_done=1
	_res6   = uint3(0);           // Reserved, 3 bits
	FAST    = false;              // Test clock faster than expected, only valid when status_done=1
	_res7   = uint3(0);           // Reserved, 3 bits
	DIED    = false;              // Test clock stopped during test
 }

 // Frequency counter status
 register FC0_STATUS_t FC0_STATUS at 0x40008098;

 type FC0_RESULT_t {
	FRAC = uint5(0);           // 
	KHZ  = uint25(0);          // 
 }

 // Result of frequency measurement, only valid when status_done=1
 register FC0_RESULT_t FC0_RESULT at 0x4000809c;

 type WAKE_EN0_t {
	CLK_SYS_CLOCKS              = false;              // 
	CLK_ADC_ADC                 = false;              // 
	CLK_SYS_ADC                 = false;              // 
	CLK_SYS_BUSCTRL             = false;              // 
	CLK_SYS_BUSFABRIC           = false;              // 
	CLK_SYS_DMA                 = false;              // 
	CLK_SYS_I2C0                = false;              // 
	CLK_SYS_I2C1                = false;              // 
	CLK_SYS_IO                  = false;              // 
	CLK_SYS_JTAG                = false;              // 
	CLK_SYS_VREG_AND_CHIP_RESET = false;              // 
	CLK_SYS_PADS                = false;              // 
	CLK_SYS_PIO0                = false;              // 
	CLK_SYS_PIO1                = false;              // 
	CLK_SYS_PLL_SYS             = false;              // 
	CLK_SYS_PLL_USB             = false;              // 
	CLK_SYS_PSM                 = false;              // 
	CLK_SYS_PWM                 = false;              // 
	CLK_SYS_RESETS              = false;              // 
	CLK_SYS_ROM                 = false;              // 
	CLK_SYS_ROSC                = false;              // 
	CLK_RTC_RTC                 = false;              // 
	CLK_SYS_RTC                 = false;              // 
	CLK_SYS_SIO                 = false;              // 
	CLK_PERI_SPI0               = false;              // 
	CLK_SYS_SPI0                = false;              // 
	CLK_PERI_SPI1               = false;              // 
	CLK_SYS_SPI1                = false;              // 
	CLK_SYS_SRAM0               = false;              // 
	CLK_SYS_SRAM1               = false;              // 
	CLK_SYS_SRAM2               = false;              // 
	CLK_SYS_SRAM3               = false;              // 
 }

 // enable clock in wake mode
 register WAKE_EN0_t WAKE_EN0 at 0x400080a0;

 type WAKE_EN1_t {
	CLK_SYS_SRAM4    = false;              // 
	CLK_SYS_SRAM5    = false;              // 
	CLK_SYS_SYSCFG   = false;              // 
	CLK_SYS_SYSINFO  = false;              // 
	CLK_SYS_TBMAN    = false;              // 
	CLK_SYS_TIMER    = false;              // 
	CLK_PERI_UART0   = false;              // 
	CLK_SYS_UART0    = false;              // 
	CLK_PERI_UART1   = false;              // 
	CLK_SYS_UART1    = false;              // 
	CLK_SYS_USBCTRL  = false;              // 
	CLK_USB_USBCTRL  = false;              // 
	CLK_SYS_WATCHDOG = false;              // 
	CLK_SYS_XIP      = false;              // 
	CLK_SYS_XOSC     = false;              // 
 }

 // enable clock in wake mode
 register WAKE_EN1_t WAKE_EN1 at 0x400080a4;

 type SLEEP_EN0_t {
	CLK_SYS_CLOCKS              = false;              // 
	CLK_ADC_ADC                 = false;              // 
	CLK_SYS_ADC                 = false;              // 
	CLK_SYS_BUSCTRL             = false;              // 
	CLK_SYS_BUSFABRIC           = false;              // 
	CLK_SYS_DMA                 = false;              // 
	CLK_SYS_I2C0                = false;              // 
	CLK_SYS_I2C1                = false;              // 
	CLK_SYS_IO                  = false;              // 
	CLK_SYS_JTAG                = false;              // 
	CLK_SYS_VREG_AND_CHIP_RESET = false;              // 
	CLK_SYS_PADS                = false;              // 
	CLK_SYS_PIO0                = false;              // 
	CLK_SYS_PIO1                = false;              // 
	CLK_SYS_PLL_SYS             = false;              // 
	CLK_SYS_PLL_USB             = false;              // 
	CLK_SYS_PSM                 = false;              // 
	CLK_SYS_PWM                 = false;              // 
	CLK_SYS_RESETS              = false;              // 
	CLK_SYS_ROM                 = false;              // 
	CLK_SYS_ROSC                = false;              // 
	CLK_RTC_RTC                 = false;              // 
	CLK_SYS_RTC                 = false;              // 
	CLK_SYS_SIO                 = false;              // 
	CLK_PERI_SPI0               = false;              // 
	CLK_SYS_SPI0                = false;              // 
	CLK_PERI_SPI1               = false;              // 
	CLK_SYS_SPI1                = false;              // 
	CLK_SYS_SRAM0               = false;              // 
	CLK_SYS_SRAM1               = false;              // 
	CLK_SYS_SRAM2               = false;              // 
	CLK_SYS_SRAM3               = false;              // 
 }

 // enable clock in sleep mode
 register SLEEP_EN0_t SLEEP_EN0 at 0x400080a8;

 type SLEEP_EN1_t {
	CLK_SYS_SRAM4    = false;              // 
	CLK_SYS_SRAM5    = false;              // 
	CLK_SYS_SYSCFG   = false;              // 
	CLK_SYS_SYSINFO  = false;              // 
	CLK_SYS_TBMAN    = false;              // 
	CLK_SYS_TIMER    = false;              // 
	CLK_PERI_UART0   = false;              // 
	CLK_SYS_UART0    = false;              // 
	CLK_PERI_UART1   = false;              // 
	CLK_SYS_UART1    = false;              // 
	CLK_SYS_USBCTRL  = false;              // 
	CLK_USB_USBCTRL  = false;              // 
	CLK_SYS_WATCHDOG = false;              // 
	CLK_SYS_XIP      = false;              // 
	CLK_SYS_XOSC     = false;              // 
 }

 // enable clock in sleep mode
 register SLEEP_EN1_t SLEEP_EN1 at 0x400080ac;

 type ENABLED0_t {
	CLK_SYS_CLOCKS              = false;              // 
	CLK_ADC_ADC                 = false;              // 
	CLK_SYS_ADC                 = false;              // 
	CLK_SYS_BUSCTRL             = false;              // 
	CLK_SYS_BUSFABRIC           = false;              // 
	CLK_SYS_DMA                 = false;              // 
	CLK_SYS_I2C0                = false;              // 
	CLK_SYS_I2C1                = false;              // 
	CLK_SYS_IO                  = false;              // 
	CLK_SYS_JTAG                = false;              // 
	CLK_SYS_VREG_AND_CHIP_RESET = false;              // 
	CLK_SYS_PADS                = false;              // 
	CLK_SYS_PIO0                = false;              // 
	CLK_SYS_PIO1                = false;              // 
	CLK_SYS_PLL_SYS             = false;              // 
	CLK_SYS_PLL_USB             = false;              // 
	CLK_SYS_PSM                 = false;              // 
	CLK_SYS_PWM                 = false;              // 
	CLK_SYS_RESETS              = false;              // 
	CLK_SYS_ROM                 = false;              // 
	CLK_SYS_ROSC                = false;              // 
	CLK_RTC_RTC                 = false;              // 
	CLK_SYS_RTC                 = false;              // 
	CLK_SYS_SIO                 = false;              // 
	CLK_PERI_SPI0               = false;              // 
	CLK_SYS_SPI0                = false;              // 
	CLK_PERI_SPI1               = false;              // 
	CLK_SYS_SPI1                = false;              // 
	CLK_SYS_SRAM0               = false;              // 
	CLK_SYS_SRAM1               = false;              // 
	CLK_SYS_SRAM2               = false;              // 
	CLK_SYS_SRAM3               = false;              // 
 }

 // indicates the state of the clock enable
 register ENABLED0_t ENABLED0 at 0x400080b0;

 type ENABLED1_t {
	CLK_SYS_SRAM4    = false;              // 
	CLK_SYS_SRAM5    = false;              // 
	CLK_SYS_SYSCFG   = false;              // 
	CLK_SYS_SYSINFO  = false;              // 
	CLK_SYS_TBMAN    = false;              // 
	CLK_SYS_TIMER    = false;              // 
	CLK_PERI_UART0   = false;              // 
	CLK_SYS_UART0    = false;              // 
	CLK_PERI_UART1   = false;              // 
	CLK_SYS_UART1    = false;              // 
	CLK_SYS_USBCTRL  = false;              // 
	CLK_USB_USBCTRL  = false;              // 
	CLK_SYS_WATCHDOG = false;              // 
	CLK_SYS_XIP      = false;              // 
	CLK_SYS_XOSC     = false;              // 
 }

 // indicates the state of the clock enable
 register ENABLED1_t ENABLED1 at 0x400080b4;

 type CLOCKS_INTR_t {
	CLK_SYS_RESUS = false;              // 
 }

 // Raw Interrupts
 register CLOCKS_INTR_t CLOCKS_INTR at 0x400080b8;

 type CLOCKS_INTE_t {
	CLK_SYS_RESUS = false;              // 
 }

 // Interrupt Enable
 register CLOCKS_INTE_t CLOCKS_INTE at 0x400080bc;

 type CLOCKS_INTF_t {
	CLK_SYS_RESUS = false;              // 
 }

 // Interrupt Force
 register CLOCKS_INTF_t CLOCKS_INTF at 0x400080c0;

 type CLOCKS_INTS_t {
	CLK_SYS_RESUS = false;              // 
 }

 // Interrupt status after masking & forcing
 register CLOCKS_INTS_t CLOCKS_INTS at 0x400080c4;


/* Types and registers for PADS_BANK0  */

 type PADS_BANK0_VOLTAGE_SELECT_t {
	VOLTAGE_SELECT = false;              // 
 }

 // Voltage select. Per bank control
 register PADS_BANK0_VOLTAGE_SELECT_t PADS_BANK0_VOLTAGE_SELECT at 0x4001c000;

 type GPIO0_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO0_t GPIO0 at 0x4001c004;

 type GPIO1_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO1_t GPIO1 at 0x4001c008;

 type GPIO2_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO2_t GPIO2 at 0x4001c00c;

 type GPIO3_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO3_t GPIO3 at 0x4001c010;

 type GPIO4_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO4_t GPIO4 at 0x4001c014;

 type GPIO5_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO5_t GPIO5 at 0x4001c018;

 type GPIO6_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO6_t GPIO6 at 0x4001c01c;

 type GPIO7_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO7_t GPIO7 at 0x4001c020;

 type GPIO8_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO8_t GPIO8 at 0x4001c024;

 type GPIO9_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO9_t GPIO9 at 0x4001c028;

 type GPIO10_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO10_t GPIO10 at 0x4001c02c;

 type GPIO11_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO11_t GPIO11 at 0x4001c030;

 type GPIO12_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO12_t GPIO12 at 0x4001c034;

 type GPIO13_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO13_t GPIO13 at 0x4001c038;

 type GPIO14_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO14_t GPIO14 at 0x4001c03c;

 type GPIO15_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO15_t GPIO15 at 0x4001c040;

 type GPIO16_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO16_t GPIO16 at 0x4001c044;

 type GPIO17_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO17_t GPIO17 at 0x4001c048;

 type GPIO18_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO18_t GPIO18 at 0x4001c04c;

 type GPIO19_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO19_t GPIO19 at 0x4001c050;

 type GPIO20_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO20_t GPIO20 at 0x4001c054;

 type GPIO21_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO21_t GPIO21 at 0x4001c058;

 type GPIO22_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO22_t GPIO22 at 0x4001c05c;

 type GPIO23_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO23_t GPIO23 at 0x4001c060;

 type GPIO24_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO24_t GPIO24 at 0x4001c064;

 type GPIO25_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO25_t GPIO25 at 0x4001c068;

 type GPIO26_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO26_t GPIO26 at 0x4001c06c;

 type GPIO27_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO27_t GPIO27 at 0x4001c070;

 type GPIO28_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO28_t GPIO28 at 0x4001c074;

 type GPIO29_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO29_t GPIO29 at 0x4001c078;

 type SWCLK_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register SWCLK_t SWCLK at 0x4001c07c;

 type SWD_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register SWD_t SWD at 0x4001c080;


/* Types and registers for PADS_QSPI  */

 type PADS_QSPI_VOLTAGE_SELECT_t {
	VOLTAGE_SELECT = false;              // 
 }

 // Voltage select. Per bank control
 register PADS_QSPI_VOLTAGE_SELECT_t PADS_QSPI_VOLTAGE_SELECT at 0x40020000;

 type GPIO_QSPI_SCLK_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO_QSPI_SCLK_t GPIO_QSPI_SCLK at 0x40020004;

 type GPIO_QSPI_SD0_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO_QSPI_SD0_t GPIO_QSPI_SD0 at 0x40020008;

 type GPIO_QSPI_SD1_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO_QSPI_SD1_t GPIO_QSPI_SD1 at 0x4002000c;

 type GPIO_QSPI_SD2_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO_QSPI_SD2_t GPIO_QSPI_SD2 at 0x40020010;

 type GPIO_QSPI_SD3_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO_QSPI_SD3_t GPIO_QSPI_SD3 at 0x40020014;

 type GPIO_QSPI_SS_t {
	SLEWFAST = false;              // Slew rate control. 1 = Fast, 0 = Slow
	SCHMITT  = false;              // Enable schmitt trigger
	PDE      = false;              // Pull down enable
	PUE      = false;              // Pull up enable
	DRIVE    = uint2(0);           // Drive strength.
	IE       = false;              // Input enable
	OD       = false;              // Output disable. Has priority over output enable from peripherals
 }

 // Pad control register
 register GPIO_QSPI_SS_t GPIO_QSPI_SS at 0x40020018;


/* Types and registers for IO_QSPI  */

 type GPIO_QSPI_SCLK_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO_QSPI_SCLK_STATUS_t GPIO_QSPI_SCLK_STATUS at 0x40018000;

 type GPIO_QSPI_SCLK_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO_QSPI_SCLK_CTRL_t GPIO_QSPI_SCLK_CTRL at 0x40018004;

 type GPIO_QSPI_SS_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO_QSPI_SS_STATUS_t GPIO_QSPI_SS_STATUS at 0x40018008;

 type GPIO_QSPI_SS_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO_QSPI_SS_CTRL_t GPIO_QSPI_SS_CTRL at 0x4001800c;

 type GPIO_QSPI_SD0_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO_QSPI_SD0_STATUS_t GPIO_QSPI_SD0_STATUS at 0x40018010;

 type GPIO_QSPI_SD0_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO_QSPI_SD0_CTRL_t GPIO_QSPI_SD0_CTRL at 0x40018014;

 type GPIO_QSPI_SD1_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO_QSPI_SD1_STATUS_t GPIO_QSPI_SD1_STATUS at 0x40018018;

 type GPIO_QSPI_SD1_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO_QSPI_SD1_CTRL_t GPIO_QSPI_SD1_CTRL at 0x4001801c;

 type GPIO_QSPI_SD2_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO_QSPI_SD2_STATUS_t GPIO_QSPI_SD2_STATUS at 0x40018020;

 type GPIO_QSPI_SD2_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO_QSPI_SD2_CTRL_t GPIO_QSPI_SD2_CTRL at 0x40018024;

 type GPIO_QSPI_SD3_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO_QSPI_SD3_STATUS_t GPIO_QSPI_SD3_STATUS at 0x40018028;

 type GPIO_QSPI_SD3_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO_QSPI_SD3_CTRL_t GPIO_QSPI_SD3_CTRL at 0x4001802c;

 type IO_QSPI_INTR_t {
	GPIO_QSPI_SCLK_LEVEL_LOW  = false;              // 
	GPIO_QSPI_SCLK_LEVEL_HIGH = false;              // 
	GPIO_QSPI_SCLK_EDGE_LOW   = false;              // 
	GPIO_QSPI_SCLK_EDGE_HIGH  = false;              // 
	GPIO_QSPI_SS_LEVEL_LOW    = false;              // 
	GPIO_QSPI_SS_LEVEL_HIGH   = false;              // 
	GPIO_QSPI_SS_EDGE_LOW     = false;              // 
	GPIO_QSPI_SS_EDGE_HIGH    = false;              // 
	GPIO_QSPI_SD0_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD0_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD0_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD0_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD1_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD1_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD1_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD1_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD2_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD2_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD2_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD2_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD3_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD3_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD3_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD3_EDGE_HIGH   = false;              // 
 }

 // Raw Interrupts
 register IO_QSPI_INTR_t IO_QSPI_INTR at 0x40018030;

 type PROC0_INTE_t {
	GPIO_QSPI_SCLK_LEVEL_LOW  = false;              // 
	GPIO_QSPI_SCLK_LEVEL_HIGH = false;              // 
	GPIO_QSPI_SCLK_EDGE_LOW   = false;              // 
	GPIO_QSPI_SCLK_EDGE_HIGH  = false;              // 
	GPIO_QSPI_SS_LEVEL_LOW    = false;              // 
	GPIO_QSPI_SS_LEVEL_HIGH   = false;              // 
	GPIO_QSPI_SS_EDGE_LOW     = false;              // 
	GPIO_QSPI_SS_EDGE_HIGH    = false;              // 
	GPIO_QSPI_SD0_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD0_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD0_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD0_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD1_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD1_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD1_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD1_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD2_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD2_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD2_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD2_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD3_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD3_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD3_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD3_EDGE_HIGH   = false;              // 
 }

 // Interrupt Enable for proc0
 register PROC0_INTE_t PROC0_INTE at 0x40018034;

 type PROC0_INTF_t {
	GPIO_QSPI_SCLK_LEVEL_LOW  = false;              // 
	GPIO_QSPI_SCLK_LEVEL_HIGH = false;              // 
	GPIO_QSPI_SCLK_EDGE_LOW   = false;              // 
	GPIO_QSPI_SCLK_EDGE_HIGH  = false;              // 
	GPIO_QSPI_SS_LEVEL_LOW    = false;              // 
	GPIO_QSPI_SS_LEVEL_HIGH   = false;              // 
	GPIO_QSPI_SS_EDGE_LOW     = false;              // 
	GPIO_QSPI_SS_EDGE_HIGH    = false;              // 
	GPIO_QSPI_SD0_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD0_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD0_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD0_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD1_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD1_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD1_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD1_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD2_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD2_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD2_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD2_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD3_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD3_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD3_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD3_EDGE_HIGH   = false;              // 
 }

 // Interrupt Force for proc0
 register PROC0_INTF_t PROC0_INTF at 0x40018038;

 type PROC0_INTS_t {
	GPIO_QSPI_SCLK_LEVEL_LOW  = false;              // 
	GPIO_QSPI_SCLK_LEVEL_HIGH = false;              // 
	GPIO_QSPI_SCLK_EDGE_LOW   = false;              // 
	GPIO_QSPI_SCLK_EDGE_HIGH  = false;              // 
	GPIO_QSPI_SS_LEVEL_LOW    = false;              // 
	GPIO_QSPI_SS_LEVEL_HIGH   = false;              // 
	GPIO_QSPI_SS_EDGE_LOW     = false;              // 
	GPIO_QSPI_SS_EDGE_HIGH    = false;              // 
	GPIO_QSPI_SD0_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD0_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD0_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD0_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD1_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD1_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD1_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD1_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD2_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD2_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD2_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD2_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD3_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD3_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD3_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD3_EDGE_HIGH   = false;              // 
 }

 // Interrupt status after masking & forcing for proc0
 register PROC0_INTS_t PROC0_INTS at 0x4001803c;

 type PROC1_INTE_t {
	GPIO_QSPI_SCLK_LEVEL_LOW  = false;              // 
	GPIO_QSPI_SCLK_LEVEL_HIGH = false;              // 
	GPIO_QSPI_SCLK_EDGE_LOW   = false;              // 
	GPIO_QSPI_SCLK_EDGE_HIGH  = false;              // 
	GPIO_QSPI_SS_LEVEL_LOW    = false;              // 
	GPIO_QSPI_SS_LEVEL_HIGH   = false;              // 
	GPIO_QSPI_SS_EDGE_LOW     = false;              // 
	GPIO_QSPI_SS_EDGE_HIGH    = false;              // 
	GPIO_QSPI_SD0_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD0_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD0_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD0_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD1_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD1_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD1_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD1_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD2_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD2_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD2_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD2_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD3_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD3_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD3_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD3_EDGE_HIGH   = false;              // 
 }

 // Interrupt Enable for proc1
 register PROC1_INTE_t PROC1_INTE at 0x40018040;

 type PROC1_INTF_t {
	GPIO_QSPI_SCLK_LEVEL_LOW  = false;              // 
	GPIO_QSPI_SCLK_LEVEL_HIGH = false;              // 
	GPIO_QSPI_SCLK_EDGE_LOW   = false;              // 
	GPIO_QSPI_SCLK_EDGE_HIGH  = false;              // 
	GPIO_QSPI_SS_LEVEL_LOW    = false;              // 
	GPIO_QSPI_SS_LEVEL_HIGH   = false;              // 
	GPIO_QSPI_SS_EDGE_LOW     = false;              // 
	GPIO_QSPI_SS_EDGE_HIGH    = false;              // 
	GPIO_QSPI_SD0_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD0_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD0_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD0_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD1_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD1_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD1_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD1_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD2_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD2_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD2_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD2_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD3_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD3_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD3_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD3_EDGE_HIGH   = false;              // 
 }

 // Interrupt Force for proc1
 register PROC1_INTF_t PROC1_INTF at 0x40018044;

 type PROC1_INTS_t {
	GPIO_QSPI_SCLK_LEVEL_LOW  = false;              // 
	GPIO_QSPI_SCLK_LEVEL_HIGH = false;              // 
	GPIO_QSPI_SCLK_EDGE_LOW   = false;              // 
	GPIO_QSPI_SCLK_EDGE_HIGH  = false;              // 
	GPIO_QSPI_SS_LEVEL_LOW    = false;              // 
	GPIO_QSPI_SS_LEVEL_HIGH   = false;              // 
	GPIO_QSPI_SS_EDGE_LOW     = false;              // 
	GPIO_QSPI_SS_EDGE_HIGH    = false;              // 
	GPIO_QSPI_SD0_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD0_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD0_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD0_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD1_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD1_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD1_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD1_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD2_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD2_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD2_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD2_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD3_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD3_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD3_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD3_EDGE_HIGH   = false;              // 
 }

 // Interrupt status after masking & forcing for proc1
 register PROC1_INTS_t PROC1_INTS at 0x40018048;

 type DORMANT_WAKE_INTE_t {
	GPIO_QSPI_SCLK_LEVEL_LOW  = false;              // 
	GPIO_QSPI_SCLK_LEVEL_HIGH = false;              // 
	GPIO_QSPI_SCLK_EDGE_LOW   = false;              // 
	GPIO_QSPI_SCLK_EDGE_HIGH  = false;              // 
	GPIO_QSPI_SS_LEVEL_LOW    = false;              // 
	GPIO_QSPI_SS_LEVEL_HIGH   = false;              // 
	GPIO_QSPI_SS_EDGE_LOW     = false;              // 
	GPIO_QSPI_SS_EDGE_HIGH    = false;              // 
	GPIO_QSPI_SD0_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD0_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD0_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD0_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD1_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD1_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD1_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD1_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD2_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD2_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD2_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD2_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD3_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD3_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD3_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD3_EDGE_HIGH   = false;              // 
 }

 // Interrupt Enable for dormant_wake
 register DORMANT_WAKE_INTE_t DORMANT_WAKE_INTE at 0x4001804c;

 type DORMANT_WAKE_INTF_t {
	GPIO_QSPI_SCLK_LEVEL_LOW  = false;              // 
	GPIO_QSPI_SCLK_LEVEL_HIGH = false;              // 
	GPIO_QSPI_SCLK_EDGE_LOW   = false;              // 
	GPIO_QSPI_SCLK_EDGE_HIGH  = false;              // 
	GPIO_QSPI_SS_LEVEL_LOW    = false;              // 
	GPIO_QSPI_SS_LEVEL_HIGH   = false;              // 
	GPIO_QSPI_SS_EDGE_LOW     = false;              // 
	GPIO_QSPI_SS_EDGE_HIGH    = false;              // 
	GPIO_QSPI_SD0_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD0_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD0_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD0_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD1_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD1_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD1_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD1_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD2_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD2_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD2_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD2_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD3_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD3_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD3_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD3_EDGE_HIGH   = false;              // 
 }

 // Interrupt Force for dormant_wake
 register DORMANT_WAKE_INTF_t DORMANT_WAKE_INTF at 0x40018050;

 type DORMANT_WAKE_INTS_t {
	GPIO_QSPI_SCLK_LEVEL_LOW  = false;              // 
	GPIO_QSPI_SCLK_LEVEL_HIGH = false;              // 
	GPIO_QSPI_SCLK_EDGE_LOW   = false;              // 
	GPIO_QSPI_SCLK_EDGE_HIGH  = false;              // 
	GPIO_QSPI_SS_LEVEL_LOW    = false;              // 
	GPIO_QSPI_SS_LEVEL_HIGH   = false;              // 
	GPIO_QSPI_SS_EDGE_LOW     = false;              // 
	GPIO_QSPI_SS_EDGE_HIGH    = false;              // 
	GPIO_QSPI_SD0_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD0_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD0_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD0_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD1_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD1_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD1_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD1_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD2_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD2_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD2_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD2_EDGE_HIGH   = false;              // 
	GPIO_QSPI_SD3_LEVEL_LOW   = false;              // 
	GPIO_QSPI_SD3_LEVEL_HIGH  = false;              // 
	GPIO_QSPI_SD3_EDGE_LOW    = false;              // 
	GPIO_QSPI_SD3_EDGE_HIGH   = false;              // 
 }

 // Interrupt status after masking & forcing for dormant_wake
 register DORMANT_WAKE_INTS_t DORMANT_WAKE_INTS at 0x40018054;


/* Types and registers for IO_BANK0  */

 type GPIO0_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO0_STATUS_t GPIO0_STATUS at 0x40014000;

 type GPIO0_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO0_CTRL_t GPIO0_CTRL at 0x40014004;

 type GPIO1_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO1_STATUS_t GPIO1_STATUS at 0x40014008;

 type GPIO1_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO1_CTRL_t GPIO1_CTRL at 0x4001400c;

 type GPIO2_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO2_STATUS_t GPIO2_STATUS at 0x40014010;

 type GPIO2_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO2_CTRL_t GPIO2_CTRL at 0x40014014;

 type GPIO3_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO3_STATUS_t GPIO3_STATUS at 0x40014018;

 type GPIO3_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO3_CTRL_t GPIO3_CTRL at 0x4001401c;

 type GPIO4_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO4_STATUS_t GPIO4_STATUS at 0x40014020;

 type GPIO4_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO4_CTRL_t GPIO4_CTRL at 0x40014024;

 type GPIO5_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO5_STATUS_t GPIO5_STATUS at 0x40014028;

 type GPIO5_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO5_CTRL_t GPIO5_CTRL at 0x4001402c;

 type GPIO6_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO6_STATUS_t GPIO6_STATUS at 0x40014030;

 type GPIO6_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO6_CTRL_t GPIO6_CTRL at 0x40014034;

 type GPIO7_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO7_STATUS_t GPIO7_STATUS at 0x40014038;

 type GPIO7_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO7_CTRL_t GPIO7_CTRL at 0x4001403c;

 type GPIO8_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO8_STATUS_t GPIO8_STATUS at 0x40014040;

 type GPIO8_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO8_CTRL_t GPIO8_CTRL at 0x40014044;

 type GPIO9_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO9_STATUS_t GPIO9_STATUS at 0x40014048;

 type GPIO9_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO9_CTRL_t GPIO9_CTRL at 0x4001404c;

 type GPIO10_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO10_STATUS_t GPIO10_STATUS at 0x40014050;

 type GPIO10_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO10_CTRL_t GPIO10_CTRL at 0x40014054;

 type GPIO11_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO11_STATUS_t GPIO11_STATUS at 0x40014058;

 type GPIO11_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO11_CTRL_t GPIO11_CTRL at 0x4001405c;

 type GPIO12_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO12_STATUS_t GPIO12_STATUS at 0x40014060;

 type GPIO12_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO12_CTRL_t GPIO12_CTRL at 0x40014064;

 type GPIO13_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO13_STATUS_t GPIO13_STATUS at 0x40014068;

 type GPIO13_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO13_CTRL_t GPIO13_CTRL at 0x4001406c;

 type GPIO14_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO14_STATUS_t GPIO14_STATUS at 0x40014070;

 type GPIO14_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO14_CTRL_t GPIO14_CTRL at 0x40014074;

 type GPIO15_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO15_STATUS_t GPIO15_STATUS at 0x40014078;

 type GPIO15_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO15_CTRL_t GPIO15_CTRL at 0x4001407c;

 type GPIO16_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO16_STATUS_t GPIO16_STATUS at 0x40014080;

 type GPIO16_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO16_CTRL_t GPIO16_CTRL at 0x40014084;

 type GPIO17_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO17_STATUS_t GPIO17_STATUS at 0x40014088;

 type GPIO17_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO17_CTRL_t GPIO17_CTRL at 0x4001408c;

 type GPIO18_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO18_STATUS_t GPIO18_STATUS at 0x40014090;

 type GPIO18_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO18_CTRL_t GPIO18_CTRL at 0x40014094;

 type GPIO19_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO19_STATUS_t GPIO19_STATUS at 0x40014098;

 type GPIO19_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO19_CTRL_t GPIO19_CTRL at 0x4001409c;

 type GPIO20_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO20_STATUS_t GPIO20_STATUS at 0x400140a0;

 type GPIO20_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO20_CTRL_t GPIO20_CTRL at 0x400140a4;

 type GPIO21_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO21_STATUS_t GPIO21_STATUS at 0x400140a8;

 type GPIO21_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO21_CTRL_t GPIO21_CTRL at 0x400140ac;

 type GPIO22_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO22_STATUS_t GPIO22_STATUS at 0x400140b0;

 type GPIO22_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO22_CTRL_t GPIO22_CTRL at 0x400140b4;

 type GPIO23_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO23_STATUS_t GPIO23_STATUS at 0x400140b8;

 type GPIO23_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO23_CTRL_t GPIO23_CTRL at 0x400140bc;

 type GPIO24_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO24_STATUS_t GPIO24_STATUS at 0x400140c0;

 type GPIO24_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO24_CTRL_t GPIO24_CTRL at 0x400140c4;

 type GPIO25_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO25_STATUS_t GPIO25_STATUS at 0x400140c8;

 type GPIO25_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO25_CTRL_t GPIO25_CTRL at 0x400140cc;

 type GPIO26_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO26_STATUS_t GPIO26_STATUS at 0x400140d0;

 type GPIO26_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO26_CTRL_t GPIO26_CTRL at 0x400140d4;

 type GPIO27_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO27_STATUS_t GPIO27_STATUS at 0x400140d8;

 type GPIO27_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO27_CTRL_t GPIO27_CTRL at 0x400140dc;

 type GPIO28_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO28_STATUS_t GPIO28_STATUS at 0x400140e0;

 type GPIO28_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO28_CTRL_t GPIO28_CTRL at 0x400140e4;

 type GPIO29_STATUS_t {
	_res1       = uint8(0);           // Reserved, 8 bits
	OUTFROMPERI = false;              // output signal from selected peripheral, before register override is applied
	OUTTOPAD    = false;              // output signal to pad after register override is applied
	_res2       = uint2(0);           // Reserved, 2 bits
	OEFROMPERI  = false;              // output enable from selected peripheral, before register override is applied
	OETOPAD     = false;              // output enable to pad after register override is applied
	_res3       = uint3(0);           // Reserved, 3 bits
	INFROMPAD   = false;              // input signal from pad, before override is applied
	_res4       = false;              // Reserved, 1 bits
	INTOPERI    = false;              // input signal to peripheral, after override is applied
	_res5       = uint4(0);           // Reserved, 4 bits
	IRQFROMPAD  = false;              // interrupt from pad before override is applied
	_res6       = false;              // Reserved, 1 bits
	IRQTOPROC   = false;              // interrupt to processors, after override is applied
 }

 // GPIO status
 register GPIO29_STATUS_t GPIO29_STATUS at 0x400140e8;

 type GPIO29_CTRL_t {
	FUNCSEL = uint5(0);           // 0-31 -> selects pin function according to the gpio table 31 == NULL
	_res1   = uint3(0);           // Reserved, 3 bits
	OUTOVER = uint2(0);           // 
	_res2   = uint2(0);           // Reserved, 2 bits
	OEOVER  = uint2(0);           // 
	_res3   = uint2(0);           // Reserved, 2 bits
	INOVER  = uint2(0);           // 
	_res4   = uint8(0);           // Reserved, 10 bits
	_res5   = uint2(0);           // 
	IRQOVER = uint2(0);           // 
 }

 // GPIO control including function select and overrides.
 register GPIO29_CTRL_t GPIO29_CTRL at 0x400140ec;

 type INTR0_t {
	GPIO0_LEVEL_LOW  = false;              // 
	GPIO0_LEVEL_HIGH = false;              // 
	GPIO0_EDGE_LOW   = false;              // 
	GPIO0_EDGE_HIGH  = false;              // 
	GPIO1_LEVEL_LOW  = false;              // 
	GPIO1_LEVEL_HIGH = false;              // 
	GPIO1_EDGE_LOW   = false;              // 
	GPIO1_EDGE_HIGH  = false;              // 
	GPIO2_LEVEL_LOW  = false;              // 
	GPIO2_LEVEL_HIGH = false;              // 
	GPIO2_EDGE_LOW   = false;              // 
	GPIO2_EDGE_HIGH  = false;              // 
	GPIO3_LEVEL_LOW  = false;              // 
	GPIO3_LEVEL_HIGH = false;              // 
	GPIO3_EDGE_LOW   = false;              // 
	GPIO3_EDGE_HIGH  = false;              // 
	GPIO4_LEVEL_LOW  = false;              // 
	GPIO4_LEVEL_HIGH = false;              // 
	GPIO4_EDGE_LOW   = false;              // 
	GPIO4_EDGE_HIGH  = false;              // 
	GPIO5_LEVEL_LOW  = false;              // 
	GPIO5_LEVEL_HIGH = false;              // 
	GPIO5_EDGE_LOW   = false;              // 
	GPIO5_EDGE_HIGH  = false;              // 
	GPIO6_LEVEL_LOW  = false;              // 
	GPIO6_LEVEL_HIGH = false;              // 
	GPIO6_EDGE_LOW   = false;              // 
	GPIO6_EDGE_HIGH  = false;              // 
	GPIO7_LEVEL_LOW  = false;              // 
	GPIO7_LEVEL_HIGH = false;              // 
	GPIO7_EDGE_LOW   = false;              // 
	GPIO7_EDGE_HIGH  = false;              // 
 }

 // Raw Interrupts
 register INTR0_t INTR0 at 0x400140f0;

 type IO_BANK0_INTR1_t {
	GPIO8_LEVEL_LOW   = false;              // 
	GPIO8_LEVEL_HIGH  = false;              // 
	GPIO8_EDGE_LOW    = false;              // 
	GPIO8_EDGE_HIGH   = false;              // 
	GPIO9_LEVEL_LOW   = false;              // 
	GPIO9_LEVEL_HIGH  = false;              // 
	GPIO9_EDGE_LOW    = false;              // 
	GPIO9_EDGE_HIGH   = false;              // 
	GPIO10_LEVEL_LOW  = false;              // 
	GPIO10_LEVEL_HIGH = false;              // 
	GPIO10_EDGE_LOW   = false;              // 
	GPIO10_EDGE_HIGH  = false;              // 
	GPIO11_LEVEL_LOW  = false;              // 
	GPIO11_LEVEL_HIGH = false;              // 
	GPIO11_EDGE_LOW   = false;              // 
	GPIO11_EDGE_HIGH  = false;              // 
	GPIO12_LEVEL_LOW  = false;              // 
	GPIO12_LEVEL_HIGH = false;              // 
	GPIO12_EDGE_LOW   = false;              // 
	GPIO12_EDGE_HIGH  = false;              // 
	GPIO13_LEVEL_LOW  = false;              // 
	GPIO13_LEVEL_HIGH = false;              // 
	GPIO13_EDGE_LOW   = false;              // 
	GPIO13_EDGE_HIGH  = false;              // 
	GPIO14_LEVEL_LOW  = false;              // 
	GPIO14_LEVEL_HIGH = false;              // 
	GPIO14_EDGE_LOW   = false;              // 
	GPIO14_EDGE_HIGH  = false;              // 
	GPIO15_LEVEL_LOW  = false;              // 
	GPIO15_LEVEL_HIGH = false;              // 
	GPIO15_EDGE_LOW   = false;              // 
	GPIO15_EDGE_HIGH  = false;              // 
 }

 // Raw Interrupts
 register IO_BANK0_INTR1_t IO_BANK0_INTR1 at 0x400140f4;

 type INTR2_t {
	GPIO16_LEVEL_LOW  = false;              // 
	GPIO16_LEVEL_HIGH = false;              // 
	GPIO16_EDGE_LOW   = false;              // 
	GPIO16_EDGE_HIGH  = false;              // 
	GPIO17_LEVEL_LOW  = false;              // 
	GPIO17_LEVEL_HIGH = false;              // 
	GPIO17_EDGE_LOW   = false;              // 
	GPIO17_EDGE_HIGH  = false;              // 
	GPIO18_LEVEL_LOW  = false;              // 
	GPIO18_LEVEL_HIGH = false;              // 
	GPIO18_EDGE_LOW   = false;              // 
	GPIO18_EDGE_HIGH  = false;              // 
	GPIO19_LEVEL_LOW  = false;              // 
	GPIO19_LEVEL_HIGH = false;              // 
	GPIO19_EDGE_LOW   = false;              // 
	GPIO19_EDGE_HIGH  = false;              // 
	GPIO20_LEVEL_LOW  = false;              // 
	GPIO20_LEVEL_HIGH = false;              // 
	GPIO20_EDGE_LOW   = false;              // 
	GPIO20_EDGE_HIGH  = false;              // 
	GPIO21_LEVEL_LOW  = false;              // 
	GPIO21_LEVEL_HIGH = false;              // 
	GPIO21_EDGE_LOW   = false;              // 
	GPIO21_EDGE_HIGH  = false;              // 
	GPIO22_LEVEL_LOW  = false;              // 
	GPIO22_LEVEL_HIGH = false;              // 
	GPIO22_EDGE_LOW   = false;              // 
	GPIO22_EDGE_HIGH  = false;              // 
	GPIO23_LEVEL_LOW  = false;              // 
	GPIO23_LEVEL_HIGH = false;              // 
	GPIO23_EDGE_LOW   = false;              // 
	GPIO23_EDGE_HIGH  = false;              // 
 }

 // Raw Interrupts
 register INTR2_t INTR2 at 0x400140f8;

 type INTR3_t {
	GPIO24_LEVEL_LOW  = false;              // 
	GPIO24_LEVEL_HIGH = false;              // 
	GPIO24_EDGE_LOW   = false;              // 
	GPIO24_EDGE_HIGH  = false;              // 
	GPIO25_LEVEL_LOW  = false;              // 
	GPIO25_LEVEL_HIGH = false;              // 
	GPIO25_EDGE_LOW   = false;              // 
	GPIO25_EDGE_HIGH  = false;              // 
	GPIO26_LEVEL_LOW  = false;              // 
	GPIO26_LEVEL_HIGH = false;              // 
	GPIO26_EDGE_LOW   = false;              // 
	GPIO26_EDGE_HIGH  = false;              // 
	GPIO27_LEVEL_LOW  = false;              // 
	GPIO27_LEVEL_HIGH = false;              // 
	GPIO27_EDGE_LOW   = false;              // 
	GPIO27_EDGE_HIGH  = false;              // 
	GPIO28_LEVEL_LOW  = false;              // 
	GPIO28_LEVEL_HIGH = false;              // 
	GPIO28_EDGE_LOW   = false;              // 
	GPIO28_EDGE_HIGH  = false;              // 
	GPIO29_LEVEL_LOW  = false;              // 
	GPIO29_LEVEL_HIGH = false;              // 
	GPIO29_EDGE_LOW   = false;              // 
	GPIO29_EDGE_HIGH  = false;              // 
 }

 // Raw Interrupts
 register INTR3_t INTR3 at 0x400140fc;

 type PROC0_INTE0_t {
	GPIO0_LEVEL_LOW  = false;              // 
	GPIO0_LEVEL_HIGH = false;              // 
	GPIO0_EDGE_LOW   = false;              // 
	GPIO0_EDGE_HIGH  = false;              // 
	GPIO1_LEVEL_LOW  = false;              // 
	GPIO1_LEVEL_HIGH = false;              // 
	GPIO1_EDGE_LOW   = false;              // 
	GPIO1_EDGE_HIGH  = false;              // 
	GPIO2_LEVEL_LOW  = false;              // 
	GPIO2_LEVEL_HIGH = false;              // 
	GPIO2_EDGE_LOW   = false;              // 
	GPIO2_EDGE_HIGH  = false;              // 
	GPIO3_LEVEL_LOW  = false;              // 
	GPIO3_LEVEL_HIGH = false;              // 
	GPIO3_EDGE_LOW   = false;              // 
	GPIO3_EDGE_HIGH  = false;              // 
	GPIO4_LEVEL_LOW  = false;              // 
	GPIO4_LEVEL_HIGH = false;              // 
	GPIO4_EDGE_LOW   = false;              // 
	GPIO4_EDGE_HIGH  = false;              // 
	GPIO5_LEVEL_LOW  = false;              // 
	GPIO5_LEVEL_HIGH = false;              // 
	GPIO5_EDGE_LOW   = false;              // 
	GPIO5_EDGE_HIGH  = false;              // 
	GPIO6_LEVEL_LOW  = false;              // 
	GPIO6_LEVEL_HIGH = false;              // 
	GPIO6_EDGE_LOW   = false;              // 
	GPIO6_EDGE_HIGH  = false;              // 
	GPIO7_LEVEL_LOW  = false;              // 
	GPIO7_LEVEL_HIGH = false;              // 
	GPIO7_EDGE_LOW   = false;              // 
	GPIO7_EDGE_HIGH  = false;              // 
 }

 // Interrupt Enable for proc0
 register PROC0_INTE0_t PROC0_INTE0 at 0x40014100;

 type PROC0_INTE1_t {
	GPIO8_LEVEL_LOW   = false;              // 
	GPIO8_LEVEL_HIGH  = false;              // 
	GPIO8_EDGE_LOW    = false;              // 
	GPIO8_EDGE_HIGH   = false;              // 
	GPIO9_LEVEL_LOW   = false;              // 
	GPIO9_LEVEL_HIGH  = false;              // 
	GPIO9_EDGE_LOW    = false;              // 
	GPIO9_EDGE_HIGH   = false;              // 
	GPIO10_LEVEL_LOW  = false;              // 
	GPIO10_LEVEL_HIGH = false;              // 
	GPIO10_EDGE_LOW   = false;              // 
	GPIO10_EDGE_HIGH  = false;              // 
	GPIO11_LEVEL_LOW  = false;              // 
	GPIO11_LEVEL_HIGH = false;              // 
	GPIO11_EDGE_LOW   = false;              // 
	GPIO11_EDGE_HIGH  = false;              // 
	GPIO12_LEVEL_LOW  = false;              // 
	GPIO12_LEVEL_HIGH = false;              // 
	GPIO12_EDGE_LOW   = false;              // 
	GPIO12_EDGE_HIGH  = false;              // 
	GPIO13_LEVEL_LOW  = false;              // 
	GPIO13_LEVEL_HIGH = false;              // 
	GPIO13_EDGE_LOW   = false;              // 
	GPIO13_EDGE_HIGH  = false;              // 
	GPIO14_LEVEL_LOW  = false;              // 
	GPIO14_LEVEL_HIGH = false;              // 
	GPIO14_EDGE_LOW   = false;              // 
	GPIO14_EDGE_HIGH  = false;              // 
	GPIO15_LEVEL_LOW  = false;              // 
	GPIO15_LEVEL_HIGH = false;              // 
	GPIO15_EDGE_LOW   = false;              // 
	GPIO15_EDGE_HIGH  = false;              // 
 }

 // Interrupt Enable for proc0
 register PROC0_INTE1_t PROC0_INTE1 at 0x40014104;

 type PROC0_INTE2_t {
	GPIO16_LEVEL_LOW  = false;              // 
	GPIO16_LEVEL_HIGH = false;              // 
	GPIO16_EDGE_LOW   = false;              // 
	GPIO16_EDGE_HIGH  = false;              // 
	GPIO17_LEVEL_LOW  = false;              // 
	GPIO17_LEVEL_HIGH = false;              // 
	GPIO17_EDGE_LOW   = false;              // 
	GPIO17_EDGE_HIGH  = false;              // 
	GPIO18_LEVEL_LOW  = false;              // 
	GPIO18_LEVEL_HIGH = false;              // 
	GPIO18_EDGE_LOW   = false;              // 
	GPIO18_EDGE_HIGH  = false;              // 
	GPIO19_LEVEL_LOW  = false;              // 
	GPIO19_LEVEL_HIGH = false;              // 
	GPIO19_EDGE_LOW   = false;              // 
	GPIO19_EDGE_HIGH  = false;              // 
	GPIO20_LEVEL_LOW  = false;              // 
	GPIO20_LEVEL_HIGH = false;              // 
	GPIO20_EDGE_LOW   = false;              // 
	GPIO20_EDGE_HIGH  = false;              // 
	GPIO21_LEVEL_LOW  = false;              // 
	GPIO21_LEVEL_HIGH = false;              // 
	GPIO21_EDGE_LOW   = false;              // 
	GPIO21_EDGE_HIGH  = false;              // 
	GPIO22_LEVEL_LOW  = false;              // 
	GPIO22_LEVEL_HIGH = false;              // 
	GPIO22_EDGE_LOW   = false;              // 
	GPIO22_EDGE_HIGH  = false;              // 
	GPIO23_LEVEL_LOW  = false;              // 
	GPIO23_LEVEL_HIGH = false;              // 
	GPIO23_EDGE_LOW   = false;              // 
	GPIO23_EDGE_HIGH  = false;              // 
 }

 // Interrupt Enable for proc0
 register PROC0_INTE2_t PROC0_INTE2 at 0x40014108;

 type PROC0_INTE3_t {
	GPIO24_LEVEL_LOW  = false;              // 
	GPIO24_LEVEL_HIGH = false;              // 
	GPIO24_EDGE_LOW   = false;              // 
	GPIO24_EDGE_HIGH  = false;              // 
	GPIO25_LEVEL_LOW  = false;              // 
	GPIO25_LEVEL_HIGH = false;              // 
	GPIO25_EDGE_LOW   = false;              // 
	GPIO25_EDGE_HIGH  = false;              // 
	GPIO26_LEVEL_LOW  = false;              // 
	GPIO26_LEVEL_HIGH = false;              // 
	GPIO26_EDGE_LOW   = false;              // 
	GPIO26_EDGE_HIGH  = false;              // 
	GPIO27_LEVEL_LOW  = false;              // 
	GPIO27_LEVEL_HIGH = false;              // 
	GPIO27_EDGE_LOW   = false;              // 
	GPIO27_EDGE_HIGH  = false;              // 
	GPIO28_LEVEL_LOW  = false;              // 
	GPIO28_LEVEL_HIGH = false;              // 
	GPIO28_EDGE_LOW   = false;              // 
	GPIO28_EDGE_HIGH  = false;              // 
	GPIO29_LEVEL_LOW  = false;              // 
	GPIO29_LEVEL_HIGH = false;              // 
	GPIO29_EDGE_LOW   = false;              // 
	GPIO29_EDGE_HIGH  = false;              // 
 }

 // Interrupt Enable for proc0
 register PROC0_INTE3_t PROC0_INTE3 at 0x4001410c;

 type PROC0_INTF0_t {
	GPIO0_LEVEL_LOW  = false;              // 
	GPIO0_LEVEL_HIGH = false;              // 
	GPIO0_EDGE_LOW   = false;              // 
	GPIO0_EDGE_HIGH  = false;              // 
	GPIO1_LEVEL_LOW  = false;              // 
	GPIO1_LEVEL_HIGH = false;              // 
	GPIO1_EDGE_LOW   = false;              // 
	GPIO1_EDGE_HIGH  = false;              // 
	GPIO2_LEVEL_LOW  = false;              // 
	GPIO2_LEVEL_HIGH = false;              // 
	GPIO2_EDGE_LOW   = false;              // 
	GPIO2_EDGE_HIGH  = false;              // 
	GPIO3_LEVEL_LOW  = false;              // 
	GPIO3_LEVEL_HIGH = false;              // 
	GPIO3_EDGE_LOW   = false;              // 
	GPIO3_EDGE_HIGH  = false;              // 
	GPIO4_LEVEL_LOW  = false;              // 
	GPIO4_LEVEL_HIGH = false;              // 
	GPIO4_EDGE_LOW   = false;              // 
	GPIO4_EDGE_HIGH  = false;              // 
	GPIO5_LEVEL_LOW  = false;              // 
	GPIO5_LEVEL_HIGH = false;              // 
	GPIO5_EDGE_LOW   = false;              // 
	GPIO5_EDGE_HIGH  = false;              // 
	GPIO6_LEVEL_LOW  = false;              // 
	GPIO6_LEVEL_HIGH = false;              // 
	GPIO6_EDGE_LOW   = false;              // 
	GPIO6_EDGE_HIGH  = false;              // 
	GPIO7_LEVEL_LOW  = false;              // 
	GPIO7_LEVEL_HIGH = false;              // 
	GPIO7_EDGE_LOW   = false;              // 
	GPIO7_EDGE_HIGH  = false;              // 
 }

 // Interrupt Force for proc0
 register PROC0_INTF0_t PROC0_INTF0 at 0x40014110;

 type PROC0_INTF1_t {
	GPIO8_LEVEL_LOW   = false;              // 
	GPIO8_LEVEL_HIGH  = false;              // 
	GPIO8_EDGE_LOW    = false;              // 
	GPIO8_EDGE_HIGH   = false;              // 
	GPIO9_LEVEL_LOW   = false;              // 
	GPIO9_LEVEL_HIGH  = false;              // 
	GPIO9_EDGE_LOW    = false;              // 
	GPIO9_EDGE_HIGH   = false;              // 
	GPIO10_LEVEL_LOW  = false;              // 
	GPIO10_LEVEL_HIGH = false;              // 
	GPIO10_EDGE_LOW   = false;              // 
	GPIO10_EDGE_HIGH  = false;              // 
	GPIO11_LEVEL_LOW  = false;              // 
	GPIO11_LEVEL_HIGH = false;              // 
	GPIO11_EDGE_LOW   = false;              // 
	GPIO11_EDGE_HIGH  = false;              // 
	GPIO12_LEVEL_LOW  = false;              // 
	GPIO12_LEVEL_HIGH = false;              // 
	GPIO12_EDGE_LOW   = false;              // 
	GPIO12_EDGE_HIGH  = false;              // 
	GPIO13_LEVEL_LOW  = false;              // 
	GPIO13_LEVEL_HIGH = false;              // 
	GPIO13_EDGE_LOW   = false;              // 
	GPIO13_EDGE_HIGH  = false;              // 
	GPIO14_LEVEL_LOW  = false;              // 
	GPIO14_LEVEL_HIGH = false;              // 
	GPIO14_EDGE_LOW   = false;              // 
	GPIO14_EDGE_HIGH  = false;              // 
	GPIO15_LEVEL_LOW  = false;              // 
	GPIO15_LEVEL_HIGH = false;              // 
	GPIO15_EDGE_LOW   = false;              // 
	GPIO15_EDGE_HIGH  = false;              // 
 }

 // Interrupt Force for proc0
 register PROC0_INTF1_t PROC0_INTF1 at 0x40014114;

 type PROC0_INTF2_t {
	GPIO16_LEVEL_LOW  = false;              // 
	GPIO16_LEVEL_HIGH = false;              // 
	GPIO16_EDGE_LOW   = false;              // 
	GPIO16_EDGE_HIGH  = false;              // 
	GPIO17_LEVEL_LOW  = false;              // 
	GPIO17_LEVEL_HIGH = false;              // 
	GPIO17_EDGE_LOW   = false;              // 
	GPIO17_EDGE_HIGH  = false;              // 
	GPIO18_LEVEL_LOW  = false;              // 
	GPIO18_LEVEL_HIGH = false;              // 
	GPIO18_EDGE_LOW   = false;              // 
	GPIO18_EDGE_HIGH  = false;              // 
	GPIO19_LEVEL_LOW  = false;              // 
	GPIO19_LEVEL_HIGH = false;              // 
	GPIO19_EDGE_LOW   = false;              // 
	GPIO19_EDGE_HIGH  = false;              // 
	GPIO20_LEVEL_LOW  = false;              // 
	GPIO20_LEVEL_HIGH = false;              // 
	GPIO20_EDGE_LOW   = false;              // 
	GPIO20_EDGE_HIGH  = false;              // 
	GPIO21_LEVEL_LOW  = false;              // 
	GPIO21_LEVEL_HIGH = false;              // 
	GPIO21_EDGE_LOW   = false;              // 
	GPIO21_EDGE_HIGH  = false;              // 
	GPIO22_LEVEL_LOW  = false;              // 
	GPIO22_LEVEL_HIGH = false;              // 
	GPIO22_EDGE_LOW   = false;              // 
	GPIO22_EDGE_HIGH  = false;              // 
	GPIO23_LEVEL_LOW  = false;              // 
	GPIO23_LEVEL_HIGH = false;              // 
	GPIO23_EDGE_LOW   = false;              // 
	GPIO23_EDGE_HIGH  = false;              // 
 }

 // Interrupt Force for proc0
 register PROC0_INTF2_t PROC0_INTF2 at 0x40014118;

 type PROC0_INTF3_t {
	GPIO24_LEVEL_LOW  = false;              // 
	GPIO24_LEVEL_HIGH = false;              // 
	GPIO24_EDGE_LOW   = false;              // 
	GPIO24_EDGE_HIGH  = false;              // 
	GPIO25_LEVEL_LOW  = false;              // 
	GPIO25_LEVEL_HIGH = false;              // 
	GPIO25_EDGE_LOW   = false;              // 
	GPIO25_EDGE_HIGH  = false;              // 
	GPIO26_LEVEL_LOW  = false;              // 
	GPIO26_LEVEL_HIGH = false;              // 
	GPIO26_EDGE_LOW   = false;              // 
	GPIO26_EDGE_HIGH  = false;              // 
	GPIO27_LEVEL_LOW  = false;              // 
	GPIO27_LEVEL_HIGH = false;              // 
	GPIO27_EDGE_LOW   = false;              // 
	GPIO27_EDGE_HIGH  = false;              // 
	GPIO28_LEVEL_LOW  = false;              // 
	GPIO28_LEVEL_HIGH = false;              // 
	GPIO28_EDGE_LOW   = false;              // 
	GPIO28_EDGE_HIGH  = false;              // 
	GPIO29_LEVEL_LOW  = false;              // 
	GPIO29_LEVEL_HIGH = false;              // 
	GPIO29_EDGE_LOW   = false;              // 
	GPIO29_EDGE_HIGH  = false;              // 
 }

 // Interrupt Force for proc0
 register PROC0_INTF3_t PROC0_INTF3 at 0x4001411c;

 type PROC0_INTS0_t {
	GPIO0_LEVEL_LOW  = false;              // 
	GPIO0_LEVEL_HIGH = false;              // 
	GPIO0_EDGE_LOW   = false;              // 
	GPIO0_EDGE_HIGH  = false;              // 
	GPIO1_LEVEL_LOW  = false;              // 
	GPIO1_LEVEL_HIGH = false;              // 
	GPIO1_EDGE_LOW   = false;              // 
	GPIO1_EDGE_HIGH  = false;              // 
	GPIO2_LEVEL_LOW  = false;              // 
	GPIO2_LEVEL_HIGH = false;              // 
	GPIO2_EDGE_LOW   = false;              // 
	GPIO2_EDGE_HIGH  = false;              // 
	GPIO3_LEVEL_LOW  = false;              // 
	GPIO3_LEVEL_HIGH = false;              // 
	GPIO3_EDGE_LOW   = false;              // 
	GPIO3_EDGE_HIGH  = false;              // 
	GPIO4_LEVEL_LOW  = false;              // 
	GPIO4_LEVEL_HIGH = false;              // 
	GPIO4_EDGE_LOW   = false;              // 
	GPIO4_EDGE_HIGH  = false;              // 
	GPIO5_LEVEL_LOW  = false;              // 
	GPIO5_LEVEL_HIGH = false;              // 
	GPIO5_EDGE_LOW   = false;              // 
	GPIO5_EDGE_HIGH  = false;              // 
	GPIO6_LEVEL_LOW  = false;              // 
	GPIO6_LEVEL_HIGH = false;              // 
	GPIO6_EDGE_LOW   = false;              // 
	GPIO6_EDGE_HIGH  = false;              // 
	GPIO7_LEVEL_LOW  = false;              // 
	GPIO7_LEVEL_HIGH = false;              // 
	GPIO7_EDGE_LOW   = false;              // 
	GPIO7_EDGE_HIGH  = false;              // 
 }

 // Interrupt status after masking & forcing for proc0
 register PROC0_INTS0_t PROC0_INTS0 at 0x40014120;

 type PROC0_INTS1_t {
	GPIO8_LEVEL_LOW   = false;              // 
	GPIO8_LEVEL_HIGH  = false;              // 
	GPIO8_EDGE_LOW    = false;              // 
	GPIO8_EDGE_HIGH   = false;              // 
	GPIO9_LEVEL_LOW   = false;              // 
	GPIO9_LEVEL_HIGH  = false;              // 
	GPIO9_EDGE_LOW    = false;              // 
	GPIO9_EDGE_HIGH   = false;              // 
	GPIO10_LEVEL_LOW  = false;              // 
	GPIO10_LEVEL_HIGH = false;              // 
	GPIO10_EDGE_LOW   = false;              // 
	GPIO10_EDGE_HIGH  = false;              // 
	GPIO11_LEVEL_LOW  = false;              // 
	GPIO11_LEVEL_HIGH = false;              // 
	GPIO11_EDGE_LOW   = false;              // 
	GPIO11_EDGE_HIGH  = false;              // 
	GPIO12_LEVEL_LOW  = false;              // 
	GPIO12_LEVEL_HIGH = false;              // 
	GPIO12_EDGE_LOW   = false;              // 
	GPIO12_EDGE_HIGH  = false;              // 
	GPIO13_LEVEL_LOW  = false;              // 
	GPIO13_LEVEL_HIGH = false;              // 
	GPIO13_EDGE_LOW   = false;              // 
	GPIO13_EDGE_HIGH  = false;              // 
	GPIO14_LEVEL_LOW  = false;              // 
	GPIO14_LEVEL_HIGH = false;              // 
	GPIO14_EDGE_LOW   = false;              // 
	GPIO14_EDGE_HIGH  = false;              // 
	GPIO15_LEVEL_LOW  = false;              // 
	GPIO15_LEVEL_HIGH = false;              // 
	GPIO15_EDGE_LOW   = false;              // 
	GPIO15_EDGE_HIGH  = false;              // 
 }

 // Interrupt status after masking & forcing for proc0
 register PROC0_INTS1_t PROC0_INTS1 at 0x40014124;

 type PROC0_INTS2_t {
	GPIO16_LEVEL_LOW  = false;              // 
	GPIO16_LEVEL_HIGH = false;              // 
	GPIO16_EDGE_LOW   = false;              // 
	GPIO16_EDGE_HIGH  = false;              // 
	GPIO17_LEVEL_LOW  = false;              // 
	GPIO17_LEVEL_HIGH = false;              // 
	GPIO17_EDGE_LOW   = false;              // 
	GPIO17_EDGE_HIGH  = false;              // 
	GPIO18_LEVEL_LOW  = false;              // 
	GPIO18_LEVEL_HIGH = false;              // 
	GPIO18_EDGE_LOW   = false;              // 
	GPIO18_EDGE_HIGH  = false;              // 
	GPIO19_LEVEL_LOW  = false;              // 
	GPIO19_LEVEL_HIGH = false;              // 
	GPIO19_EDGE_LOW   = false;              // 
	GPIO19_EDGE_HIGH  = false;              // 
	GPIO20_LEVEL_LOW  = false;              // 
	GPIO20_LEVEL_HIGH = false;              // 
	GPIO20_EDGE_LOW   = false;              // 
	GPIO20_EDGE_HIGH  = false;              // 
	GPIO21_LEVEL_LOW  = false;              // 
	GPIO21_LEVEL_HIGH = false;              // 
	GPIO21_EDGE_LOW   = false;              // 
	GPIO21_EDGE_HIGH  = false;              // 
	GPIO22_LEVEL_LOW  = false;              // 
	GPIO22_LEVEL_HIGH = false;              // 
	GPIO22_EDGE_LOW   = false;              // 
	GPIO22_EDGE_HIGH  = false;              // 
	GPIO23_LEVEL_LOW  = false;              // 
	GPIO23_LEVEL_HIGH = false;              // 
	GPIO23_EDGE_LOW   = false;              // 
	GPIO23_EDGE_HIGH  = false;              // 
 }

 // Interrupt status after masking & forcing for proc0
 register PROC0_INTS2_t PROC0_INTS2 at 0x40014128;

 type PROC0_INTS3_t {
	GPIO24_LEVEL_LOW  = false;              // 
	GPIO24_LEVEL_HIGH = false;              // 
	GPIO24_EDGE_LOW   = false;              // 
	GPIO24_EDGE_HIGH  = false;              // 
	GPIO25_LEVEL_LOW  = false;              // 
	GPIO25_LEVEL_HIGH = false;              // 
	GPIO25_EDGE_LOW   = false;              // 
	GPIO25_EDGE_HIGH  = false;              // 
	GPIO26_LEVEL_LOW  = false;              // 
	GPIO26_LEVEL_HIGH = false;              // 
	GPIO26_EDGE_LOW   = false;              // 
	GPIO26_EDGE_HIGH  = false;              // 
	GPIO27_LEVEL_LOW  = false;              // 
	GPIO27_LEVEL_HIGH = false;              // 
	GPIO27_EDGE_LOW   = false;              // 
	GPIO27_EDGE_HIGH  = false;              // 
	GPIO28_LEVEL_LOW  = false;              // 
	GPIO28_LEVEL_HIGH = false;              // 
	GPIO28_EDGE_LOW   = false;              // 
	GPIO28_EDGE_HIGH  = false;              // 
	GPIO29_LEVEL_LOW  = false;              // 
	GPIO29_LEVEL_HIGH = false;              // 
	GPIO29_EDGE_LOW   = false;              // 
	GPIO29_EDGE_HIGH  = false;              // 
 }

 // Interrupt status after masking & forcing for proc0
 register PROC0_INTS3_t PROC0_INTS3 at 0x4001412c;

 type PROC1_INTE0_t {
	GPIO0_LEVEL_LOW  = false;              // 
	GPIO0_LEVEL_HIGH = false;              // 
	GPIO0_EDGE_LOW   = false;              // 
	GPIO0_EDGE_HIGH  = false;              // 
	GPIO1_LEVEL_LOW  = false;              // 
	GPIO1_LEVEL_HIGH = false;              // 
	GPIO1_EDGE_LOW   = false;              // 
	GPIO1_EDGE_HIGH  = false;              // 
	GPIO2_LEVEL_LOW  = false;              // 
	GPIO2_LEVEL_HIGH = false;              // 
	GPIO2_EDGE_LOW   = false;              // 
	GPIO2_EDGE_HIGH  = false;              // 
	GPIO3_LEVEL_LOW  = false;              // 
	GPIO3_LEVEL_HIGH = false;              // 
	GPIO3_EDGE_LOW   = false;              // 
	GPIO3_EDGE_HIGH  = false;              // 
	GPIO4_LEVEL_LOW  = false;              // 
	GPIO4_LEVEL_HIGH = false;              // 
	GPIO4_EDGE_LOW   = false;              // 
	GPIO4_EDGE_HIGH  = false;              // 
	GPIO5_LEVEL_LOW  = false;              // 
	GPIO5_LEVEL_HIGH = false;              // 
	GPIO5_EDGE_LOW   = false;              // 
	GPIO5_EDGE_HIGH  = false;              // 
	GPIO6_LEVEL_LOW  = false;              // 
	GPIO6_LEVEL_HIGH = false;              // 
	GPIO6_EDGE_LOW   = false;              // 
	GPIO6_EDGE_HIGH  = false;              // 
	GPIO7_LEVEL_LOW  = false;              // 
	GPIO7_LEVEL_HIGH = false;              // 
	GPIO7_EDGE_LOW   = false;              // 
	GPIO7_EDGE_HIGH  = false;              // 
 }

 // Interrupt Enable for proc1
 register PROC1_INTE0_t PROC1_INTE0 at 0x40014130;

 type PROC1_INTE1_t {
	GPIO8_LEVEL_LOW   = false;              // 
	GPIO8_LEVEL_HIGH  = false;              // 
	GPIO8_EDGE_LOW    = false;              // 
	GPIO8_EDGE_HIGH   = false;              // 
	GPIO9_LEVEL_LOW   = false;              // 
	GPIO9_LEVEL_HIGH  = false;              // 
	GPIO9_EDGE_LOW    = false;              // 
	GPIO9_EDGE_HIGH   = false;              // 
	GPIO10_LEVEL_LOW  = false;              // 
	GPIO10_LEVEL_HIGH = false;              // 
	GPIO10_EDGE_LOW   = false;              // 
	GPIO10_EDGE_HIGH  = false;              // 
	GPIO11_LEVEL_LOW  = false;              // 
	GPIO11_LEVEL_HIGH = false;              // 
	GPIO11_EDGE_LOW   = false;              // 
	GPIO11_EDGE_HIGH  = false;              // 
	GPIO12_LEVEL_LOW  = false;              // 
	GPIO12_LEVEL_HIGH = false;              // 
	GPIO12_EDGE_LOW   = false;              // 
	GPIO12_EDGE_HIGH  = false;              // 
	GPIO13_LEVEL_LOW  = false;              // 
	GPIO13_LEVEL_HIGH = false;              // 
	GPIO13_EDGE_LOW   = false;              // 
	GPIO13_EDGE_HIGH  = false;              // 
	GPIO14_LEVEL_LOW  = false;              // 
	GPIO14_LEVEL_HIGH = false;              // 
	GPIO14_EDGE_LOW   = false;              // 
	GPIO14_EDGE_HIGH  = false;              // 
	GPIO15_LEVEL_LOW  = false;              // 
	GPIO15_LEVEL_HIGH = false;              // 
	GPIO15_EDGE_LOW   = false;              // 
	GPIO15_EDGE_HIGH  = false;              // 
 }

 // Interrupt Enable for proc1
 register PROC1_INTE1_t PROC1_INTE1 at 0x40014134;

 type PROC1_INTE2_t {
	GPIO16_LEVEL_LOW  = false;              // 
	GPIO16_LEVEL_HIGH = false;              // 
	GPIO16_EDGE_LOW   = false;              // 
	GPIO16_EDGE_HIGH  = false;              // 
	GPIO17_LEVEL_LOW  = false;              // 
	GPIO17_LEVEL_HIGH = false;              // 
	GPIO17_EDGE_LOW   = false;              // 
	GPIO17_EDGE_HIGH  = false;              // 
	GPIO18_LEVEL_LOW  = false;              // 
	GPIO18_LEVEL_HIGH = false;              // 
	GPIO18_EDGE_LOW   = false;              // 
	GPIO18_EDGE_HIGH  = false;              // 
	GPIO19_LEVEL_LOW  = false;              // 
	GPIO19_LEVEL_HIGH = false;              // 
	GPIO19_EDGE_LOW   = false;              // 
	GPIO19_EDGE_HIGH  = false;              // 
	GPIO20_LEVEL_LOW  = false;              // 
	GPIO20_LEVEL_HIGH = false;              // 
	GPIO20_EDGE_LOW   = false;              // 
	GPIO20_EDGE_HIGH  = false;              // 
	GPIO21_LEVEL_LOW  = false;              // 
	GPIO21_LEVEL_HIGH = false;              // 
	GPIO21_EDGE_LOW   = false;              // 
	GPIO21_EDGE_HIGH  = false;              // 
	GPIO22_LEVEL_LOW  = false;              // 
	GPIO22_LEVEL_HIGH = false;              // 
	GPIO22_EDGE_LOW   = false;              // 
	GPIO22_EDGE_HIGH  = false;              // 
	GPIO23_LEVEL_LOW  = false;              // 
	GPIO23_LEVEL_HIGH = false;              // 
	GPIO23_EDGE_LOW   = false;              // 
	GPIO23_EDGE_HIGH  = false;              // 
 }

 // Interrupt Enable for proc1
 register PROC1_INTE2_t PROC1_INTE2 at 0x40014138;

 type PROC1_INTE3_t {
	GPIO24_LEVEL_LOW  = false;              // 
	GPIO24_LEVEL_HIGH = false;              // 
	GPIO24_EDGE_LOW   = false;              // 
	GPIO24_EDGE_HIGH  = false;              // 
	GPIO25_LEVEL_LOW  = false;              // 
	GPIO25_LEVEL_HIGH = false;              // 
	GPIO25_EDGE_LOW   = false;              // 
	GPIO25_EDGE_HIGH  = false;              // 
	GPIO26_LEVEL_LOW  = false;              // 
	GPIO26_LEVEL_HIGH = false;              // 
	GPIO26_EDGE_LOW   = false;              // 
	GPIO26_EDGE_HIGH  = false;              // 
	GPIO27_LEVEL_LOW  = false;              // 
	GPIO27_LEVEL_HIGH = false;              // 
	GPIO27_EDGE_LOW   = false;              // 
	GPIO27_EDGE_HIGH  = false;              // 
	GPIO28_LEVEL_LOW  = false;              // 
	GPIO28_LEVEL_HIGH = false;              // 
	GPIO28_EDGE_LOW   = false;              // 
	GPIO28_EDGE_HIGH  = false;              // 
	GPIO29_LEVEL_LOW  = false;              // 
	GPIO29_LEVEL_HIGH = false;              // 
	GPIO29_EDGE_LOW   = false;              // 
	GPIO29_EDGE_HIGH  = false;              // 
 }

 // Interrupt Enable for proc1
 register PROC1_INTE3_t PROC1_INTE3 at 0x4001413c;

 type PROC1_INTF0_t {
	GPIO0_LEVEL_LOW  = false;              // 
	GPIO0_LEVEL_HIGH = false;              // 
	GPIO0_EDGE_LOW   = false;              // 
	GPIO0_EDGE_HIGH  = false;              // 
	GPIO1_LEVEL_LOW  = false;              // 
	GPIO1_LEVEL_HIGH = false;              // 
	GPIO1_EDGE_LOW   = false;              // 
	GPIO1_EDGE_HIGH  = false;              // 
	GPIO2_LEVEL_LOW  = false;              // 
	GPIO2_LEVEL_HIGH = false;              // 
	GPIO2_EDGE_LOW   = false;              // 
	GPIO2_EDGE_HIGH  = false;              // 
	GPIO3_LEVEL_LOW  = false;              // 
	GPIO3_LEVEL_HIGH = false;              // 
	GPIO3_EDGE_LOW   = false;              // 
	GPIO3_EDGE_HIGH  = false;              // 
	GPIO4_LEVEL_LOW  = false;              // 
	GPIO4_LEVEL_HIGH = false;              // 
	GPIO4_EDGE_LOW   = false;              // 
	GPIO4_EDGE_HIGH  = false;              // 
	GPIO5_LEVEL_LOW  = false;              // 
	GPIO5_LEVEL_HIGH = false;              // 
	GPIO5_EDGE_LOW   = false;              // 
	GPIO5_EDGE_HIGH  = false;              // 
	GPIO6_LEVEL_LOW  = false;              // 
	GPIO6_LEVEL_HIGH = false;              // 
	GPIO6_EDGE_LOW   = false;              // 
	GPIO6_EDGE_HIGH  = false;              // 
	GPIO7_LEVEL_LOW  = false;              // 
	GPIO7_LEVEL_HIGH = false;              // 
	GPIO7_EDGE_LOW   = false;              // 
	GPIO7_EDGE_HIGH  = false;              // 
 }

 // Interrupt Force for proc1
 register PROC1_INTF0_t PROC1_INTF0 at 0x40014140;

 type PROC1_INTF1_t {
	GPIO8_LEVEL_LOW   = false;              // 
	GPIO8_LEVEL_HIGH  = false;              // 
	GPIO8_EDGE_LOW    = false;              // 
	GPIO8_EDGE_HIGH   = false;              // 
	GPIO9_LEVEL_LOW   = false;              // 
	GPIO9_LEVEL_HIGH  = false;              // 
	GPIO9_EDGE_LOW    = false;              // 
	GPIO9_EDGE_HIGH   = false;              // 
	GPIO10_LEVEL_LOW  = false;              // 
	GPIO10_LEVEL_HIGH = false;              // 
	GPIO10_EDGE_LOW   = false;              // 
	GPIO10_EDGE_HIGH  = false;              // 
	GPIO11_LEVEL_LOW  = false;              // 
	GPIO11_LEVEL_HIGH = false;              // 
	GPIO11_EDGE_LOW   = false;              // 
	GPIO11_EDGE_HIGH  = false;              // 
	GPIO12_LEVEL_LOW  = false;              // 
	GPIO12_LEVEL_HIGH = false;              // 
	GPIO12_EDGE_LOW   = false;              // 
	GPIO12_EDGE_HIGH  = false;              // 
	GPIO13_LEVEL_LOW  = false;              // 
	GPIO13_LEVEL_HIGH = false;              // 
	GPIO13_EDGE_LOW   = false;              // 
	GPIO13_EDGE_HIGH  = false;              // 
	GPIO14_LEVEL_LOW  = false;              // 
	GPIO14_LEVEL_HIGH = false;              // 
	GPIO14_EDGE_LOW   = false;              // 
	GPIO14_EDGE_HIGH  = false;              // 
	GPIO15_LEVEL_LOW  = false;              // 
	GPIO15_LEVEL_HIGH = false;              // 
	GPIO15_EDGE_LOW   = false;              // 
	GPIO15_EDGE_HIGH  = false;              // 
 }

 // Interrupt Force for proc1
 register PROC1_INTF1_t PROC1_INTF1 at 0x40014144;

 type PROC1_INTF2_t {
	GPIO16_LEVEL_LOW  = false;              // 
	GPIO16_LEVEL_HIGH = false;              // 
	GPIO16_EDGE_LOW   = false;              // 
	GPIO16_EDGE_HIGH  = false;              // 
	GPIO17_LEVEL_LOW  = false;              // 
	GPIO17_LEVEL_HIGH = false;              // 
	GPIO17_EDGE_LOW   = false;              // 
	GPIO17_EDGE_HIGH  = false;              // 
	GPIO18_LEVEL_LOW  = false;              // 
	GPIO18_LEVEL_HIGH = false;              // 
	GPIO18_EDGE_LOW   = false;              // 
	GPIO18_EDGE_HIGH  = false;              // 
	GPIO19_LEVEL_LOW  = false;              // 
	GPIO19_LEVEL_HIGH = false;              // 
	GPIO19_EDGE_LOW   = false;              // 
	GPIO19_EDGE_HIGH  = false;              // 
	GPIO20_LEVEL_LOW  = false;              // 
	GPIO20_LEVEL_HIGH = false;              // 
	GPIO20_EDGE_LOW   = false;              // 
	GPIO20_EDGE_HIGH  = false;              // 
	GPIO21_LEVEL_LOW  = false;              // 
	GPIO21_LEVEL_HIGH = false;              // 
	GPIO21_EDGE_LOW   = false;              // 
	GPIO21_EDGE_HIGH  = false;              // 
	GPIO22_LEVEL_LOW  = false;              // 
	GPIO22_LEVEL_HIGH = false;              // 
	GPIO22_EDGE_LOW   = false;              // 
	GPIO22_EDGE_HIGH  = false;              // 
	GPIO23_LEVEL_LOW  = false;              // 
	GPIO23_LEVEL_HIGH = false;              // 
	GPIO23_EDGE_LOW   = false;              // 
	GPIO23_EDGE_HIGH  = false;              // 
 }

 // Interrupt Force for proc1
 register PROC1_INTF2_t PROC1_INTF2 at 0x40014148;

 type PROC1_INTF3_t {
	GPIO24_LEVEL_LOW  = false;              // 
	GPIO24_LEVEL_HIGH = false;              // 
	GPIO24_EDGE_LOW   = false;              // 
	GPIO24_EDGE_HIGH  = false;              // 
	GPIO25_LEVEL_LOW  = false;              // 
	GPIO25_LEVEL_HIGH = false;              // 
	GPIO25_EDGE_LOW   = false;              // 
	GPIO25_EDGE_HIGH  = false;              // 
	GPIO26_LEVEL_LOW  = false;              // 
	GPIO26_LEVEL_HIGH = false;              // 
	GPIO26_EDGE_LOW   = false;              // 
	GPIO26_EDGE_HIGH  = false;              // 
	GPIO27_LEVEL_LOW  = false;              // 
	GPIO27_LEVEL_HIGH = false;              // 
	GPIO27_EDGE_LOW   = false;              // 
	GPIO27_EDGE_HIGH  = false;              // 
	GPIO28_LEVEL_LOW  = false;              // 
	GPIO28_LEVEL_HIGH = false;              // 
	GPIO28_EDGE_LOW   = false;              // 
	GPIO28_EDGE_HIGH  = false;              // 
	GPIO29_LEVEL_LOW  = false;              // 
	GPIO29_LEVEL_HIGH = false;              // 
	GPIO29_EDGE_LOW   = false;              // 
	GPIO29_EDGE_HIGH  = false;              // 
 }

 // Interrupt Force for proc1
 register PROC1_INTF3_t PROC1_INTF3 at 0x4001414c;

 type PROC1_INTS0_t {
	GPIO0_LEVEL_LOW  = false;              // 
	GPIO0_LEVEL_HIGH = false;              // 
	GPIO0_EDGE_LOW   = false;              // 
	GPIO0_EDGE_HIGH  = false;              // 
	GPIO1_LEVEL_LOW  = false;              // 
	GPIO1_LEVEL_HIGH = false;              // 
	GPIO1_EDGE_LOW   = false;              // 
	GPIO1_EDGE_HIGH  = false;              // 
	GPIO2_LEVEL_LOW  = false;              // 
	GPIO2_LEVEL_HIGH = false;              // 
	GPIO2_EDGE_LOW   = false;              // 
	GPIO2_EDGE_HIGH  = false;              // 
	GPIO3_LEVEL_LOW  = false;              // 
	GPIO3_LEVEL_HIGH = false;              // 
	GPIO3_EDGE_LOW   = false;              // 
	GPIO3_EDGE_HIGH  = false;              // 
	GPIO4_LEVEL_LOW  = false;              // 
	GPIO4_LEVEL_HIGH = false;              // 
	GPIO4_EDGE_LOW   = false;              // 
	GPIO4_EDGE_HIGH  = false;              // 
	GPIO5_LEVEL_LOW  = false;              // 
	GPIO5_LEVEL_HIGH = false;              // 
	GPIO5_EDGE_LOW   = false;              // 
	GPIO5_EDGE_HIGH  = false;              // 
	GPIO6_LEVEL_LOW  = false;              // 
	GPIO6_LEVEL_HIGH = false;              // 
	GPIO6_EDGE_LOW   = false;              // 
	GPIO6_EDGE_HIGH  = false;              // 
	GPIO7_LEVEL_LOW  = false;              // 
	GPIO7_LEVEL_HIGH = false;              // 
	GPIO7_EDGE_LOW   = false;              // 
	GPIO7_EDGE_HIGH  = false;              // 
 }

 // Interrupt status after masking & forcing for proc1
 register PROC1_INTS0_t PROC1_INTS0 at 0x40014150;

 type PROC1_INTS1_t {
	GPIO8_LEVEL_LOW   = false;              // 
	GPIO8_LEVEL_HIGH  = false;              // 
	GPIO8_EDGE_LOW    = false;              // 
	GPIO8_EDGE_HIGH   = false;              // 
	GPIO9_LEVEL_LOW   = false;              // 
	GPIO9_LEVEL_HIGH  = false;              // 
	GPIO9_EDGE_LOW    = false;              // 
	GPIO9_EDGE_HIGH   = false;              // 
	GPIO10_LEVEL_LOW  = false;              // 
	GPIO10_LEVEL_HIGH = false;              // 
	GPIO10_EDGE_LOW   = false;              // 
	GPIO10_EDGE_HIGH  = false;              // 
	GPIO11_LEVEL_LOW  = false;              // 
	GPIO11_LEVEL_HIGH = false;              // 
	GPIO11_EDGE_LOW   = false;              // 
	GPIO11_EDGE_HIGH  = false;              // 
	GPIO12_LEVEL_LOW  = false;              // 
	GPIO12_LEVEL_HIGH = false;              // 
	GPIO12_EDGE_LOW   = false;              // 
	GPIO12_EDGE_HIGH  = false;              // 
	GPIO13_LEVEL_LOW  = false;              // 
	GPIO13_LEVEL_HIGH = false;              // 
	GPIO13_EDGE_LOW   = false;              // 
	GPIO13_EDGE_HIGH  = false;              // 
	GPIO14_LEVEL_LOW  = false;              // 
	GPIO14_LEVEL_HIGH = false;              // 
	GPIO14_EDGE_LOW   = false;              // 
	GPIO14_EDGE_HIGH  = false;              // 
	GPIO15_LEVEL_LOW  = false;              // 
	GPIO15_LEVEL_HIGH = false;              // 
	GPIO15_EDGE_LOW   = false;              // 
	GPIO15_EDGE_HIGH  = false;              // 
 }

 // Interrupt status after masking & forcing for proc1
 register PROC1_INTS1_t PROC1_INTS1 at 0x40014154;

 type PROC1_INTS2_t {
	GPIO16_LEVEL_LOW  = false;              // 
	GPIO16_LEVEL_HIGH = false;              // 
	GPIO16_EDGE_LOW   = false;              // 
	GPIO16_EDGE_HIGH  = false;              // 
	GPIO17_LEVEL_LOW  = false;              // 
	GPIO17_LEVEL_HIGH = false;              // 
	GPIO17_EDGE_LOW   = false;              // 
	GPIO17_EDGE_HIGH  = false;              // 
	GPIO18_LEVEL_LOW  = false;              // 
	GPIO18_LEVEL_HIGH = false;              // 
	GPIO18_EDGE_LOW   = false;              // 
	GPIO18_EDGE_HIGH  = false;              // 
	GPIO19_LEVEL_LOW  = false;              // 
	GPIO19_LEVEL_HIGH = false;              // 
	GPIO19_EDGE_LOW   = false;              // 
	GPIO19_EDGE_HIGH  = false;              // 
	GPIO20_LEVEL_LOW  = false;              // 
	GPIO20_LEVEL_HIGH = false;              // 
	GPIO20_EDGE_LOW   = false;              // 
	GPIO20_EDGE_HIGH  = false;              // 
	GPIO21_LEVEL_LOW  = false;              // 
	GPIO21_LEVEL_HIGH = false;              // 
	GPIO21_EDGE_LOW   = false;              // 
	GPIO21_EDGE_HIGH  = false;              // 
	GPIO22_LEVEL_LOW  = false;              // 
	GPIO22_LEVEL_HIGH = false;              // 
	GPIO22_EDGE_LOW   = false;              // 
	GPIO22_EDGE_HIGH  = false;              // 
	GPIO23_LEVEL_LOW  = false;              // 
	GPIO23_LEVEL_HIGH = false;              // 
	GPIO23_EDGE_LOW   = false;              // 
	GPIO23_EDGE_HIGH  = false;              // 
 }

 // Interrupt status after masking & forcing for proc1
 register PROC1_INTS2_t PROC1_INTS2 at 0x40014158;

 type PROC1_INTS3_t {
	GPIO24_LEVEL_LOW  = false;              // 
	GPIO24_LEVEL_HIGH = false;              // 
	GPIO24_EDGE_LOW   = false;              // 
	GPIO24_EDGE_HIGH  = false;              // 
	GPIO25_LEVEL_LOW  = false;              // 
	GPIO25_LEVEL_HIGH = false;              // 
	GPIO25_EDGE_LOW   = false;              // 
	GPIO25_EDGE_HIGH  = false;              // 
	GPIO26_LEVEL_LOW  = false;              // 
	GPIO26_LEVEL_HIGH = false;              // 
	GPIO26_EDGE_LOW   = false;              // 
	GPIO26_EDGE_HIGH  = false;              // 
	GPIO27_LEVEL_LOW  = false;              // 
	GPIO27_LEVEL_HIGH = false;              // 
	GPIO27_EDGE_LOW   = false;              // 
	GPIO27_EDGE_HIGH  = false;              // 
	GPIO28_LEVEL_LOW  = false;              // 
	GPIO28_LEVEL_HIGH = false;              // 
	GPIO28_EDGE_LOW   = false;              // 
	GPIO28_EDGE_HIGH  = false;              // 
	GPIO29_LEVEL_LOW  = false;              // 
	GPIO29_LEVEL_HIGH = false;              // 
	GPIO29_EDGE_LOW   = false;              // 
	GPIO29_EDGE_HIGH  = false;              // 
 }

 // Interrupt status after masking & forcing for proc1
 register PROC1_INTS3_t PROC1_INTS3 at 0x4001415c;

 type DORMANT_WAKE_INTE0_t {
	GPIO0_LEVEL_LOW  = false;              // 
	GPIO0_LEVEL_HIGH = false;              // 
	GPIO0_EDGE_LOW   = false;              // 
	GPIO0_EDGE_HIGH  = false;              // 
	GPIO1_LEVEL_LOW  = false;              // 
	GPIO1_LEVEL_HIGH = false;              // 
	GPIO1_EDGE_LOW   = false;              // 
	GPIO1_EDGE_HIGH  = false;              // 
	GPIO2_LEVEL_LOW  = false;              // 
	GPIO2_LEVEL_HIGH = false;              // 
	GPIO2_EDGE_LOW   = false;              // 
	GPIO2_EDGE_HIGH  = false;              // 
	GPIO3_LEVEL_LOW  = false;              // 
	GPIO3_LEVEL_HIGH = false;              // 
	GPIO3_EDGE_LOW   = false;              // 
	GPIO3_EDGE_HIGH  = false;              // 
	GPIO4_LEVEL_LOW  = false;              // 
	GPIO4_LEVEL_HIGH = false;              // 
	GPIO4_EDGE_LOW   = false;              // 
	GPIO4_EDGE_HIGH  = false;              // 
	GPIO5_LEVEL_LOW  = false;              // 
	GPIO5_LEVEL_HIGH = false;              // 
	GPIO5_EDGE_LOW   = false;              // 
	GPIO5_EDGE_HIGH  = false;              // 
	GPIO6_LEVEL_LOW  = false;              // 
	GPIO6_LEVEL_HIGH = false;              // 
	GPIO6_EDGE_LOW   = false;              // 
	GPIO6_EDGE_HIGH  = false;              // 
	GPIO7_LEVEL_LOW  = false;              // 
	GPIO7_LEVEL_HIGH = false;              // 
	GPIO7_EDGE_LOW   = false;              // 
	GPIO7_EDGE_HIGH  = false;              // 
 }

 // Interrupt Enable for dormant_wake
 register DORMANT_WAKE_INTE0_t DORMANT_WAKE_INTE0 at 0x40014160;

 type DORMANT_WAKE_INTE1_t {
	GPIO8_LEVEL_LOW   = false;              // 
	GPIO8_LEVEL_HIGH  = false;              // 
	GPIO8_EDGE_LOW    = false;              // 
	GPIO8_EDGE_HIGH   = false;              // 
	GPIO9_LEVEL_LOW   = false;              // 
	GPIO9_LEVEL_HIGH  = false;              // 
	GPIO9_EDGE_LOW    = false;              // 
	GPIO9_EDGE_HIGH   = false;              // 
	GPIO10_LEVEL_LOW  = false;              // 
	GPIO10_LEVEL_HIGH = false;              // 
	GPIO10_EDGE_LOW   = false;              // 
	GPIO10_EDGE_HIGH  = false;              // 
	GPIO11_LEVEL_LOW  = false;              // 
	GPIO11_LEVEL_HIGH = false;              // 
	GPIO11_EDGE_LOW   = false;              // 
	GPIO11_EDGE_HIGH  = false;              // 
	GPIO12_LEVEL_LOW  = false;              // 
	GPIO12_LEVEL_HIGH = false;              // 
	GPIO12_EDGE_LOW   = false;              // 
	GPIO12_EDGE_HIGH  = false;              // 
	GPIO13_LEVEL_LOW  = false;              // 
	GPIO13_LEVEL_HIGH = false;              // 
	GPIO13_EDGE_LOW   = false;              // 
	GPIO13_EDGE_HIGH  = false;              // 
	GPIO14_LEVEL_LOW  = false;              // 
	GPIO14_LEVEL_HIGH = false;              // 
	GPIO14_EDGE_LOW   = false;              // 
	GPIO14_EDGE_HIGH  = false;              // 
	GPIO15_LEVEL_LOW  = false;              // 
	GPIO15_LEVEL_HIGH = false;              // 
	GPIO15_EDGE_LOW   = false;              // 
	GPIO15_EDGE_HIGH  = false;              // 
 }

 // Interrupt Enable for dormant_wake
 register DORMANT_WAKE_INTE1_t DORMANT_WAKE_INTE1 at 0x40014164;

 type DORMANT_WAKE_INTE2_t {
	GPIO16_LEVEL_LOW  = false;              // 
	GPIO16_LEVEL_HIGH = false;              // 
	GPIO16_EDGE_LOW   = false;              // 
	GPIO16_EDGE_HIGH  = false;              // 
	GPIO17_LEVEL_LOW  = false;              // 
	GPIO17_LEVEL_HIGH = false;              // 
	GPIO17_EDGE_LOW   = false;              // 
	GPIO17_EDGE_HIGH  = false;              // 
	GPIO18_LEVEL_LOW  = false;              // 
	GPIO18_LEVEL_HIGH = false;              // 
	GPIO18_EDGE_LOW   = false;              // 
	GPIO18_EDGE_HIGH  = false;              // 
	GPIO19_LEVEL_LOW  = false;              // 
	GPIO19_LEVEL_HIGH = false;              // 
	GPIO19_EDGE_LOW   = false;              // 
	GPIO19_EDGE_HIGH  = false;              // 
	GPIO20_LEVEL_LOW  = false;              // 
	GPIO20_LEVEL_HIGH = false;              // 
	GPIO20_EDGE_LOW   = false;              // 
	GPIO20_EDGE_HIGH  = false;              // 
	GPIO21_LEVEL_LOW  = false;              // 
	GPIO21_LEVEL_HIGH = false;              // 
	GPIO21_EDGE_LOW   = false;              // 
	GPIO21_EDGE_HIGH  = false;              // 
	GPIO22_LEVEL_LOW  = false;              // 
	GPIO22_LEVEL_HIGH = false;              // 
	GPIO22_EDGE_LOW   = false;              // 
	GPIO22_EDGE_HIGH  = false;              // 
	GPIO23_LEVEL_LOW  = false;              // 
	GPIO23_LEVEL_HIGH = false;              // 
	GPIO23_EDGE_LOW   = false;              // 
	GPIO23_EDGE_HIGH  = false;              // 
 }

 // Interrupt Enable for dormant_wake
 register DORMANT_WAKE_INTE2_t DORMANT_WAKE_INTE2 at 0x40014168;

 type DORMANT_WAKE_INTE3_t {
	GPIO24_LEVEL_LOW  = false;              // 
	GPIO24_LEVEL_HIGH = false;              // 
	GPIO24_EDGE_LOW   = false;              // 
	GPIO24_EDGE_HIGH  = false;              // 
	GPIO25_LEVEL_LOW  = false;              // 
	GPIO25_LEVEL_HIGH = false;              // 
	GPIO25_EDGE_LOW   = false;              // 
	GPIO25_EDGE_HIGH  = false;              // 
	GPIO26_LEVEL_LOW  = false;              // 
	GPIO26_LEVEL_HIGH = false;              // 
	GPIO26_EDGE_LOW   = false;              // 
	GPIO26_EDGE_HIGH  = false;              // 
	GPIO27_LEVEL_LOW  = false;              // 
	GPIO27_LEVEL_HIGH = false;              // 
	GPIO27_EDGE_LOW   = false;              // 
	GPIO27_EDGE_HIGH  = false;              // 
	GPIO28_LEVEL_LOW  = false;              // 
	GPIO28_LEVEL_HIGH = false;              // 
	GPIO28_EDGE_LOW   = false;              // 
	GPIO28_EDGE_HIGH  = false;              // 
	GPIO29_LEVEL_LOW  = false;              // 
	GPIO29_LEVEL_HIGH = false;              // 
	GPIO29_EDGE_LOW   = false;              // 
	GPIO29_EDGE_HIGH  = false;              // 
 }

 // Interrupt Enable for dormant_wake
 register DORMANT_WAKE_INTE3_t DORMANT_WAKE_INTE3 at 0x4001416c;

 type DORMANT_WAKE_INTF0_t {
	GPIO0_LEVEL_LOW  = false;              // 
	GPIO0_LEVEL_HIGH = false;              // 
	GPIO0_EDGE_LOW   = false;              // 
	GPIO0_EDGE_HIGH  = false;              // 
	GPIO1_LEVEL_LOW  = false;              // 
	GPIO1_LEVEL_HIGH = false;              // 
	GPIO1_EDGE_LOW   = false;              // 
	GPIO1_EDGE_HIGH  = false;              // 
	GPIO2_LEVEL_LOW  = false;              // 
	GPIO2_LEVEL_HIGH = false;              // 
	GPIO2_EDGE_LOW   = false;              // 
	GPIO2_EDGE_HIGH  = false;              // 
	GPIO3_LEVEL_LOW  = false;              // 
	GPIO3_LEVEL_HIGH = false;              // 
	GPIO3_EDGE_LOW   = false;              // 
	GPIO3_EDGE_HIGH  = false;              // 
	GPIO4_LEVEL_LOW  = false;              // 
	GPIO4_LEVEL_HIGH = false;              // 
	GPIO4_EDGE_LOW   = false;              // 
	GPIO4_EDGE_HIGH  = false;              // 
	GPIO5_LEVEL_LOW  = false;              // 
	GPIO5_LEVEL_HIGH = false;              // 
	GPIO5_EDGE_LOW   = false;              // 
	GPIO5_EDGE_HIGH  = false;              // 
	GPIO6_LEVEL_LOW  = false;              // 
	GPIO6_LEVEL_HIGH = false;              // 
	GPIO6_EDGE_LOW   = false;              // 
	GPIO6_EDGE_HIGH  = false;              // 
	GPIO7_LEVEL_LOW  = false;              // 
	GPIO7_LEVEL_HIGH = false;              // 
	GPIO7_EDGE_LOW   = false;              // 
	GPIO7_EDGE_HIGH  = false;              // 
 }

 // Interrupt Force for dormant_wake
 register DORMANT_WAKE_INTF0_t DORMANT_WAKE_INTF0 at 0x40014170;

 type DORMANT_WAKE_INTF1_t {
	GPIO8_LEVEL_LOW   = false;              // 
	GPIO8_LEVEL_HIGH  = false;              // 
	GPIO8_EDGE_LOW    = false;              // 
	GPIO8_EDGE_HIGH   = false;              // 
	GPIO9_LEVEL_LOW   = false;              // 
	GPIO9_LEVEL_HIGH  = false;              // 
	GPIO9_EDGE_LOW    = false;              // 
	GPIO9_EDGE_HIGH   = false;              // 
	GPIO10_LEVEL_LOW  = false;              // 
	GPIO10_LEVEL_HIGH = false;              // 
	GPIO10_EDGE_LOW   = false;              // 
	GPIO10_EDGE_HIGH  = false;              // 
	GPIO11_LEVEL_LOW  = false;              // 
	GPIO11_LEVEL_HIGH = false;              // 
	GPIO11_EDGE_LOW   = false;              // 
	GPIO11_EDGE_HIGH  = false;              // 
	GPIO12_LEVEL_LOW  = false;              // 
	GPIO12_LEVEL_HIGH = false;              // 
	GPIO12_EDGE_LOW   = false;              // 
	GPIO12_EDGE_HIGH  = false;              // 
	GPIO13_LEVEL_LOW  = false;              // 
	GPIO13_LEVEL_HIGH = false;              // 
	GPIO13_EDGE_LOW   = false;              // 
	GPIO13_EDGE_HIGH  = false;              // 
	GPIO14_LEVEL_LOW  = false;              // 
	GPIO14_LEVEL_HIGH = false;              // 
	GPIO14_EDGE_LOW   = false;              // 
	GPIO14_EDGE_HIGH  = false;              // 
	GPIO15_LEVEL_LOW  = false;              // 
	GPIO15_LEVEL_HIGH = false;              // 
	GPIO15_EDGE_LOW   = false;              // 
	GPIO15_EDGE_HIGH  = false;              // 
 }

 // Interrupt Force for dormant_wake
 register DORMANT_WAKE_INTF1_t DORMANT_WAKE_INTF1 at 0x40014174;

 type DORMANT_WAKE_INTF2_t {
	GPIO16_LEVEL_LOW  = false;              // 
	GPIO16_LEVEL_HIGH = false;              // 
	GPIO16_EDGE_LOW   = false;              // 
	GPIO16_EDGE_HIGH  = false;              // 
	GPIO17_LEVEL_LOW  = false;              // 
	GPIO17_LEVEL_HIGH = false;              // 
	GPIO17_EDGE_LOW   = false;              // 
	GPIO17_EDGE_HIGH  = false;              // 
	GPIO18_LEVEL_LOW  = false;              // 
	GPIO18_LEVEL_HIGH = false;              // 
	GPIO18_EDGE_LOW   = false;              // 
	GPIO18_EDGE_HIGH  = false;              // 
	GPIO19_LEVEL_LOW  = false;              // 
	GPIO19_LEVEL_HIGH = false;              // 
	GPIO19_EDGE_LOW   = false;              // 
	GPIO19_EDGE_HIGH  = false;              // 
	GPIO20_LEVEL_LOW  = false;              // 
	GPIO20_LEVEL_HIGH = false;              // 
	GPIO20_EDGE_LOW   = false;              // 
	GPIO20_EDGE_HIGH  = false;              // 
	GPIO21_LEVEL_LOW  = false;              // 
	GPIO21_LEVEL_HIGH = false;              // 
	GPIO21_EDGE_LOW   = false;              // 
	GPIO21_EDGE_HIGH  = false;              // 
	GPIO22_LEVEL_LOW  = false;              // 
	GPIO22_LEVEL_HIGH = false;              // 
	GPIO22_EDGE_LOW   = false;              // 
	GPIO22_EDGE_HIGH  = false;              // 
	GPIO23_LEVEL_LOW  = false;              // 
	GPIO23_LEVEL_HIGH = false;              // 
	GPIO23_EDGE_LOW   = false;              // 
	GPIO23_EDGE_HIGH  = false;              // 
 }

 // Interrupt Force for dormant_wake
 register DORMANT_WAKE_INTF2_t DORMANT_WAKE_INTF2 at 0x40014178;

 type DORMANT_WAKE_INTF3_t {
	GPIO24_LEVEL_LOW  = false;              // 
	GPIO24_LEVEL_HIGH = false;              // 
	GPIO24_EDGE_LOW   = false;              // 
	GPIO24_EDGE_HIGH  = false;              // 
	GPIO25_LEVEL_LOW  = false;              // 
	GPIO25_LEVEL_HIGH = false;              // 
	GPIO25_EDGE_LOW   = false;              // 
	GPIO25_EDGE_HIGH  = false;              // 
	GPIO26_LEVEL_LOW  = false;              // 
	GPIO26_LEVEL_HIGH = false;              // 
	GPIO26_EDGE_LOW   = false;              // 
	GPIO26_EDGE_HIGH  = false;              // 
	GPIO27_LEVEL_LOW  = false;              // 
	GPIO27_LEVEL_HIGH = false;              // 
	GPIO27_EDGE_LOW   = false;              // 
	GPIO27_EDGE_HIGH  = false;              // 
	GPIO28_LEVEL_LOW  = false;              // 
	GPIO28_LEVEL_HIGH = false;              // 
	GPIO28_EDGE_LOW   = false;              // 
	GPIO28_EDGE_HIGH  = false;              // 
	GPIO29_LEVEL_LOW  = false;              // 
	GPIO29_LEVEL_HIGH = false;              // 
	GPIO29_EDGE_LOW   = false;              // 
	GPIO29_EDGE_HIGH  = false;              // 
 }

 // Interrupt Force for dormant_wake
 register DORMANT_WAKE_INTF3_t DORMANT_WAKE_INTF3 at 0x4001417c;

 type DORMANT_WAKE_INTS0_t {
	GPIO0_LEVEL_LOW  = false;              // 
	GPIO0_LEVEL_HIGH = false;              // 
	GPIO0_EDGE_LOW   = false;              // 
	GPIO0_EDGE_HIGH  = false;              // 
	GPIO1_LEVEL_LOW  = false;              // 
	GPIO1_LEVEL_HIGH = false;              // 
	GPIO1_EDGE_LOW   = false;              // 
	GPIO1_EDGE_HIGH  = false;              // 
	GPIO2_LEVEL_LOW  = false;              // 
	GPIO2_LEVEL_HIGH = false;              // 
	GPIO2_EDGE_LOW   = false;              // 
	GPIO2_EDGE_HIGH  = false;              // 
	GPIO3_LEVEL_LOW  = false;              // 
	GPIO3_LEVEL_HIGH = false;              // 
	GPIO3_EDGE_LOW   = false;              // 
	GPIO3_EDGE_HIGH  = false;              // 
	GPIO4_LEVEL_LOW  = false;              // 
	GPIO4_LEVEL_HIGH = false;              // 
	GPIO4_EDGE_LOW   = false;              // 
	GPIO4_EDGE_HIGH  = false;              // 
	GPIO5_LEVEL_LOW  = false;              // 
	GPIO5_LEVEL_HIGH = false;              // 
	GPIO5_EDGE_LOW   = false;              // 
	GPIO5_EDGE_HIGH  = false;              // 
	GPIO6_LEVEL_LOW  = false;              // 
	GPIO6_LEVEL_HIGH = false;              // 
	GPIO6_EDGE_LOW   = false;              // 
	GPIO6_EDGE_HIGH  = false;              // 
	GPIO7_LEVEL_LOW  = false;              // 
	GPIO7_LEVEL_HIGH = false;              // 
	GPIO7_EDGE_LOW   = false;              // 
	GPIO7_EDGE_HIGH  = false;              // 
 }

 // Interrupt status after masking & forcing for dormant_wake
 register DORMANT_WAKE_INTS0_t DORMANT_WAKE_INTS0 at 0x40014180;

 type DORMANT_WAKE_INTS1_t {
	GPIO8_LEVEL_LOW   = false;              // 
	GPIO8_LEVEL_HIGH  = false;              // 
	GPIO8_EDGE_LOW    = false;              // 
	GPIO8_EDGE_HIGH   = false;              // 
	GPIO9_LEVEL_LOW   = false;              // 
	GPIO9_LEVEL_HIGH  = false;              // 
	GPIO9_EDGE_LOW    = false;              // 
	GPIO9_EDGE_HIGH   = false;              // 
	GPIO10_LEVEL_LOW  = false;              // 
	GPIO10_LEVEL_HIGH = false;              // 
	GPIO10_EDGE_LOW   = false;              // 
	GPIO10_EDGE_HIGH  = false;              // 
	GPIO11_LEVEL_LOW  = false;              // 
	GPIO11_LEVEL_HIGH = false;              // 
	GPIO11_EDGE_LOW   = false;              // 
	GPIO11_EDGE_HIGH  = false;              // 
	GPIO12_LEVEL_LOW  = false;              // 
	GPIO12_LEVEL_HIGH = false;              // 
	GPIO12_EDGE_LOW   = false;              // 
	GPIO12_EDGE_HIGH  = false;              // 
	GPIO13_LEVEL_LOW  = false;              // 
	GPIO13_LEVEL_HIGH = false;              // 
	GPIO13_EDGE_LOW   = false;              // 
	GPIO13_EDGE_HIGH  = false;              // 
	GPIO14_LEVEL_LOW  = false;              // 
	GPIO14_LEVEL_HIGH = false;              // 
	GPIO14_EDGE_LOW   = false;              // 
	GPIO14_EDGE_HIGH  = false;              // 
	GPIO15_LEVEL_LOW  = false;              // 
	GPIO15_LEVEL_HIGH = false;              // 
	GPIO15_EDGE_LOW   = false;              // 
	GPIO15_EDGE_HIGH  = false;              // 
 }

 // Interrupt status after masking & forcing for dormant_wake
 register DORMANT_WAKE_INTS1_t DORMANT_WAKE_INTS1 at 0x40014184;

 type DORMANT_WAKE_INTS2_t {
	GPIO16_LEVEL_LOW  = false;              // 
	GPIO16_LEVEL_HIGH = false;              // 
	GPIO16_EDGE_LOW   = false;              // 
	GPIO16_EDGE_HIGH  = false;              // 
	GPIO17_LEVEL_LOW  = false;              // 
	GPIO17_LEVEL_HIGH = false;              // 
	GPIO17_EDGE_LOW   = false;              // 
	GPIO17_EDGE_HIGH  = false;              // 
	GPIO18_LEVEL_LOW  = false;              // 
	GPIO18_LEVEL_HIGH = false;              // 
	GPIO18_EDGE_LOW   = false;              // 
	GPIO18_EDGE_HIGH  = false;              // 
	GPIO19_LEVEL_LOW  = false;              // 
	GPIO19_LEVEL_HIGH = false;              // 
	GPIO19_EDGE_LOW   = false;              // 
	GPIO19_EDGE_HIGH  = false;              // 
	GPIO20_LEVEL_LOW  = false;              // 
	GPIO20_LEVEL_HIGH = false;              // 
	GPIO20_EDGE_LOW   = false;              // 
	GPIO20_EDGE_HIGH  = false;              // 
	GPIO21_LEVEL_LOW  = false;              // 
	GPIO21_LEVEL_HIGH = false;              // 
	GPIO21_EDGE_LOW   = false;              // 
	GPIO21_EDGE_HIGH  = false;              // 
	GPIO22_LEVEL_LOW  = false;              // 
	GPIO22_LEVEL_HIGH = false;              // 
	GPIO22_EDGE_LOW   = false;              // 
	GPIO22_EDGE_HIGH  = false;              // 
	GPIO23_LEVEL_LOW  = false;              // 
	GPIO23_LEVEL_HIGH = false;              // 
	GPIO23_EDGE_LOW   = false;              // 
	GPIO23_EDGE_HIGH  = false;              // 
 }

 // Interrupt status after masking & forcing for dormant_wake
 register DORMANT_WAKE_INTS2_t DORMANT_WAKE_INTS2 at 0x40014188;

 type DORMANT_WAKE_INTS3_t {
	GPIO24_LEVEL_LOW  = false;              // 
	GPIO24_LEVEL_HIGH = false;              // 
	GPIO24_EDGE_LOW   = false;              // 
	GPIO24_EDGE_HIGH  = false;              // 
	GPIO25_LEVEL_LOW  = false;              // 
	GPIO25_LEVEL_HIGH = false;              // 
	GPIO25_EDGE_LOW   = false;              // 
	GPIO25_EDGE_HIGH  = false;              // 
	GPIO26_LEVEL_LOW  = false;              // 
	GPIO26_LEVEL_HIGH = false;              // 
	GPIO26_EDGE_LOW   = false;              // 
	GPIO26_EDGE_HIGH  = false;              // 
	GPIO27_LEVEL_LOW  = false;              // 
	GPIO27_LEVEL_HIGH = false;              // 
	GPIO27_EDGE_LOW   = false;              // 
	GPIO27_EDGE_HIGH  = false;              // 
	GPIO28_LEVEL_LOW  = false;              // 
	GPIO28_LEVEL_HIGH = false;              // 
	GPIO28_EDGE_LOW   = false;              // 
	GPIO28_EDGE_HIGH  = false;              // 
	GPIO29_LEVEL_LOW  = false;              // 
	GPIO29_LEVEL_HIGH = false;              // 
	GPIO29_EDGE_LOW   = false;              // 
	GPIO29_EDGE_HIGH  = false;              // 
 }

 // Interrupt status after masking & forcing for dormant_wake
 register DORMANT_WAKE_INTS3_t DORMANT_WAKE_INTS3 at 0x4001418c;


/* Types and registers for SYSINFO  */

 type CHIP_ID_t {
	MANUFACTURER = uint12(0);          // 
	PART         = uint16(0);          // 
	REVISION     = uint4(0);           // 
 }

 // JEDEC JEP-106 compliant chip identifier.
 register CHIP_ID_t CHIP_ID at 0x40000000;

 type SYSINFO_PLATFORM_t {
	FPGA = false;              // 
	ASIC = false;              // 
 }

 // Platform register. Allows software to know what environment it is running in.
 register SYSINFO_PLATFORM_t SYSINFO_PLATFORM at 0x40000004;

 type GITREF_RP2040_t {
	GITREF_RP2040 = uint32(0);          // 
 }

 // Git hash of the chip source. Used to identify chip version.
 register GITREF_RP2040_t GITREF_RP2040 at 0x40000010;


/* Types and registers for PPB  */

 type SYST_CSR_t {
	ENABLE    = false;              // Enable SysTick counter: 0 = Counter disabled. 1 = Counter enabled.
	TICKINT   = false;              // Enables SysTick exception request: 0 = Counting down to zero does not assert the SysTick exception request. 1 = Counting down to zero to asserts the SysTick exception request.
	CLKSOURCE = false;              // SysTick clock source. Always reads as one if SYST_CALIB reports NOREF. Selects the SysTick timer clock source: 0 = External reference clock. 1 = Processor clock.
	_res1     = uint8(0);           // Reserved, 13 bits
	_res2     = uint5(0);           // 
	COUNTFLAG = false;              // Returns 1 if timer counted to 0 since last time this was read. Clears on read by application or debugger.
 }

 // Use the SysTick Control and Status Register to enable the SysTick features.
 register SYST_CSR_t SYST_CSR at 0xe000e010;

 type SYST_RVR_t {
	RELOAD = uint24(0);          // Value to load into the SysTick Current Value Register when the counter reaches 0.
 }

 // Use the SysTick Reload Value Register to specify the start value to load into the current value register when the counter reaches 0. It can be any value between 0 and 0x00FFFFFF. A start value of 0 is possible, but has no effect because the SysTick interrupt and COUNTFLAG are activated when counting from 1 to 0. The reset value of this register is UNKNOWN. To generate a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1. For example, if the SysTick interrupt is required every 100 clock pulses, set RELOAD to 99.
 register SYST_RVR_t SYST_RVR at 0xe000e014;

 type SYST_CVR_t {
	CURRENT = uint24(0);          // Reads return the current value of the SysTick counter. This register is write-clear. Writing to it with any value clears the register to 0. Clearing this register also clears the COUNTFLAG bit of the SysTick Control and Status Register.
 }

 // Use the SysTick Current Value Register to find the current value in the register. The reset value of this register is UNKNOWN.
 register SYST_CVR_t SYST_CVR at 0xe000e018;

 type SYST_CALIB_t {
	TENMS = uint24(0);          // An optional Reload value to be used for 10ms (100Hz) timing, subject to system clock skew errors. If the value reads as 0, the calibration value is not known.
	_res1 = uint6(0);           // Reserved, 6 bits
	SKEW  = false;              // If reads as 1, the calibration value for 10ms is inexact (due to clock frequency).
	NOREF = false;              // If reads as 1, the Reference clock is not provided - the CLKSOURCE bit of the SysTick Control and Status register will be forced to 1 and cannot be cleared to 0.
 }

 // Use the SysTick Calibration Value Register to enable software to scale to any required speed using divide and multiply.
 register SYST_CALIB_t SYST_CALIB at 0xe000e01c;

 type NVIC_ISER_t {
	SETENA = uint32(0);          // Interrupt set-enable bits. Write: 0 = No effect. 1 = Enable interrupt. Read: 0 = Interrupt disabled. 1 = Interrupt enabled.
 }

 // Use the Interrupt Set-Enable Register to enable interrupts and determine which interrupts are currently enabled. If a pending interrupt is enabled, the NVIC activates the interrupt based on its priority. If an interrupt is not enabled, asserting its interrupt signal changes the interrupt state to pending, but the NVIC never activates the interrupt, regardless of its priority.
 register NVIC_ISER_t NVIC_ISER at 0xe000e100;

 type NVIC_ICER_t {
	CLRENA = uint32(0);          // Interrupt clear-enable bits. Write: 0 = No effect. 1 = Disable interrupt. Read: 0 = Interrupt disabled. 1 = Interrupt enabled.
 }

 // Use the Interrupt Clear-Enable Registers to disable interrupts and determine which interrupts are currently enabled.
 register NVIC_ICER_t NVIC_ICER at 0xe000e180;

 type NVIC_ISPR_t {
	SETPEND = uint32(0);          // Interrupt set-pending bits. Write: 0 = No effect. 1 = Changes interrupt state to pending. Read: 0 = Interrupt is not pending. 1 = Interrupt is pending. Note: Writing 1 to the NVIC_ISPR bit corresponding to: An interrupt that is pending has no effect. A disabled interrupt sets the state of that interrupt to pending.
 }

 // The NVIC_ISPR forces interrupts into the pending state, and shows which interrupts are pending.
 register NVIC_ISPR_t NVIC_ISPR at 0xe000e200;

 type NVIC_ICPR_t {
	CLRPEND = uint32(0);          // Interrupt clear-pending bits. Write: 0 = No effect. 1 = Removes pending state and interrupt. Read: 0 = Interrupt is not pending. 1 = Interrupt is pending.
 }

 // Use the Interrupt Clear-Pending Register to clear pending interrupts and determine which interrupts are currently pending.
 register NVIC_ICPR_t NVIC_ICPR at 0xe000e280;

 type NVIC_IPR0_t {
	_res1 = uint6(0);           // Reserved, 6 bits
	IP_0  = uint2(0);           // Priority of interrupt 0
	_res2 = uint6(0);           // Reserved, 6 bits
	IP_1  = uint2(0);           // Priority of interrupt 1
	_res3 = uint6(0);           // Reserved, 6 bits
	IP_2  = uint2(0);           // Priority of interrupt 2
	_res4 = uint6(0);           // Reserved, 6 bits
	IP_3  = uint2(0);           // Priority of interrupt 3
 }

 // Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest. Note: Writing 1 to an NVIC_ICPR bit does not affect the active state of the corresponding interrupt. These registers are only word-accessible
 register NVIC_IPR0_t NVIC_IPR0 at 0xe000e400;

 type NVIC_IPR1_t {
	_res1 = uint6(0);           // Reserved, 6 bits
	IP_4  = uint2(0);           // Priority of interrupt 4
	_res2 = uint6(0);           // Reserved, 6 bits
	IP_5  = uint2(0);           // Priority of interrupt 5
	_res3 = uint6(0);           // Reserved, 6 bits
	IP_6  = uint2(0);           // Priority of interrupt 6
	_res4 = uint6(0);           // Reserved, 6 bits
	IP_7  = uint2(0);           // Priority of interrupt 7
 }

 // Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
 register NVIC_IPR1_t NVIC_IPR1 at 0xe000e404;

 type NVIC_IPR2_t {
	_res1 = uint6(0);           // Reserved, 6 bits
	IP_8  = uint2(0);           // Priority of interrupt 8
	_res2 = uint6(0);           // Reserved, 6 bits
	IP_9  = uint2(0);           // Priority of interrupt 9
	_res3 = uint6(0);           // Reserved, 6 bits
	IP_10 = uint2(0);           // Priority of interrupt 10
	_res4 = uint6(0);           // Reserved, 6 bits
	IP_11 = uint2(0);           // Priority of interrupt 11
 }

 // Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
 register NVIC_IPR2_t NVIC_IPR2 at 0xe000e408;

 type NVIC_IPR3_t {
	_res1 = uint6(0);           // Reserved, 6 bits
	IP_12 = uint2(0);           // Priority of interrupt 12
	_res2 = uint6(0);           // Reserved, 6 bits
	IP_13 = uint2(0);           // Priority of interrupt 13
	_res3 = uint6(0);           // Reserved, 6 bits
	IP_14 = uint2(0);           // Priority of interrupt 14
	_res4 = uint6(0);           // Reserved, 6 bits
	IP_15 = uint2(0);           // Priority of interrupt 15
 }

 // Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
 register NVIC_IPR3_t NVIC_IPR3 at 0xe000e40c;

 type NVIC_IPR4_t {
	_res1 = uint6(0);           // Reserved, 6 bits
	IP_16 = uint2(0);           // Priority of interrupt 16
	_res2 = uint6(0);           // Reserved, 6 bits
	IP_17 = uint2(0);           // Priority of interrupt 17
	_res3 = uint6(0);           // Reserved, 6 bits
	IP_18 = uint2(0);           // Priority of interrupt 18
	_res4 = uint6(0);           // Reserved, 6 bits
	IP_19 = uint2(0);           // Priority of interrupt 19
 }

 // Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
 register NVIC_IPR4_t NVIC_IPR4 at 0xe000e410;

 type NVIC_IPR5_t {
	_res1 = uint6(0);           // Reserved, 6 bits
	IP_20 = uint2(0);           // Priority of interrupt 20
	_res2 = uint6(0);           // Reserved, 6 bits
	IP_21 = uint2(0);           // Priority of interrupt 21
	_res3 = uint6(0);           // Reserved, 6 bits
	IP_22 = uint2(0);           // Priority of interrupt 22
	_res4 = uint6(0);           // Reserved, 6 bits
	IP_23 = uint2(0);           // Priority of interrupt 23
 }

 // Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
 register NVIC_IPR5_t NVIC_IPR5 at 0xe000e414;

 type NVIC_IPR6_t {
	_res1 = uint6(0);           // Reserved, 6 bits
	IP_24 = uint2(0);           // Priority of interrupt 24
	_res2 = uint6(0);           // Reserved, 6 bits
	IP_25 = uint2(0);           // Priority of interrupt 25
	_res3 = uint6(0);           // Reserved, 6 bits
	IP_26 = uint2(0);           // Priority of interrupt 26
	_res4 = uint6(0);           // Reserved, 6 bits
	IP_27 = uint2(0);           // Priority of interrupt 27
 }

 // Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
 register NVIC_IPR6_t NVIC_IPR6 at 0xe000e418;

 type NVIC_IPR7_t {
	_res1 = uint6(0);           // Reserved, 6 bits
	IP_28 = uint2(0);           // Priority of interrupt 28
	_res2 = uint6(0);           // Reserved, 6 bits
	IP_29 = uint2(0);           // Priority of interrupt 29
	_res3 = uint6(0);           // Reserved, 6 bits
	IP_30 = uint2(0);           // Priority of interrupt 30
	_res4 = uint6(0);           // Reserved, 6 bits
	IP_31 = uint2(0);           // Priority of interrupt 31
 }

 // Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
 register NVIC_IPR7_t NVIC_IPR7 at 0xe000e41c;

 type PPB_CPUID_t {
	REVISION     = uint4(0);           // Minor revision number m in the rnpm revision status: 0x1 = Patch 1.
	PARTNO       = uint12(0);          // Number of processor within family: 0xC60 = Cortex-M0+
	ARCHITECTURE = uint4(0);           // Constant that defines the architecture of the processor: 0xC = ARMv6-M architecture.
	VARIANT      = uint4(0);           // Major revision number n in the rnpm revision status: 0x0 = Revision 0.
	IMPLEMENTER  = uint8(0);           // Implementor code: 0x41 = ARM
 }

 // Read the CPU ID Base Register to determine: the ID number of the processor core, the version number of the processor core, the implementation details of the processor core.
 register PPB_CPUID_t PPB_CPUID at 0xe000ed00;

 type ICSR_t {
	VECTACTIVE  = uint9(0);           // Active exception number field. Reset clears the VECTACTIVE field.
	_res1       = uint3(0);           // Reserved, 3 bits
	VECTPENDING = uint9(0);           // Indicates the exception number for the highest priority pending exception: 0 = no pending exceptions. Non zero = The pending state includes the effect of memory-mapped enable and mask registers. It does not include the PRIMASK special-purpose register qualifier.
	_res2       = false;              // Reserved, 1 bits
	ISRPENDING  = false;              // External interrupt pending flag
	ISRPREEMPT  = false;              // The system can only access this bit when the core is halted. It indicates that a pending interrupt is to be taken in the next running cycle. If C_MASKINTS is clear in the Debug Halting Control and Status Register, the interrupt is serviced.
	_res3       = false;              // Reserved, 1 bits
	PENDSTCLR   = false;              // SysTick exception clear-pending bit. Write: 0 = No effect. 1 = Removes the pending state from the SysTick exception. This bit is WO. On a register read its value is Unknown.
	PENDSTSET   = false;              // SysTick exception set-pending bit. Write: 0 = No effect. 1 = Changes SysTick exception state to pending. Read: 0 = SysTick exception is not pending. 1 = SysTick exception is pending.
	PENDSVCLR   = false;              // PendSV clear-pending bit. Write: 0 = No effect. 1 = Removes the pending state from the PendSV exception.
	PENDSVSET   = false;              // PendSV set-pending bit. Write: 0 = No effect. 1 = Changes PendSV exception state to pending. Read: 0 = PendSV exception is not pending. 1 = PendSV exception is pending. Writing 1 to this bit is the only way to set the PendSV exception state to pending.
	_res4       = uint2(0);           // Reserved, 2 bits
	NMIPENDSET  = false;              // Setting this bit will activate an NMI. Since NMI is the highest priority exception, it will activate as soon as it is registered. NMI set-pending bit. Write: 0 = No effect. 1 = Changes NMI exception state to pending. Read: 0 = NMI exception is not pending. 1 = NMI exception is pending. Because NMI is the highest-priority exception, normally the processor enters the NMI exception handler as soon as it detects a write of 1 to this bit. Entering the handler then clears this bit to 0. This means a read of this bit by the NMI exception handler returns 1 only if the NMI signal is reasserted while the processor is executing that handler.
 }

 // Use the Interrupt Control State Register to set a pending Non-Maskable Interrupt (NMI), set or clear a pending PendSV, set or clear a pending SysTick, check for pending exceptions, check the vector number of the highest priority pended exception, check the vector number of the active exception.
 register ICSR_t ICSR at 0xe000ed04;

 type VTOR_t {
	_res1  = uint8(0);           // Reserved, 8 bits
	TBLOFF = uint24(0);          // Bits [31:8] of the indicate the vector table offset address.
 }

 // The VTOR holds the vector table offset address.
 register VTOR_t VTOR at 0xe000ed08;

 type AIRCR_t {
	_res1         = false;              // Reserved, 1 bits
	VECTCLRACTIVE = false;              // Clears all active state information for fixed and configurable exceptions. This bit: is self-clearing, can only be set by the DAP when the core is halted. When set: clears all active exception status of the processor, forces a return to Thread mode, forces an IPSR of 0. A debugger must re-initialize the stack.
	SYSRESETREQ   = false;              // Writing 1 to this bit causes the SYSRESETREQ signal to the outer system to be asserted to request a reset. The intention is to force a large system reset of all major components except for debug. The C_HALT bit in the DHCSR is cleared as a result of the system reset requested. The debugger does not lose contact with the device.
	_res2         = uint8(0);           // Reserved, 12 bits
	_res3         = uint4(0);           // 
	ENDIANESS     = false;              // Data endianness implemented: 0 = Little-endian.
	VECTKEY       = uint16(0);          // Register key: Reads as Unknown On writes, write 0x05FA to VECTKEY, otherwise the write is ignored.
 }

 // Use the Application Interrupt and Reset Control Register to: determine data endianness, clear all active state information from debug halt mode, request a system reset.
 register AIRCR_t AIRCR at 0xe000ed0c;

 type SCR_t {
	_res1       = false;              // Reserved, 1 bits
	SLEEPONEXIT = false;              // Indicates sleep-on-exit when returning from Handler mode to Thread mode: 0 = Do not sleep when returning to Thread mode. 1 = Enter sleep, or deep sleep, on return from an ISR to Thread mode. Setting this bit to 1 enables an interrupt driven application to avoid returning to an empty main application.
	SLEEPDEEP   = false;              // Controls whether the processor uses sleep or deep sleep as its low power mode: 0 = Sleep. 1 = Deep sleep.
	_res2       = false;              // Reserved, 1 bits
	SEVONPEND   = false;              // Send Event on Pending bit: 0 = Only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded. 1 = Enabled events and all interrupts, including disabled interrupts, can wakeup the processor. When an event or interrupt becomes pending, the event signal wakes up the processor from WFE. If the processor is not waiting for an event, the event is registered and affects the next WFE. The processor also wakes up on execution of an SEV instruction or an external event.
 }

 // System Control Register. Use the System Control Register for power-management functions: signal to the system when the processor can enter a low power state, control how the processor enters and exits low power states.
 register SCR_t SCR at 0xe000ed10;

 type CCR_t {
	_res1       = uint3(0);           // Reserved, 3 bits
	UNALIGN_TRP = false;              // Always reads as one, indicates that all unaligned accesses generate a HardFault.
	_res2       = uint5(0);           // Reserved, 5 bits
	STKALIGN    = false;              // Always reads as one, indicates 8-byte stack alignment on exception entry. On exception entry, the processor uses bit[9] of the stacked PSR to indicate the stack alignment. On return from the exception it uses this stacked bit to restore the correct stack alignment.
 }

 // The Configuration and Control Register permanently enables stack alignment and causes unaligned accesses to result in a Hard Fault.
 register CCR_t CCR at 0xe000ed14;

 type SHPR2_t {
	_res1  = uint16(0);          // Reserved, 30 bits
	_res2  = uint8(0);           // 
	_res3  = uint6(0);           // 
	PRI_11 = uint2(0);           // Priority of system handler 11, SVCall
 }

 // System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 2 to set the priority of SVCall.
 register SHPR2_t SHPR2 at 0xe000ed1c;

 type SHPR3_t {
	_res1  = uint16(0);          // Reserved, 22 bits
	_res2  = uint6(0);           // 
	PRI_14 = uint2(0);           // Priority of system handler 14, PendSV
	_res3  = uint6(0);           // Reserved, 6 bits
	PRI_15 = uint2(0);           // Priority of system handler 15, SysTick
 }

 // System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 3 to set the priority of PendSV and SysTick.
 register SHPR3_t SHPR3 at 0xe000ed20;

 type SHCSR_t {
	_res1        = uint8(0);           // Reserved, 15 bits
	_res2        = uint7(0);           // 
	SVCALLPENDED = false;              // Reads as 1 if SVCall is Pending. Write 1 to set pending SVCall, write 0 to clear pending SVCall.
 }

 // Use the System Handler Control and State Register to determine or clear the pending status of SVCall.
 register SHCSR_t SHCSR at 0xe000ed24;

 type MPU_TYPE_t {
	SEPARATE = false;              // Indicates support for separate instruction and data address maps. Reads as 0 as ARMv6-M only supports a unified MPU.
	_res1    = uint7(0);           // Reserved, 7 bits
	DREGION  = uint8(0);           // Number of regions supported by the MPU.
	IREGION  = uint8(0);           // Instruction region. Reads as zero as ARMv6-M only supports a unified MPU.
 }

 // Read the MPU Type Register to determine if the processor implements an MPU, and how many regions the MPU supports.
 register MPU_TYPE_t MPU_TYPE at 0xe000ed90;

 type MPU_CTRL_t {
	ENABLE     = false;              // Enables the MPU. If the MPU is disabled, privileged and unprivileged accesses use the default memory map. 0 = MPU disabled. 1 = MPU enabled.
	HFNMIENA   = false;              // Controls the use of the MPU for HardFaults and NMIs. Setting this bit when ENABLE is clear results in UNPREDICTABLE behaviour. When the MPU is enabled: 0 = MPU is disabled during HardFault and NMI handlers, regardless of the value of the ENABLE bit. 1 = the MPU is enabled during HardFault and NMI handlers.
	PRIVDEFENA = false;              // Controls whether the default memory map is enabled as a background region for privileged accesses. This bit is ignored when ENABLE is clear. 0 = If the MPU is enabled, disables use of the default memory map. Any memory access to a location not covered by any enabled region causes a fault. 1 = If the MPU is enabled, enables use of the default memory map as a background region for privileged software accesses. When enabled, the background region acts as if it is region number -1. Any region that is defined and enabled has priority over this default map.
 }

 // Use the MPU Control Register to enable and disable the MPU, and to control whether the default memory map is enabled as a background region for privileged accesses, and whether the MPU is enabled for HardFaults and NMIs.
 register MPU_CTRL_t MPU_CTRL at 0xe000ed94;

 type MPU_RNR_t {
	REGION = uint4(0);           // Indicates the MPU region referenced by the MPU_RBAR and MPU_RASR registers. The MPU supports 8 memory regions, so the permitted values of this field are 0-7.
 }

 // Use the MPU Region Number Register to select the region currently accessed by MPU_RBAR and MPU_RASR.
 register MPU_RNR_t MPU_RNR at 0xe000ed98;

 type MPU_RBAR_t {
	REGION = uint4(0);           // On writes, specifies the number of the region whose base address to update provided VALID is set written as 1. On reads, returns bits [3:0] of MPU_RNR.
	VALID  = false;              // On writes, indicates whether the write must update the base address of the region identified by the REGION field, updating the MPU_RNR to indicate this new region. Write: 0 = MPU_RNR not changed, and the processor: Updates the base address for the region specified in the MPU_RNR. Ignores the value of the REGION field. 1 = The processor: Updates the value of the MPU_RNR to the value of the REGION field. Updates the base address for the region specified in the REGION field. Always reads as zero.
	_res1  = uint3(0);           // Reserved, 3 bits
	ADDR   = uint24(0);          // Base address of the region.
 }

 // Read the MPU Region Base Address Register to determine the base address of the region identified by MPU_RNR. Write to update the base address of said region or that of a specified region, with whose number MPU_RNR will also be updated.
 register MPU_RBAR_t MPU_RBAR at 0xe000ed9c;

 type MPU_RASR_t {
	ENABLE = false;              // Enables the region.
	SIZE   = uint5(0);           // Indicates the region size. Region size in bytes = 2^(SIZE+1). The minimum permitted value is 7 (b00111) = 256Bytes
	_res1  = uint2(0);           // Reserved, 2 bits
	SRD    = uint8(0);           // Subregion Disable. For regions of 256 bytes or larger, each bit of this field controls whether one of the eight equal subregions is enabled.
	ATTRS  = uint16(0);          // The MPU Region Attribute field. Use to define the region attribute control. 28 = XN: Instruction access disable bit: 0 = Instruction fetches enabled. 1 = Instruction fetches disabled. 26:24 = AP: Access permission field 18 = S: Shareable bit 17 = C: Cacheable bit 16 = B: Bufferable bit
 }

 // Use the MPU Region Attribute and Size Register to define the size, access behaviour and memory type of the region identified by MPU_RNR, and enable that region.
 register MPU_RASR_t MPU_RASR at 0xe000eda0;


/* Types and registers for SSI 
  DW_apb_ssi has the following features: * APB interface – Allows for easy integration into a DesignWare Synthesizable Components for AMBA 2 implementation. * APB3 and APB4 protocol support. * Scalable APB data bus width – Supports APB data bus widths of 8, 16, and 32 bits. * Serial-master or serial-slave operation – Enables serial communication with serial-master or serial-slave peripheral devices. * Programmable Dual/Quad/Octal SPI support in Master Mode. * Dual Data Rate (DDR) and Read Data Strobe (RDS) Support - Enables the DW_apb_ssi master to perform operations with the device in DDR and RDS modes when working in Dual/Quad/Octal mode of operation. * Data Mask Support - Enables the DW_apb_ssi to selectively update the bytes in the device. This feature is applicable only in enhanced SPI modes. * eXecute-In-Place (XIP) support - Enables the DW_apb_ssi master to behave as a memory mapped I/O and fetches the data from the device based on the APB read request. This feature is applicable only in enhanced SPI modes. * DMA Controller Interface – Enables the DW_apb_ssi to interface to a DMA controller over the bus using a handshaking interface for transfer requests. * Independent masking of interrupts – Master collision, transmit FIFO overflow, transmit FIFO empty, receive FIFO full, receive FIFO underflow, and receive FIFO overflow interrupts can all be masked independently. * Multi-master contention detection – Informs the processor of multiple serial-master accesses on the serial bus. * Bypass of meta-stability flip-flops for synchronous clocks – When the APB clock (pclk) and the DW_apb_ssi serial clock (ssi_clk) are synchronous, meta-stable flip-flops are not used when transferring control signals across these clock domains. * Programmable delay on the sample time of the received serial data bit (rxd); enables programmable control of routing delays resulting in higher serial data-bit rates. * Programmable features: - Serial interface operation – Choice of Motorola SPI, Texas Instruments Synchronous Serial Protocol or National Semiconductor Microwire. - Clock bit-rate – Dynamic control of the serial bit rate of the data transfer; used in only serial-master mode of operation. - Data Item size (4 to 32 bits) – Item size of each data transfer under the control of the programmer. * Configured features: - FIFO depth – 16 words deep. The FIFO width is fixed at 32 bits. - 1 slave select output. - Hardware slave-select – Dedicated hardware slave-select line. - Combined interrupt line - one combined interrupt line from the DW_apb_ssi to the interrupt controller. - Interrupt polarity – active high interrupt lines. - Serial clock polarity – low serial-clock polarity directly after reset. - Serial clock phase – capture on first edge of serial-clock directly after reset.
 */

 type CTRLR0_t {
	DFS     = uint4(0);           // Data frame size
	FRF     = uint2(0);           // Frame format
	SCPH    = false;              // Serial clock phase
	SCPOL   = false;              // Serial clock polarity
	TMOD    = uint2(0);           // Transfer mode
	SLV_OE  = false;              // Slave output enable
	SRL     = false;              // Shift register loop (test mode)
	CFS     = uint4(0);           // Control frame size Value of n -> n+1 clocks per frame.
	DFS_32  = uint5(0);           // Data frame size in 32b transfer mode Value of n -> n+1 clocks per frame.
	SPI_FRF = uint2(0);           // SPI frame format
	_res1   = false;              // Reserved, 1 bits
	SSTE    = false;              // Slave select toggle enable
 }

 // Control register 0
 register CTRLR0_t CTRLR0 at 0x18000000;

 type CTRLR1_t {
	NDF = uint16(0);          // Number of data frames
 }

 // Master Control register 1
 register CTRLR1_t CTRLR1 at 0x18000004;

 type SSIENR_t {
	SSI_EN = false;              // SSI enable
 }

 // SSI Enable
 register SSIENR_t SSIENR at 0x18000008;

 type MWCR_t {
	MWMOD = false;              // Microwire transfer mode
	MDD   = false;              // Microwire control
	MHS   = false;              // Microwire handshaking
 }

 // Microwire Control
 register MWCR_t MWCR at 0x1800000c;

 type SER_t {
	SER = false;              // For each bit: 0 -> slave not selected 1 -> slave selected
 }

 // Slave enable
 register SER_t SER at 0x18000010;

 type BAUDR_t {
	SCKDV = uint16(0);          // SSI clock divider
 }

 // Baud rate
 register BAUDR_t BAUDR at 0x18000014;

 type TXFTLR_t {
	TFT = uint8(0);           // Transmit FIFO threshold
 }

 // TX FIFO threshold level
 register TXFTLR_t TXFTLR at 0x18000018;

 type RXFTLR_t {
	RFT = uint8(0);           // Receive FIFO threshold
 }

 // RX FIFO threshold level
 register RXFTLR_t RXFTLR at 0x1800001c;

 type TXFLR_t {
	TFTFL = uint8(0);           // Transmit FIFO level
 }

 // TX FIFO level
 register TXFLR_t TXFLR at 0x18000020;

 type RXFLR_t {
	RXTFL = uint8(0);           // Receive FIFO level
 }

 // RX FIFO level
 register RXFLR_t RXFLR at 0x18000024;

 type SR_t {
	BUSY = false;              // SSI busy flag
	TFNF = false;              // Transmit FIFO not full
	TFE  = false;              // Transmit FIFO empty
	RFNE = false;              // Receive FIFO not empty
	RFF  = false;              // Receive FIFO full
	TXE  = false;              // Transmission error
	DCOL = false;              // Data collision error
 }

 // Status register
 register SR_t SR at 0x18000028;

 type IMR_t {
	TXEIM = false;              // Transmit FIFO empty interrupt mask
	TXOIM = false;              // Transmit FIFO overflow interrupt mask
	RXUIM = false;              // Receive FIFO underflow interrupt mask
	RXOIM = false;              // Receive FIFO overflow interrupt mask
	RXFIM = false;              // Receive FIFO full interrupt mask
	MSTIM = false;              // Multi-master contention interrupt mask
 }

 // Interrupt mask
 register IMR_t IMR at 0x1800002c;

 type ISR_t {
	TXEIS = false;              // Transmit FIFO empty interrupt status
	TXOIS = false;              // Transmit FIFO overflow interrupt status
	RXUIS = false;              // Receive FIFO underflow interrupt status
	RXOIS = false;              // Receive FIFO overflow interrupt status
	RXFIS = false;              // Receive FIFO full interrupt status
	MSTIS = false;              // Multi-master contention interrupt status
 }

 // Interrupt status
 register ISR_t ISR at 0x18000030;

 type RISR_t {
	TXEIR = false;              // Transmit FIFO empty raw interrupt status
	TXOIR = false;              // Transmit FIFO overflow raw interrupt status
	RXUIR = false;              // Receive FIFO underflow raw interrupt status
	RXOIR = false;              // Receive FIFO overflow raw interrupt status
	RXFIR = false;              // Receive FIFO full raw interrupt status
	MSTIR = false;              // Multi-master contention raw interrupt status
 }

 // Raw interrupt status
 register RISR_t RISR at 0x18000034;

 type TXOICR_t {
	TXOICR = false;              // Clear-on-read transmit FIFO overflow interrupt
 }

 // TX FIFO overflow interrupt clear
 register TXOICR_t TXOICR at 0x18000038;

 type RXOICR_t {
	RXOICR = false;              // Clear-on-read receive FIFO overflow interrupt
 }

 // RX FIFO overflow interrupt clear
 register RXOICR_t RXOICR at 0x1800003c;

 type RXUICR_t {
	RXUICR = false;              // Clear-on-read receive FIFO underflow interrupt
 }

 // RX FIFO underflow interrupt clear
 register RXUICR_t RXUICR at 0x18000040;

 type MSTICR_t {
	MSTICR = false;              // Clear-on-read multi-master contention interrupt
 }

 // Multi-master interrupt clear
 register MSTICR_t MSTICR at 0x18000044;

 type ICR_t {
	ICR = false;              // Clear-on-read all active interrupts
 }

 // Interrupt clear
 register ICR_t ICR at 0x18000048;

 type DMACR_t {
	RDMAE = false;              // Receive DMA enable
	TDMAE = false;              // Transmit DMA enable
 }

 // DMA control
 register DMACR_t DMACR at 0x1800004c;

 type DMATDLR_t {
	DMATDL = uint8(0);           // Transmit data watermark level
 }

 // DMA TX data level
 register DMATDLR_t DMATDLR at 0x18000050;

 type DMARDLR_t {
	DMARDL = uint8(0);           // Receive data watermark level (DMARDLR+1)
 }

 // DMA RX data level
 register DMARDLR_t DMARDLR at 0x18000054;

 type IDR_t {
	IDCODE = uint32(0);          // Peripheral dentification code
 }

 // Identification register
 register IDR_t IDR at 0x18000058;

 type SSI_VERSION_ID_t {
	SSI_COMP_VERSION = uint32(0);          // SNPS component version (format X.YY)
 }

 // Version ID
 register SSI_VERSION_ID_t SSI_VERSION_ID at 0x1800005c;

 type DR0_t {
	DR = uint32(0);          // First data register of 36
 }

 // Data Register 0 (of 36)
 register DR0_t DR0 at 0x18000060;

 type RX_SAMPLE_DLY_t {
	RSD = uint8(0);           // RXD sample delay (in SCLK cycles)
 }

 // RX sample delay
 register RX_SAMPLE_DLY_t RX_SAMPLE_DLY at 0x180000f0;

 type SPI_CTRLR0_t {
	TRANS_TYPE  = uint2(0);           // Address and instruction transfer format
	ADDR_L      = uint4(0);           // Address length (0b-60b in 4b increments)
	_res1       = uint2(0);           // Reserved, 2 bits
	INST_L      = uint2(0);           // Instruction length (0/4/8/16b)
	_res2       = false;              // Reserved, 1 bits
	WAIT_CYCLES = uint5(0);           // Wait cycles between control frame transmit and data reception (in SCLK cycles)
	SPI_DDR_EN  = false;              // SPI DDR transfer enable
	INST_DDR_EN = false;              // Instruction DDR transfer enable
	SPI_RXDS_EN = false;              // Read data strobe enable
	_res3       = uint5(0);           // Reserved, 5 bits
	XIP_CMD     = uint8(0);           // SPI Command to send in XIP mode (INST_L = 8-bit) or to append to Address (INST_L = 0-bit)
 }

 // SPI control
 register SPI_CTRLR0_t SPI_CTRLR0 at 0x180000f4;

 type TXD_DRIVE_EDGE_t {
	TDE = uint8(0);           // TXD drive edge
 }

 // TX drive edge
 register TXD_DRIVE_EDGE_t TXD_DRIVE_EDGE at 0x180000f8;


/* Types and registers for XIP_CTRL 
  QSPI flash execute-in-place block
 */

 type XIP_CTRL_CTRL_t {
	EN           = false;              // When 1, enable the cache. When the cache is disabled, all XIP accesses will go straight to the flash, without querying the cache. When enabled, cacheable XIP accesses will query the cache, and the flash will not be accessed if the tag matches and the valid bit is set. If the cache is enabled, cache-as-SRAM accesses have no effect on the cache data RAM, and will produce a bus error response.
	ERR_BADWRITE = false;              // When 1, writes to any alias other than 0x0 (caching, allocating) will produce a bus fault. When 0, these writes are silently ignored. In either case, writes to the 0x0 alias will deallocate on tag match, as usual.
	_res1        = false;              // Reserved, 1 bits
	POWER_DOWN   = false;              // When 1, the cache memories are powered down. They retain state, but can not be accessed. This reduces static power dissipation. Writing 1 to this bit forces CTRL_EN to 0, i.e. the cache cannot be enabled when powered down. Cache-as-SRAM accesses will produce a bus error response when the cache is powered down.
 }

 // Cache control
 register XIP_CTRL_CTRL_t XIP_CTRL_CTRL at 0x14000000;

 type FLUSH_t {
	FLUSH = false;              // Write 1 to flush the cache. This clears the tag memory, but the data memory retains its contents. (This means cache-as-SRAM contents is not affected by flush or reset.) Reading will hold the bus (stall the processor) until the flush completes. Alternatively STAT can be polled until completion.
 }

 // Cache Flush control
 register FLUSH_t FLUSH at 0x14000004;

 type STAT_t {
	FLUSH_READY = false;              // Reads as 0 while a cache flush is in progress, and 1 otherwise. The cache is flushed whenever the XIP block is reset, and also when requested via the FLUSH register.
	FIFO_EMPTY  = false;              // When 1, indicates the XIP streaming FIFO is completely empty.
	FIFO_FULL   = false;              // When 1, indicates the XIP streaming FIFO is completely full. The streaming FIFO is 2 entries deep, so the full and empty flag allow its level to be ascertained.
 }

 // Cache Status
 register STAT_t STAT at 0x14000008;

 type CTR_HIT_t {
	CTR_HIT = uint32(0);          // A 32 bit saturating counter that increments upon each cache hit, i.e. when an XIP access is serviced directly from cached data. Write any value to clear.
 }

 // Cache Hit counter
 register CTR_HIT_t CTR_HIT at 0x1400000c;

 type CTR_ACC_t {
	CTR_ACC = uint32(0);          // A 32 bit saturating counter that increments upon each XIP access, whether the cache is hit or not. This includes noncacheable accesses. Write any value to clear.
 }

 // Cache Access counter
 register CTR_ACC_t CTR_ACC at 0x14000010;

 type STREAM_ADDR_t {
	_res1       = uint2(0);           // Reserved, 2 bits
	STREAM_ADDR = uint30(0);          // The address of the next word to be streamed from flash to the streaming FIFO. Increments automatically after each flash access. Write the initial access address here before starting a streaming read.
 }

 // FIFO stream address
 register STREAM_ADDR_t STREAM_ADDR at 0x14000014;

 type STREAM_CTR_t {
	STREAM_CTR = uint22(0);          // Write a nonzero value to start a streaming read. This will then progress in the background, using flash idle cycles to transfer a linear data block from flash to the streaming FIFO. Decrements automatically (1 at a time) as the stream progresses, and halts on reaching 0. Write 0 to halt an in-progress stream, and discard any in-flight read, so that a new stream can immediately be started (after draining the FIFO and reinitialising STREAM_ADDR)
 }

 // FIFO stream control
 register STREAM_CTR_t STREAM_CTR at 0x14000018;

 type STREAM_FIFO_t {
	STREAM_FIFO = uint32(0);          // Streamed data is buffered here, for retrieval by the system DMA. This FIFO can also be accessed via the XIP_AUX slave, to avoid exposing the DMA to bus stalls caused by other XIP traffic.
 }

 // FIFO stream data
 register STREAM_FIFO_t STREAM_FIFO at 0x1400001c;


/* Types and registers for SYSCFG 
  Register block for various chip control signals
 */

 type PROC0_NMI_MASK_t {
	PROC0_NMI_MASK = uint32(0);          // Set a bit high to enable NMI from that IRQ
 }

 // Processor core 0 NMI source mask
 register PROC0_NMI_MASK_t PROC0_NMI_MASK at 0x40004000;

 type PROC1_NMI_MASK_t {
	PROC1_NMI_MASK = uint32(0);          // Set a bit high to enable NMI from that IRQ
 }

 // Processor core 1 NMI source mask
 register PROC1_NMI_MASK_t PROC1_NMI_MASK at 0x40004004;

 type PROC_CONFIG_t {
	PROC0_HALTED     = false;              // Indication that proc0 has halted
	PROC1_HALTED     = false;              // Indication that proc1 has halted
	_res1            = uint16(0);          // Reserved, 22 bits
	_res2            = uint6(0);           // 
	PROC0_DAP_INSTID = uint4(0);           // Configure proc0 DAP instance ID. Recommend that this is NOT changed until you require debug access in multi-chip environment WARNING: do not set to 15 as this is reserved for RescueDP
	PROC1_DAP_INSTID = uint4(0);           // Configure proc1 DAP instance ID. Recommend that this is NOT changed until you require debug access in multi-chip environment WARNING: do not set to 15 as this is reserved for RescueDP
 }

 // Configuration for processors
 register PROC_CONFIG_t PROC_CONFIG at 0x40004008;

 type PROC_IN_SYNC_BYPASS_t {
	PROC_IN_SYNC_BYPASS = uint30(0);          // 
 }

 // For each bit, if 1, bypass the input synchronizer between that GPIO and the GPIO input register in the SIO. The input synchronizers should generally be unbypassed, to avoid injecting metastabilities into processors. If you're feeling brave, you can bypass to save two cycles of input latency. This register applies to GPIO 0...29.
 register PROC_IN_SYNC_BYPASS_t PROC_IN_SYNC_BYPASS at 0x4000400c;

 type PROC_IN_SYNC_BYPASS_HI_t {
	PROC_IN_SYNC_BYPASS_HI = uint6(0);           // 
 }

 // For each bit, if 1, bypass the input synchronizer between that GPIO and the GPIO input register in the SIO. The input synchronizers should generally be unbypassed, to avoid injecting metastabilities into processors. If you're feeling brave, you can bypass to save two cycles of input latency. This register applies to GPIO 30...35 (the QSPI IOs).
 register PROC_IN_SYNC_BYPASS_HI_t PROC_IN_SYNC_BYPASS_HI at 0x40004010;

 type DBGFORCE_t {
	PROC0_SWDO   = false;              // Observe the value of processor 0 SWDIO output.
	PROC0_SWDI   = false;              // Directly drive processor 0 SWDIO input, if PROC0_ATTACH is set
	PROC0_SWCLK  = false;              // Directly drive processor 0 SWCLK, if PROC0_ATTACH is set
	PROC0_ATTACH = false;              // Attach processor 0 debug port to syscfg controls, and disconnect it from external SWD pads.
	PROC1_SWDO   = false;              // Observe the value of processor 1 SWDIO output.
	PROC1_SWDI   = false;              // Directly drive processor 1 SWDIO input, if PROC1_ATTACH is set
	PROC1_SWCLK  = false;              // Directly drive processor 1 SWCLK, if PROC1_ATTACH is set
	PROC1_ATTACH = false;              // Attach processor 1 debug port to syscfg controls, and disconnect it from external SWD pads.
 }

 // Directly control the SWD debug port of either processor
 register DBGFORCE_t DBGFORCE at 0x40004014;

 type MEMPOWERDOWN_t {
	SRAM0 = false;              // 
	SRAM1 = false;              // 
	SRAM2 = false;              // 
	SRAM3 = false;              // 
	SRAM4 = false;              // 
	SRAM5 = false;              // 
	USB   = false;              // 
	ROM   = false;              // 
 }

 // Control power downs to memories. Set high to power down memories. Use with extreme caution
 register MEMPOWERDOWN_t MEMPOWERDOWN at 0x40004018;


/* Types and registers for XOSC 
  Controls the crystal oscillator
 */

 type XOSC_CTRL_t {
	FREQ_RANGE = uint12(0);          // Frequency range. An invalid setting will retain the previous value. The actual value being used can be read from STATUS_FREQ_RANGE. This resets to 0xAA0 and cannot be changed.
	ENABLE     = uint12(0);          // On power-up this field is initialised to DISABLE and the chip runs from the ROSC. If the chip has subsequently been programmed to run from the XOSC then DISABLE may lock-up the chip. If this is a concern then run the clk_ref from the ROSC and enable the clk_sys RESUS feature. The 12-bit code is intended to give some protection against accidental writes. An invalid setting will enable the oscillator.
 }

 // Crystal Oscillator Control
 register XOSC_CTRL_t XOSC_CTRL at 0x40024000;

 type XOSC_STATUS_t {
	FREQ_RANGE = uint2(0);           // The current frequency range setting, always reads 0
	_res1      = uint8(0);           // Reserved, 10 bits
	_res2      = uint2(0);           // 
	ENABLED    = false;              // Oscillator is enabled but not necessarily running and stable, resets to 0
	_res3      = uint8(0);           // Reserved, 11 bits
	_res4      = uint3(0);           // 
	BADWRITE   = false;              // An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE or DORMANT
	_res5      = uint6(0);           // Reserved, 6 bits
	STABLE     = false;              // Oscillator is running and stable
 }

 // Crystal Oscillator Status
 register XOSC_STATUS_t XOSC_STATUS at 0x40024004;

 type XOSC_DORMANT_t {
	DORMANT = uint32(0);          // This is used to save power by pausing the XOSC On power-up this field is initialised to WAKE An invalid write will also select WAKE Warning: stop the PLLs before selecting dormant mode Warning: setup the irq before selecting dormant mode
 }

 // Crystal Oscillator pause control
 register XOSC_DORMANT_t XOSC_DORMANT at 0x40024008;

 type STARTUP_t {
	DELAY = uint14(0);          // in multiples of 256*xtal_period. The reset value of 0xc4 corresponds to approx 50 000 cycles.
	_res1 = uint6(0);           // Reserved, 6 bits
	X4    = false;              // Multiplies the startup_delay by 4. This is of little value to the user given that the delay can be programmed directly.
 }

 // Controls the startup delay
 register STARTUP_t STARTUP at 0x4002400c;

 type XOSC_COUNT_t {
	COUNT = uint8(0);           // 
 }

 // A down counter running at the xosc frequency which counts to zero and stops. To start the counter write a non-zero value. Can be used for short software pauses when setting up time sensitive hardware.
 register XOSC_COUNT_t XOSC_COUNT at 0x4002401c;


/* Types and registers for PLL_SYS  */

 type PLL_SYS_CS_t {
	REFDIV = uint6(0);           // Divides the PLL input reference clock. Behaviour is undefined for div=0. PLL output will be unpredictable during refdiv changes, wait for lock=1 before using it.
	_res1  = uint2(0);           // Reserved, 2 bits
	BYPASS = false;              // Passes the reference clock to the output instead of the divided VCO. The VCO continues to run so the user can switch between the reference clock and the divided VCO but the output will glitch when doing so.
	_res2  = uint16(0);          // Reserved, 22 bits
	_res3  = uint6(0);           // 
	LOCK   = false;              // PLL is locked
 }

 // PLL_SYS Control and Status GENERAL CONSTRAINTS: Reference clock frequency min=5MHz, max=800MHz Feedback divider min=16, max=320 VCO frequency min=750MHz, max=1600MHz
 register PLL_SYS_CS_t PLL_SYS_PLL_SYS_CS at 0x40028000;

 type PWR_t {
	PD        = false;              // PLL powerdown To save power set high when PLL output not required.
	_res1     = false;              // Reserved, 1 bits
	DSMPD     = false;              // PLL DSM powerdown Nothing is achieved by setting this low.
	POSTDIVPD = false;              // PLL post divider powerdown To save power set high when PLL output not required or bypass=1.
	_res2     = false;              // Reserved, 1 bits
	VCOPD     = false;              // PLL VCO powerdown To save power set high when PLL output not required or bypass=1.
 }

 // PLL_SYS Controls the PLL power modes.
 register PWR_t PLL_SYS_PWR at 0x40028004;

 type FBDIV_INT_t {
	FBDIV_INT = uint12(0);          // see ctrl reg description for constraints
 }

 // PLL_SYS Feedback divisor (note: this PLL does not support fractional division)
 register FBDIV_INT_t PLL_SYS_FBDIV_INT at 0x40028008;

 type PRIM_t {
	_res1    = uint8(0);           // Reserved, 12 bits
	_res2    = uint4(0);           // 
	POSTDIV2 = uint3(0);           // divide by 1-7
	_res3    = false;              // Reserved, 1 bits
	POSTDIV1 = uint3(0);           // divide by 1-7
 }

 // PLL_SYS Controls the PLL post dividers for the primary output (note: this PLL does not have a secondary output) the primary output is driven from VCO divided by postdiv1*postdiv2
 register PRIM_t PLL_SYS_PRIM at 0x4002800c;


/* Types and registers for PLL_USB  */

 // PLL_USB Control and Status GENERAL CONSTRAINTS: Reference clock frequency min=5MHz, max=800MHz Feedback divider min=16, max=320 VCO frequency min=750MHz, max=1600MHz
 register PLL_SYS_CS_t PLL_USB_CS at 0x4002c000;

 // PLL_USB Controls the PLL power modes.
 register PWR_t PLL_USB_PWR at 0x4002c004;

 // PLL_USB Feedback divisor (note: this PLL does not support fractional division)
 register FBDIV_INT_t PLL_USB_FBDIV_INT at 0x4002c008;

 // PLL_USB Controls the PLL post dividers for the primary output (note: this PLL does not have a secondary output) the primary output is driven from VCO divided by postdiv1*postdiv2
 register PRIM_t PLL_USB_PRIM at 0x4002c00c;


/* Types and registers for UART0  */

 type UARTDR_t {
	DATA = uint8(0);           // Receive (read) data character. Transmit (write) data character.
	FE   = false;              // Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). In FIFO mode, this error is associated with the character at the top of the FIFO.
	PE   = false;              // Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. In FIFO mode, this error is associated with the character at the top of the FIFO.
	BE   = false;              // Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop bits). In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state), and the next valid start bit is received.
	OE   = false;              // Overrun error. This bit is set to 1 if data is received and the receive FIFO is already full. This is cleared to 0 once there is an empty space in the FIFO and a new character can be written to it.
 }

 // UART0 Data Register, UARTDR
 register UARTDR_t UART0_UARTDR at 0x40034000;

 type UARTRSR_t {
	FE = false;              // Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO.
	PE = false;              // Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO.
	BE = false;              // Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity, and stop bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received.
	OE = false;              // Overrun error. This bit is set to 1 if data is received and the FIFO is already full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must now read the data, to empty the FIFO.
 }

 // UART0 Receive Status Register/Error Clear Register, UARTRSR/UARTECR
 register UARTRSR_t UART0_UARTRSR at 0x40034004;

 type UARTFR_t {
	CTS  = false;              // Clear to send. This bit is the complement of the UART clear to send, nUARTCTS, modem status input. That is, the bit is 1 when nUARTCTS is LOW.
	DSR  = false;              // Data set ready. This bit is the complement of the UART data set ready, nUARTDSR, modem status input. That is, the bit is 1 when nUARTDSR is LOW.
	DCD  = false;              // Data carrier detect. This bit is the complement of the UART data carrier detect, nUARTDCD, modem status input. That is, the bit is 1 when nUARTDCD is LOW.
	BUSY = false;              // UART busy. If this bit is set to 1, the UART is busy transmitting data. This bit remains set until the complete byte, including all the stop bits, has been sent from the shift register. This bit is set as soon as the transmit FIFO becomes non-empty, regardless of whether the UART is enabled or not.
	RXFE = false;              // Receive FIFO empty. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is empty. If the FIFO is enabled, the RXFE bit is set when the receive FIFO is empty.
	TXFF = false;              // Transmit FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the transmit holding register is full. If the FIFO is enabled, the TXFF bit is set when the transmit FIFO is full.
	RXFF = false;              // Receive FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is full. If the FIFO is enabled, the RXFF bit is set when the receive FIFO is full.
	TXFE = false;              // Transmit FIFO empty. The meaning of this bit depends on the state of the FEN bit in the Line Control Register, UARTLCR_H. If the FIFO is disabled, this bit is set when the transmit holding register is empty. If the FIFO is enabled, the TXFE bit is set when the transmit FIFO is empty. This bit does not indicate if there is data in the transmit shift register.
	RI   = false;              // Ring indicator. This bit is the complement of the UART ring indicator, nUARTRI, modem status input. That is, the bit is 1 when nUARTRI is LOW.
 }

 // UART0 Flag Register, UARTFR
 register UARTFR_t UART0_UARTFR at 0x40034018;

 type UARTILPR_t {
	ILPDVSR = uint8(0);           // 8-bit low-power divisor value. These bits are cleared to 0 at reset.
 }

 // UART0 IrDA Low-Power Counter Register, UARTILPR
 register UARTILPR_t UART0_UARTILPR at 0x40034020;

 type UARTIBRD_t {
	BAUD_DIVINT = uint16(0);          // The integer baud rate divisor. These bits are cleared to 0 on reset.
 }

 // UART0 Integer Baud Rate Register, UARTIBRD
 register UARTIBRD_t UART0_UARTIBRD at 0x40034024;

 type UARTFBRD_t {
	BAUD_DIVFRAC = uint6(0);           // The fractional baud rate divisor. These bits are cleared to 0 on reset.
 }

 // UART0 Fractional Baud Rate Register, UARTFBRD
 register UARTFBRD_t UART0_UARTFBRD at 0x40034028;

 type UARTLCR_H_t {
	BRK  = false;              // Send break. If this bit is set to 1, a low-level is continually output on the UARTTXD output, after completing transmission of the current character. For the proper execution of the break command, the software must set this bit for at least two complete frames. For normal use, this bit must be cleared to 0.
	PEN  = false;              // Parity enable: 0 = parity is disabled and no parity bit added to the data frame 1 = parity checking and generation is enabled.
	EPS  = false;              // Even parity select. Controls the type of parity the UART uses during transmission and reception: 0 = odd parity. The UART generates or checks for an odd number of 1s in the data and parity bits. 1 = even parity. The UART generates or checks for an even number of 1s in the data and parity bits. This bit has no effect when the PEN bit disables parity checking and generation.
	STP2 = false;              // Two stop bits select. If this bit is set to 1, two stop bits are transmitted at the end of the frame. The receive logic does not check for two stop bits being received.
	FEN  = false;              // Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs become 1-byte-deep holding registers 1 = transmit and receive FIFO buffers are enabled (FIFO mode).
	WLEN = uint2(0);           // Word length. These bits indicate the number of data bits transmitted or received in a frame as follows: b11 = 8 bits b10 = 7 bits b01 = 6 bits b00 = 5 bits.
	SPS  = false;              // Stick parity select. 0 = stick parity is disabled 1 = either: * if the EPS bit is 0 then the parity bit is transmitted and checked as a 1 * if the EPS bit is 1 then the parity bit is transmitted and checked as a 0. This bit has no effect when the PEN bit disables parity checking and generation.
 }

 // UART0 Line Control Register, UARTLCR_H
 register UARTLCR_H_t UART0_UARTLCR_H at 0x4003402c;

 type UARTCR_t {
	UARTEN = false;              // UART enable: 0 = UART is disabled. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. 1 = the UART is enabled. Data transmission and reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit.
	SIREN  = false;              // SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no light pulse generated), and signal transitions on SIRIN have no effect. 1 = IrDA SIR ENDEC is enabled. Data is transmitted and received on nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal transitions on UARTRXD or modem status inputs have no effect. This bit has no effect if the UARTEN bit disables the UART.
	SIRLP  = false;              // SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If this bit is cleared to 0, low-level bits are transmitted as an active high pulse with a width of 3 / 16th of the bit period. If this bit is set to 1, low-level bits are transmitted with a pulse width that is 3 times the period of the IrLPBaud16 input signal, regardless of the selected bit rate. Setting this bit uses less power, but might reduce transmission distances.
	_res1  = uint4(0);           // Reserved, 4 bits
	LBE    = false;              // Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1 and the SIRTEST bit in the Test Control Register, UARTTCR is set to 1, then the nSIROUT path is inverted, and fed through to the SIRIN path. The SIRTEST bit in the test register must be set to 1 to override the normal half-duplex SIR operation. This must be the requirement for accessing the test registers during normal operation, and SIRTEST must be cleared to 0 when loopback testing is finished. This feature reduces the amount of external coupling required during system test. If this bit is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path is fed through to the UARTRXD path. In either SIR mode or UART mode, when this bit is set, the modem outputs are also fed through to the modem inputs. This bit is cleared to 0 on reset, to disable loopback.
	TXE    = false;              // Transmit enable. If this bit is set to 1, the transmit section of the UART is enabled. Data transmission occurs for either UART signals, or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of transmission, it completes the current character before stopping.
	RXE    = false;              // Receive enable. If this bit is set to 1, the receive section of the UART is enabled. Data reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of reception, it completes the current character before stopping.
	DTR    = false;              // Data transmit ready. This bit is the complement of the UART data transmit ready, nUARTDTR, modem status output. That is, when the bit is programmed to a 1 then nUARTDTR is LOW.
	RTS    = false;              // Request to send. This bit is the complement of the UART request to send, nUARTRTS, modem status output. That is, when the bit is programmed to a 1 then nUARTRTS is LOW.
	OUT1   = false;              // This bit is the complement of the UART Out1 (nUARTOut1) modem status output. That is, when the bit is programmed to a 1 the output is 0. For DTE this can be used as Data Carrier Detect (DCD).
	OUT2   = false;              // This bit is the complement of the UART Out2 (nUARTOut2) modem status output. That is, when the bit is programmed to a 1, the output is 0. For DTE this can be used as Ring Indicator (RI).
	RTSEN  = false;              // RTS hardware flow control enable. If this bit is set to 1, RTS hardware flow control is enabled. Data is only requested when there is space in the receive FIFO for it to be received.
	CTSEN  = false;              // CTS hardware flow control enable. If this bit is set to 1, CTS hardware flow control is enabled. Data is only transmitted when the nUARTCTS signal is asserted.
 }

 // UART0 Control Register, UARTCR
 register UARTCR_t UART0_UARTCR at 0x40034030;

 type UARTIFLS_t {
	TXIFLSEL = uint3(0);           // Transmit interrupt FIFO level select. The trigger points for the transmit interrupt are as follows: b000 = Transmit FIFO becomes <= 1 / 8 full b001 = Transmit FIFO becomes <= 1 / 4 full b010 = Transmit FIFO becomes <= 1 / 2 full b011 = Transmit FIFO becomes <= 3 / 4 full b100 = Transmit FIFO becomes <= 7 / 8 full b101-b111 = reserved.
	RXIFLSEL = uint3(0);           // Receive interrupt FIFO level select. The trigger points for the receive interrupt are as follows: b000 = Receive FIFO becomes >= 1 / 8 full b001 = Receive FIFO becomes >= 1 / 4 full b010 = Receive FIFO becomes >= 1 / 2 full b011 = Receive FIFO becomes >= 3 / 4 full b100 = Receive FIFO becomes >= 7 / 8 full b101-b111 = reserved.
 }

 // UART0 Interrupt FIFO Level Select Register, UARTIFLS
 register UARTIFLS_t UART0_UARTIFLS at 0x40034034;

 type UARTIMSC_t {
	RIMIM  = false;              // nUARTRI modem interrupt mask. A read returns the current mask for the UARTRIINTR interrupt. On a write of 1, the mask of the UARTRIINTR interrupt is set. A write of 0 clears the mask.
	CTSMIM = false;              // nUARTCTS modem interrupt mask. A read returns the current mask for the UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR interrupt is set. A write of 0 clears the mask.
	DCDMIM = false;              // nUARTDCD modem interrupt mask. A read returns the current mask for the UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR interrupt is set. A write of 0 clears the mask.
	DSRMIM = false;              // nUARTDSR modem interrupt mask. A read returns the current mask for the UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR interrupt is set. A write of 0 clears the mask.
	RXIM   = false;              // Receive interrupt mask. A read returns the current mask for the UARTRXINTR interrupt. On a write of 1, the mask of the UARTRXINTR interrupt is set. A write of 0 clears the mask.
	TXIM   = false;              // Transmit interrupt mask. A read returns the current mask for the UARTTXINTR interrupt. On a write of 1, the mask of the UARTTXINTR interrupt is set. A write of 0 clears the mask.
	RTIM   = false;              // Receive timeout interrupt mask. A read returns the current mask for the UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR interrupt is set. A write of 0 clears the mask.
	FEIM   = false;              // Framing error interrupt mask. A read returns the current mask for the UARTFEINTR interrupt. On a write of 1, the mask of the UARTFEINTR interrupt is set. A write of 0 clears the mask.
	PEIM   = false;              // Parity error interrupt mask. A read returns the current mask for the UARTPEINTR interrupt. On a write of 1, the mask of the UARTPEINTR interrupt is set. A write of 0 clears the mask.
	BEIM   = false;              // Break error interrupt mask. A read returns the current mask for the UARTBEINTR interrupt. On a write of 1, the mask of the UARTBEINTR interrupt is set. A write of 0 clears the mask.
	OEIM   = false;              // Overrun error interrupt mask. A read returns the current mask for the UARTOEINTR interrupt. On a write of 1, the mask of the UARTOEINTR interrupt is set. A write of 0 clears the mask.
 }

 // UART0 Interrupt Mask Set/Clear Register, UARTIMSC
 register UARTIMSC_t UART0_UARTIMSC at 0x40034038;

 type UARTRIS_t {
	RIRMIS  = false;              // nUARTRI modem interrupt status. Returns the raw interrupt state of the UARTRIINTR interrupt.
	CTSRMIS = false;              // nUARTCTS modem interrupt status. Returns the raw interrupt state of the UARTCTSINTR interrupt.
	DCDRMIS = false;              // nUARTDCD modem interrupt status. Returns the raw interrupt state of the UARTDCDINTR interrupt.
	DSRRMIS = false;              // nUARTDSR modem interrupt status. Returns the raw interrupt state of the UARTDSRINTR interrupt.
	RXRIS   = false;              // Receive interrupt status. Returns the raw interrupt state of the UARTRXINTR interrupt.
	TXRIS   = false;              // Transmit interrupt status. Returns the raw interrupt state of the UARTTXINTR interrupt.
	RTRIS   = false;              // Receive timeout interrupt status. Returns the raw interrupt state of the UARTRTINTR interrupt. a
	FERIS   = false;              // Framing error interrupt status. Returns the raw interrupt state of the UARTFEINTR interrupt.
	PERIS   = false;              // Parity error interrupt status. Returns the raw interrupt state of the UARTPEINTR interrupt.
	BERIS   = false;              // Break error interrupt status. Returns the raw interrupt state of the UARTBEINTR interrupt.
	OERIS   = false;              // Overrun error interrupt status. Returns the raw interrupt state of the UARTOEINTR interrupt.
 }

 // UART0 Raw Interrupt Status Register, UARTRIS
 register UARTRIS_t UART0_UARTRIS at 0x4003403c;

 type UARTMIS_t {
	RIMMIS  = false;              // nUARTRI modem masked interrupt status. Returns the masked interrupt state of the UARTRIINTR interrupt.
	CTSMMIS = false;              // nUARTCTS modem masked interrupt status. Returns the masked interrupt state of the UARTCTSINTR interrupt.
	DCDMMIS = false;              // nUARTDCD modem masked interrupt status. Returns the masked interrupt state of the UARTDCDINTR interrupt.
	DSRMMIS = false;              // nUARTDSR modem masked interrupt status. Returns the masked interrupt state of the UARTDSRINTR interrupt.
	RXMIS   = false;              // Receive masked interrupt status. Returns the masked interrupt state of the UARTRXINTR interrupt.
	TXMIS   = false;              // Transmit masked interrupt status. Returns the masked interrupt state of the UARTTXINTR interrupt.
	RTMIS   = false;              // Receive timeout masked interrupt status. Returns the masked interrupt state of the UARTRTINTR interrupt.
	FEMIS   = false;              // Framing error masked interrupt status. Returns the masked interrupt state of the UARTFEINTR interrupt.
	PEMIS   = false;              // Parity error masked interrupt status. Returns the masked interrupt state of the UARTPEINTR interrupt.
	BEMIS   = false;              // Break error masked interrupt status. Returns the masked interrupt state of the UARTBEINTR interrupt.
	OEMIS   = false;              // Overrun error masked interrupt status. Returns the masked interrupt state of the UARTOEINTR interrupt.
 }

 // UART0 Masked Interrupt Status Register, UARTMIS
 register UARTMIS_t UART0_UARTMIS at 0x40034040;

 type UARTICR_t {
	RIMIC  = false;              // nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt.
	CTSMIC = false;              // nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt.
	DCDMIC = false;              // nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt.
	DSRMIC = false;              // nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt.
	RXIC   = false;              // Receive interrupt clear. Clears the UARTRXINTR interrupt.
	TXIC   = false;              // Transmit interrupt clear. Clears the UARTTXINTR interrupt.
	RTIC   = false;              // Receive timeout interrupt clear. Clears the UARTRTINTR interrupt.
	FEIC   = false;              // Framing error interrupt clear. Clears the UARTFEINTR interrupt.
	PEIC   = false;              // Parity error interrupt clear. Clears the UARTPEINTR interrupt.
	BEIC   = false;              // Break error interrupt clear. Clears the UARTBEINTR interrupt.
	OEIC   = false;              // Overrun error interrupt clear. Clears the UARTOEINTR interrupt.
 }

 // UART0 Interrupt Clear Register, UARTICR
 register UARTICR_t UART0_UARTICR at 0x40034044;

 type UARTDMACR_t {
	RXDMAE   = false;              // Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is enabled.
	TXDMAE   = false;              // Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.
	DMAONERR = false;              // DMA on error. If this bit is set to 1, the DMA receive request outputs, UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error interrupt is asserted.
 }

 // UART0 DMA Control Register, UARTDMACR
 register UARTDMACR_t UART0_UARTDMACR at 0x40034048;

 type UARTPERIPHID0_t {
	PARTNUMBER0 = uint8(0);           // These bits read back as 0x11
 }

 // UART0 UARTPeriphID0 Register
 register UARTPERIPHID0_t UART0_UARTPERIPHID0 at 0x40034fe0;

 type UARTPERIPHID1_t {
	PARTNUMBER1 = uint4(0);           // These bits read back as 0x0
	DESIGNER0   = uint4(0);           // These bits read back as 0x1
 }

 // UART0 UARTPeriphID1 Register
 register UARTPERIPHID1_t UART0_UARTPERIPHID1 at 0x40034fe4;

 type UARTPERIPHID2_t {
	DESIGNER1 = uint4(0);           // These bits read back as 0x4
	REVISION  = uint4(0);           // This field depends on the revision of the UART: r1p0 0x0 r1p1 0x1 r1p3 0x2 r1p4 0x2 r1p5 0x3
 }

 // UART0 UARTPeriphID2 Register
 register UARTPERIPHID2_t UART0_UARTPERIPHID2 at 0x40034fe8;

 type UARTPERIPHID3_t {
	CONFIGURATION = uint8(0);           // These bits read back as 0x00
 }

 // UART0 UARTPeriphID3 Register
 register UARTPERIPHID3_t UART0_UARTPERIPHID3 at 0x40034fec;

 type UARTPCELLID0_t {
	UARTPCELLID0 = uint8(0);           // These bits read back as 0x0D
 }

 // UART0 UARTPCellID0 Register
 register UARTPCELLID0_t UART0_UARTPCELLID0 at 0x40034ff0;

 type UARTPCELLID1_t {
	UARTPCELLID1 = uint8(0);           // These bits read back as 0xF0
 }

 // UART0 UARTPCellID1 Register
 register UARTPCELLID1_t UART0_UARTPCELLID1 at 0x40034ff4;

 type UARTPCELLID2_t {
	UARTPCELLID2 = uint8(0);           // These bits read back as 0x05
 }

 // UART0 UARTPCellID2 Register
 register UARTPCELLID2_t UART0_UARTPCELLID2 at 0x40034ff8;

 type UARTPCELLID3_t {
	UARTPCELLID3 = uint8(0);           // These bits read back as 0xB1
 }

 // UART0 UARTPCellID3 Register
 register UARTPCELLID3_t UART0_UARTPCELLID3 at 0x40034ffc;


/* Types and registers for UART1  */

 // UART1 Data Register, UARTDR
 register UARTDR_t UART1_UARTDR at 0x40038000;

 // UART1 Receive Status Register/Error Clear Register, UARTRSR/UARTECR
 register UARTRSR_t UART1_UARTRSR at 0x40038004;

 // UART1 Flag Register, UARTFR
 register UARTFR_t UART1_UARTFR at 0x40038018;

 // UART1 IrDA Low-Power Counter Register, UARTILPR
 register UARTILPR_t UART1_UARTILPR at 0x40038020;

 // UART1 Integer Baud Rate Register, UARTIBRD
 register UARTIBRD_t UART1_UARTIBRD at 0x40038024;

 // UART1 Fractional Baud Rate Register, UARTFBRD
 register UARTFBRD_t UART1_UARTFBRD at 0x40038028;

 // UART1 Line Control Register, UARTLCR_H
 register UARTLCR_H_t UART1_UARTLCR_H at 0x4003802c;

 // UART1 Control Register, UARTCR
 register UARTCR_t UART1_UARTCR at 0x40038030;

 // UART1 Interrupt FIFO Level Select Register, UARTIFLS
 register UARTIFLS_t UART1_UARTIFLS at 0x40038034;

 // UART1 Interrupt Mask Set/Clear Register, UARTIMSC
 register UARTIMSC_t UART1_UARTIMSC at 0x40038038;

 // UART1 Raw Interrupt Status Register, UARTRIS
 register UARTRIS_t UART1_UARTRIS at 0x4003803c;

 // UART1 Masked Interrupt Status Register, UARTMIS
 register UARTMIS_t UART1_UARTMIS at 0x40038040;

 // UART1 Interrupt Clear Register, UARTICR
 register UARTICR_t UART1_UARTICR at 0x40038044;

 // UART1 DMA Control Register, UARTDMACR
 register UARTDMACR_t UART1_UARTDMACR at 0x40038048;

 // UART1 UARTPeriphID0 Register
 register UARTPERIPHID0_t UART1_UARTPERIPHID0 at 0x40038fe0;

 // UART1 UARTPeriphID1 Register
 register UARTPERIPHID1_t UART1_UARTPERIPHID1 at 0x40038fe4;

 // UART1 UARTPeriphID2 Register
 register UARTPERIPHID2_t UART1_UARTPERIPHID2 at 0x40038fe8;

 // UART1 UARTPeriphID3 Register
 register UARTPERIPHID3_t UART1_UARTPERIPHID3 at 0x40038fec;

 // UART1 UARTPCellID0 Register
 register UARTPCELLID0_t UART1_UARTPCELLID0 at 0x40038ff0;

 // UART1 UARTPCellID1 Register
 register UARTPCELLID1_t UART1_UARTPCELLID1 at 0x40038ff4;

 // UART1 UARTPCellID2 Register
 register UARTPCELLID2_t UART1_UARTPCELLID2 at 0x40038ff8;

 // UART1 UARTPCellID3 Register
 register UARTPCELLID3_t UART1_UARTPCELLID3 at 0x40038ffc;


/* Types and registers for ROSC  */

 type ROSC_CTRL_t {
	FREQ_RANGE = uint12(0);          // Controls the number of delay stages in the ROSC ring LOW uses stages 0 to 7 MEDIUM uses stages 2 to 7 HIGH uses stages 4 to 7 TOOHIGH uses stages 6 to 7 and should not be used because its frequency exceeds design specifications The clock output will not glitch when changing the range up one step at a time The clock output will glitch when changing the range down Note: the values here are gray coded which is why HIGH comes before TOOHIGH
	ENABLE     = uint12(0);          // On power-up this field is initialised to ENABLE The system clock must be switched to another source before setting this field to DISABLE otherwise the chip will lock up The 12-bit code is intended to give some protection against accidental writes. An invalid setting will enable the oscillator.
 }

 // Ring Oscillator control
 register ROSC_CTRL_t ROSC_CTRL at 0x40060000;

 type FREQA_t {
	DS0    = uint3(0);           // Stage 0 drive strength
	_res1  = false;              // Reserved, 1 bits
	DS1    = uint3(0);           // Stage 1 drive strength
	_res2  = false;              // Reserved, 1 bits
	DS2    = uint3(0);           // Stage 2 drive strength
	_res3  = false;              // Reserved, 1 bits
	DS3    = uint3(0);           // Stage 3 drive strength
	_res4  = false;              // Reserved, 1 bits
	PASSWD = uint16(0);          // Set to 0x9696 to apply the settings Any other value in this field will set all drive strengths to 0
 }

 // The FREQA & FREQB registers control the frequency by controlling the drive strength of each stage The drive strength has 4 levels determined by the number of bits set Increasing the number of bits set increases the drive strength and increases the oscillation frequency 0 bits set is the default drive strength 1 bit set doubles the drive strength 2 bits set triples drive strength 3 bits set quadruples drive strength
 register FREQA_t FREQA at 0x40060004;

 type FREQB_t {
	DS4    = uint3(0);           // Stage 4 drive strength
	_res1  = false;              // Reserved, 1 bits
	DS5    = uint3(0);           // Stage 5 drive strength
	_res2  = false;              // Reserved, 1 bits
	DS6    = uint3(0);           // Stage 6 drive strength
	_res3  = false;              // Reserved, 1 bits
	DS7    = uint3(0);           // Stage 7 drive strength
	_res4  = false;              // Reserved, 1 bits
	PASSWD = uint16(0);          // Set to 0x9696 to apply the settings Any other value in this field will set all drive strengths to 0
 }

 // For a detailed description see freqa register
 register FREQB_t FREQB at 0x40060008;

 type ROSC_DORMANT_t {
	DORMANT = uint32(0);          // This is used to save power by pausing the ROSC On power-up this field is initialised to WAKE An invalid write will also select WAKE Warning: setup the irq before selecting dormant mode
 }

 // Ring Oscillator pause control
 register ROSC_DORMANT_t ROSC_DORMANT at 0x4006000c;

 type ROSC_DIV_t {
	DIV = uint12(0);          // set to 0xaa0 + div where div = 0 divides by 32 div = 1-31 divides by div any other value sets div=31 this register resets to div=16
 }

 // Controls the output divider
 register ROSC_DIV_t ROSC_DIV at 0x40060010;

 type PHASE_t {
	SHIFT  = uint2(0);           // phase shift the phase-shifted output by SHIFT input clocks this can be changed on-the-fly must be set to 0 before setting div=1
	FLIP   = false;              // invert the phase-shifted output this is ignored when div=1
	ENABLE = false;              // enable the phase-shifted output this can be changed on-the-fly
	PASSWD = uint8(0);           // set to 0xaa any other value enables the output with shift=0
 }

 // Controls the phase shifted output
 register PHASE_t PHASE at 0x40060014;

 type ROSC_STATUS_t {
	_res1       = uint8(0);           // Reserved, 12 bits
	_res2       = uint4(0);           // 
	ENABLED     = false;              // Oscillator is enabled but not necessarily running and stable this resets to 0 but transitions to 1 during chip startup
	_res3       = uint3(0);           // Reserved, 3 bits
	DIV_RUNNING = false;              // post-divider is running this resets to 0 but transitions to 1 during chip startup
	_res4       = uint7(0);           // Reserved, 7 bits
	BADWRITE    = false;              // An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE or FREQA or FREQB or DIV or PHASE or DORMANT
	_res5       = uint6(0);           // Reserved, 6 bits
	STABLE      = false;              // Oscillator is running and stable
 }

 // Ring Oscillator Status
 register ROSC_STATUS_t ROSC_STATUS at 0x40060018;

 type RANDOMBIT_t {
	RANDOMBIT = false;              // 
 }

 // This just reads the state of the oscillator output so randomness is compromised if the ring oscillator is stopped or run at a harmonic of the bus frequency
 register RANDOMBIT_t RANDOMBIT at 0x4006001c;

 type ROSC_COUNT_t {
	COUNT = uint8(0);           // 
 }

 // A down counter running at the ROSC frequency which counts to zero and stops. To start the counter write a non-zero value. Can be used for short software pauses when setting up time sensitive hardware.
 register ROSC_COUNT_t ROSC_COUNT at 0x40060020;


/* Types and registers for WATCHDOG  */

 type WATCHDOG_CTRL_t {
	TIME       = uint24(0);          // Indicates the number of ticks / 2 (see errata RP2040-E1) before a watchdog reset will be triggered
	PAUSE_JTAG = false;              // Pause the watchdog timer when JTAG is accessing the bus fabric
	PAUSE_DBG0 = false;              // Pause the watchdog timer when processor 0 is in debug mode
	PAUSE_DBG1 = false;              // Pause the watchdog timer when processor 1 is in debug mode
	_res1      = uint3(0);           // Reserved, 3 bits
	ENABLE     = false;              // When not enabled the watchdog timer is paused
	TRIGGER    = false;              // Trigger a watchdog reset
 }

 // Watchdog control The rst_wdsel register determines which subsystems are reset when the watchdog is triggered. The watchdog can be triggered in software.
 register WATCHDOG_CTRL_t WATCHDOG_CTRL at 0x40058000;

 type LOAD_t {
	LOAD = uint24(0);          // 
 }

 // Load the watchdog timer. The maximum setting is 0xffffff which corresponds to 0xffffff / 2 ticks before triggering a watchdog reset (see errata RP2040-E1).
 register LOAD_t LOAD at 0x40058004;

 type REASON_t {
	TIMER = false;              // 
	FORCE = false;              // 
 }

 // Logs the reason for the last reset. Both bits are zero for the case of a hardware reset.
 register REASON_t REASON at 0x40058008;

 type SCRATCH0_t {
	SCRATCH0 = uint32(0);          // 
 }

 // Scratch register. Information persists through soft reset of the chip.
 register SCRATCH0_t SCRATCH0 at 0x4005800c;

 type SCRATCH1_t {
	SCRATCH1 = uint32(0);          // 
 }

 // Scratch register. Information persists through soft reset of the chip.
 register SCRATCH1_t SCRATCH1 at 0x40058010;

 type SCRATCH2_t {
	SCRATCH2 = uint32(0);          // 
 }

 // Scratch register. Information persists through soft reset of the chip.
 register SCRATCH2_t SCRATCH2 at 0x40058014;

 type SCRATCH3_t {
	SCRATCH3 = uint32(0);          // 
 }

 // Scratch register. Information persists through soft reset of the chip.
 register SCRATCH3_t SCRATCH3 at 0x40058018;

 type SCRATCH4_t {
	SCRATCH4 = uint32(0);          // 
 }

 // Scratch register. Information persists through soft reset of the chip.
 register SCRATCH4_t SCRATCH4 at 0x4005801c;

 type SCRATCH5_t {
	SCRATCH5 = uint32(0);          // 
 }

 // Scratch register. Information persists through soft reset of the chip.
 register SCRATCH5_t SCRATCH5 at 0x40058020;

 type SCRATCH6_t {
	SCRATCH6 = uint32(0);          // 
 }

 // Scratch register. Information persists through soft reset of the chip.
 register SCRATCH6_t SCRATCH6 at 0x40058024;

 type SCRATCH7_t {
	SCRATCH7 = uint32(0);          // 
 }

 // Scratch register. Information persists through soft reset of the chip.
 register SCRATCH7_t SCRATCH7 at 0x40058028;

 type TICK_t {
	CYCLES  = uint9(0);           // Total number of clk_tick cycles before the next tick.
	ENABLE  = false;              // start / stop tick generation
	RUNNING = false;              // Is the tick generator running?
	COUNT   = uint9(0);           // Count down timer: the remaining number clk_tick cycles before the next tick is generated.
 }

 // Controls the tick generator
 register TICK_t TICK at 0x4005802c;


/* Types and registers for DMA 
  DMA with separate read and write masters
 */

 type CH0_READ_ADDR_t {
	CH0_READ_ADDR = uint32(0);          // This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
 }

 // DMA Channel 0 Read Address pointer
 register CH0_READ_ADDR_t CH0_READ_ADDR at 0x50000000;

 type CH0_WRITE_ADDR_t {
	CH0_WRITE_ADDR = uint32(0);          // This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
 }

 // DMA Channel 0 Write Address pointer
 register CH0_WRITE_ADDR_t CH0_WRITE_ADDR at 0x50000004;

 type CH0_TRANS_COUNT_t {
	CH0_TRANS_COUNT = uint32(0);          // Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
 }

 // DMA Channel 0 Transfer Count
 register CH0_TRANS_COUNT_t CH0_TRANS_COUNT at 0x50000008;

 type CH0_CTRL_TRIG_t {
	EN            = false;              // DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY = false;              // HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE     = uint2(0);           // Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	INCR_READ     = false;              // If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_WRITE    = false;              // If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	RING_SIZE     = uint4(0);           // Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_SEL      = false;              // Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO      = uint4(0);           // When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
	TREQ_SEL      = uint6(0);           // Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	IRQ_QUIET     = false;              // In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP         = false;              // Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN      = false;              // If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY          = false;              // This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	_res1         = uint4(0);           // Reserved, 4 bits
	WRITE_ERROR   = false;              // If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR    = false;              // If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR     = false;              // Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
 }

 // DMA Channel 0 Control and Status
 register CH0_CTRL_TRIG_t CH0_CTRL_TRIG at 0x5000000c;

 type CH0_AL1_CTRL_t {
	CH0_AL1_CTRL = uint32(0);          // 
 }

 // Alias for channel 0 CTRL register
 register CH0_AL1_CTRL_t CH0_AL1_CTRL at 0x50000010;

 type CH0_AL1_READ_ADDR_t {
	CH0_AL1_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 0 READ_ADDR register
 register CH0_AL1_READ_ADDR_t CH0_AL1_READ_ADDR at 0x50000014;

 type CH0_AL1_WRITE_ADDR_t {
	CH0_AL1_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 0 WRITE_ADDR register
 register CH0_AL1_WRITE_ADDR_t CH0_AL1_WRITE_ADDR at 0x50000018;

 type CH0_AL1_TRANS_COUNT_TRIG_t {
	CH0_AL1_TRANS_COUNT_TRIG = uint32(0);          // 
 }

 // Alias for channel 0 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH0_AL1_TRANS_COUNT_TRIG_t CH0_AL1_TRANS_COUNT_TRIG at 0x5000001c;

 type CH0_AL2_CTRL_t {
	CH0_AL2_CTRL = uint32(0);          // 
 }

 // Alias for channel 0 CTRL register
 register CH0_AL2_CTRL_t CH0_AL2_CTRL at 0x50000020;

 type CH0_AL2_TRANS_COUNT_t {
	CH0_AL2_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 0 TRANS_COUNT register
 register CH0_AL2_TRANS_COUNT_t CH0_AL2_TRANS_COUNT at 0x50000024;

 type CH0_AL2_READ_ADDR_t {
	CH0_AL2_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 0 READ_ADDR register
 register CH0_AL2_READ_ADDR_t CH0_AL2_READ_ADDR at 0x50000028;

 type CH0_AL2_WRITE_ADDR_TRIG_t {
	CH0_AL2_WRITE_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 0 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH0_AL2_WRITE_ADDR_TRIG_t CH0_AL2_WRITE_ADDR_TRIG at 0x5000002c;

 type CH0_AL3_CTRL_t {
	CH0_AL3_CTRL = uint32(0);          // 
 }

 // Alias for channel 0 CTRL register
 register CH0_AL3_CTRL_t CH0_AL3_CTRL at 0x50000030;

 type CH0_AL3_WRITE_ADDR_t {
	CH0_AL3_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 0 WRITE_ADDR register
 register CH0_AL3_WRITE_ADDR_t CH0_AL3_WRITE_ADDR at 0x50000034;

 type CH0_AL3_TRANS_COUNT_t {
	CH0_AL3_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 0 TRANS_COUNT register
 register CH0_AL3_TRANS_COUNT_t CH0_AL3_TRANS_COUNT at 0x50000038;

 type CH0_AL3_READ_ADDR_TRIG_t {
	CH0_AL3_READ_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 0 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH0_AL3_READ_ADDR_TRIG_t CH0_AL3_READ_ADDR_TRIG at 0x5000003c;

 type CH1_READ_ADDR_t {
	CH1_READ_ADDR = uint32(0);          // This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
 }

 // DMA Channel 1 Read Address pointer
 register CH1_READ_ADDR_t CH1_READ_ADDR at 0x50000040;

 type CH1_WRITE_ADDR_t {
	CH1_WRITE_ADDR = uint32(0);          // This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
 }

 // DMA Channel 1 Write Address pointer
 register CH1_WRITE_ADDR_t CH1_WRITE_ADDR at 0x50000044;

 type CH1_TRANS_COUNT_t {
	CH1_TRANS_COUNT = uint32(0);          // Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
 }

 // DMA Channel 1 Transfer Count
 register CH1_TRANS_COUNT_t CH1_TRANS_COUNT at 0x50000048;

 type CH1_CTRL_TRIG_t {
	EN            = false;              // DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY = false;              // HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE     = uint2(0);           // Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	INCR_READ     = false;              // If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_WRITE    = false;              // If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	RING_SIZE     = uint4(0);           // Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_SEL      = false;              // Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO      = uint4(0);           // When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
	TREQ_SEL      = uint6(0);           // Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	IRQ_QUIET     = false;              // In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP         = false;              // Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN      = false;              // If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY          = false;              // This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	_res1         = uint4(0);           // Reserved, 4 bits
	WRITE_ERROR   = false;              // If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR    = false;              // If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR     = false;              // Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
 }

 // DMA Channel 1 Control and Status
 register CH1_CTRL_TRIG_t CH1_CTRL_TRIG at 0x5000004c;

 type CH1_AL1_CTRL_t {
	CH1_AL1_CTRL = uint32(0);          // 
 }

 // Alias for channel 1 CTRL register
 register CH1_AL1_CTRL_t CH1_AL1_CTRL at 0x50000050;

 type CH1_AL1_READ_ADDR_t {
	CH1_AL1_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 1 READ_ADDR register
 register CH1_AL1_READ_ADDR_t CH1_AL1_READ_ADDR at 0x50000054;

 type CH1_AL1_WRITE_ADDR_t {
	CH1_AL1_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 1 WRITE_ADDR register
 register CH1_AL1_WRITE_ADDR_t CH1_AL1_WRITE_ADDR at 0x50000058;

 type CH1_AL1_TRANS_COUNT_TRIG_t {
	CH1_AL1_TRANS_COUNT_TRIG = uint32(0);          // 
 }

 // Alias for channel 1 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH1_AL1_TRANS_COUNT_TRIG_t CH1_AL1_TRANS_COUNT_TRIG at 0x5000005c;

 type CH1_AL2_CTRL_t {
	CH1_AL2_CTRL = uint32(0);          // 
 }

 // Alias for channel 1 CTRL register
 register CH1_AL2_CTRL_t CH1_AL2_CTRL at 0x50000060;

 type CH1_AL2_TRANS_COUNT_t {
	CH1_AL2_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 1 TRANS_COUNT register
 register CH1_AL2_TRANS_COUNT_t CH1_AL2_TRANS_COUNT at 0x50000064;

 type CH1_AL2_READ_ADDR_t {
	CH1_AL2_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 1 READ_ADDR register
 register CH1_AL2_READ_ADDR_t CH1_AL2_READ_ADDR at 0x50000068;

 type CH1_AL2_WRITE_ADDR_TRIG_t {
	CH1_AL2_WRITE_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 1 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH1_AL2_WRITE_ADDR_TRIG_t CH1_AL2_WRITE_ADDR_TRIG at 0x5000006c;

 type CH1_AL3_CTRL_t {
	CH1_AL3_CTRL = uint32(0);          // 
 }

 // Alias for channel 1 CTRL register
 register CH1_AL3_CTRL_t CH1_AL3_CTRL at 0x50000070;

 type CH1_AL3_WRITE_ADDR_t {
	CH1_AL3_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 1 WRITE_ADDR register
 register CH1_AL3_WRITE_ADDR_t CH1_AL3_WRITE_ADDR at 0x50000074;

 type CH1_AL3_TRANS_COUNT_t {
	CH1_AL3_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 1 TRANS_COUNT register
 register CH1_AL3_TRANS_COUNT_t CH1_AL3_TRANS_COUNT at 0x50000078;

 type CH1_AL3_READ_ADDR_TRIG_t {
	CH1_AL3_READ_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 1 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH1_AL3_READ_ADDR_TRIG_t CH1_AL3_READ_ADDR_TRIG at 0x5000007c;

 type CH2_READ_ADDR_t {
	CH2_READ_ADDR = uint32(0);          // This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
 }

 // DMA Channel 2 Read Address pointer
 register CH2_READ_ADDR_t CH2_READ_ADDR at 0x50000080;

 type CH2_WRITE_ADDR_t {
	CH2_WRITE_ADDR = uint32(0);          // This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
 }

 // DMA Channel 2 Write Address pointer
 register CH2_WRITE_ADDR_t CH2_WRITE_ADDR at 0x50000084;

 type CH2_TRANS_COUNT_t {
	CH2_TRANS_COUNT = uint32(0);          // Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
 }

 // DMA Channel 2 Transfer Count
 register CH2_TRANS_COUNT_t CH2_TRANS_COUNT at 0x50000088;

 type CH2_CTRL_TRIG_t {
	EN            = false;              // DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY = false;              // HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE     = uint2(0);           // Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	INCR_READ     = false;              // If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_WRITE    = false;              // If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	RING_SIZE     = uint4(0);           // Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_SEL      = false;              // Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO      = uint4(0);           // When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
	TREQ_SEL      = uint6(0);           // Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	IRQ_QUIET     = false;              // In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP         = false;              // Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN      = false;              // If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY          = false;              // This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	_res1         = uint4(0);           // Reserved, 4 bits
	WRITE_ERROR   = false;              // If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR    = false;              // If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR     = false;              // Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
 }

 // DMA Channel 2 Control and Status
 register CH2_CTRL_TRIG_t CH2_CTRL_TRIG at 0x5000008c;

 type CH2_AL1_CTRL_t {
	CH2_AL1_CTRL = uint32(0);          // 
 }

 // Alias for channel 2 CTRL register
 register CH2_AL1_CTRL_t CH2_AL1_CTRL at 0x50000090;

 type CH2_AL1_READ_ADDR_t {
	CH2_AL1_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 2 READ_ADDR register
 register CH2_AL1_READ_ADDR_t CH2_AL1_READ_ADDR at 0x50000094;

 type CH2_AL1_WRITE_ADDR_t {
	CH2_AL1_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 2 WRITE_ADDR register
 register CH2_AL1_WRITE_ADDR_t CH2_AL1_WRITE_ADDR at 0x50000098;

 type CH2_AL1_TRANS_COUNT_TRIG_t {
	CH2_AL1_TRANS_COUNT_TRIG = uint32(0);          // 
 }

 // Alias for channel 2 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH2_AL1_TRANS_COUNT_TRIG_t CH2_AL1_TRANS_COUNT_TRIG at 0x5000009c;

 type CH2_AL2_CTRL_t {
	CH2_AL2_CTRL = uint32(0);          // 
 }

 // Alias for channel 2 CTRL register
 register CH2_AL2_CTRL_t CH2_AL2_CTRL at 0x500000a0;

 type CH2_AL2_TRANS_COUNT_t {
	CH2_AL2_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 2 TRANS_COUNT register
 register CH2_AL2_TRANS_COUNT_t CH2_AL2_TRANS_COUNT at 0x500000a4;

 type CH2_AL2_READ_ADDR_t {
	CH2_AL2_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 2 READ_ADDR register
 register CH2_AL2_READ_ADDR_t CH2_AL2_READ_ADDR at 0x500000a8;

 type CH2_AL2_WRITE_ADDR_TRIG_t {
	CH2_AL2_WRITE_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 2 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH2_AL2_WRITE_ADDR_TRIG_t CH2_AL2_WRITE_ADDR_TRIG at 0x500000ac;

 type CH2_AL3_CTRL_t {
	CH2_AL3_CTRL = uint32(0);          // 
 }

 // Alias for channel 2 CTRL register
 register CH2_AL3_CTRL_t CH2_AL3_CTRL at 0x500000b0;

 type CH2_AL3_WRITE_ADDR_t {
	CH2_AL3_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 2 WRITE_ADDR register
 register CH2_AL3_WRITE_ADDR_t CH2_AL3_WRITE_ADDR at 0x500000b4;

 type CH2_AL3_TRANS_COUNT_t {
	CH2_AL3_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 2 TRANS_COUNT register
 register CH2_AL3_TRANS_COUNT_t CH2_AL3_TRANS_COUNT at 0x500000b8;

 type CH2_AL3_READ_ADDR_TRIG_t {
	CH2_AL3_READ_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 2 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH2_AL3_READ_ADDR_TRIG_t CH2_AL3_READ_ADDR_TRIG at 0x500000bc;

 type CH3_READ_ADDR_t {
	CH3_READ_ADDR = uint32(0);          // This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
 }

 // DMA Channel 3 Read Address pointer
 register CH3_READ_ADDR_t CH3_READ_ADDR at 0x500000c0;

 type CH3_WRITE_ADDR_t {
	CH3_WRITE_ADDR = uint32(0);          // This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
 }

 // DMA Channel 3 Write Address pointer
 register CH3_WRITE_ADDR_t CH3_WRITE_ADDR at 0x500000c4;

 type CH3_TRANS_COUNT_t {
	CH3_TRANS_COUNT = uint32(0);          // Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
 }

 // DMA Channel 3 Transfer Count
 register CH3_TRANS_COUNT_t CH3_TRANS_COUNT at 0x500000c8;

 type CH3_CTRL_TRIG_t {
	EN            = false;              // DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY = false;              // HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE     = uint2(0);           // Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	INCR_READ     = false;              // If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_WRITE    = false;              // If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	RING_SIZE     = uint4(0);           // Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_SEL      = false;              // Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO      = uint4(0);           // When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
	TREQ_SEL      = uint6(0);           // Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	IRQ_QUIET     = false;              // In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP         = false;              // Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN      = false;              // If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY          = false;              // This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	_res1         = uint4(0);           // Reserved, 4 bits
	WRITE_ERROR   = false;              // If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR    = false;              // If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR     = false;              // Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
 }

 // DMA Channel 3 Control and Status
 register CH3_CTRL_TRIG_t CH3_CTRL_TRIG at 0x500000cc;

 type CH3_AL1_CTRL_t {
	CH3_AL1_CTRL = uint32(0);          // 
 }

 // Alias for channel 3 CTRL register
 register CH3_AL1_CTRL_t CH3_AL1_CTRL at 0x500000d0;

 type CH3_AL1_READ_ADDR_t {
	CH3_AL1_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 3 READ_ADDR register
 register CH3_AL1_READ_ADDR_t CH3_AL1_READ_ADDR at 0x500000d4;

 type CH3_AL1_WRITE_ADDR_t {
	CH3_AL1_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 3 WRITE_ADDR register
 register CH3_AL1_WRITE_ADDR_t CH3_AL1_WRITE_ADDR at 0x500000d8;

 type CH3_AL1_TRANS_COUNT_TRIG_t {
	CH3_AL1_TRANS_COUNT_TRIG = uint32(0);          // 
 }

 // Alias for channel 3 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH3_AL1_TRANS_COUNT_TRIG_t CH3_AL1_TRANS_COUNT_TRIG at 0x500000dc;

 type CH3_AL2_CTRL_t {
	CH3_AL2_CTRL = uint32(0);          // 
 }

 // Alias for channel 3 CTRL register
 register CH3_AL2_CTRL_t CH3_AL2_CTRL at 0x500000e0;

 type CH3_AL2_TRANS_COUNT_t {
	CH3_AL2_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 3 TRANS_COUNT register
 register CH3_AL2_TRANS_COUNT_t CH3_AL2_TRANS_COUNT at 0x500000e4;

 type CH3_AL2_READ_ADDR_t {
	CH3_AL2_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 3 READ_ADDR register
 register CH3_AL2_READ_ADDR_t CH3_AL2_READ_ADDR at 0x500000e8;

 type CH3_AL2_WRITE_ADDR_TRIG_t {
	CH3_AL2_WRITE_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 3 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH3_AL2_WRITE_ADDR_TRIG_t CH3_AL2_WRITE_ADDR_TRIG at 0x500000ec;

 type CH3_AL3_CTRL_t {
	CH3_AL3_CTRL = uint32(0);          // 
 }

 // Alias for channel 3 CTRL register
 register CH3_AL3_CTRL_t CH3_AL3_CTRL at 0x500000f0;

 type CH3_AL3_WRITE_ADDR_t {
	CH3_AL3_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 3 WRITE_ADDR register
 register CH3_AL3_WRITE_ADDR_t CH3_AL3_WRITE_ADDR at 0x500000f4;

 type CH3_AL3_TRANS_COUNT_t {
	CH3_AL3_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 3 TRANS_COUNT register
 register CH3_AL3_TRANS_COUNT_t CH3_AL3_TRANS_COUNT at 0x500000f8;

 type CH3_AL3_READ_ADDR_TRIG_t {
	CH3_AL3_READ_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 3 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH3_AL3_READ_ADDR_TRIG_t CH3_AL3_READ_ADDR_TRIG at 0x500000fc;

 type CH4_READ_ADDR_t {
	CH4_READ_ADDR = uint32(0);          // This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
 }

 // DMA Channel 4 Read Address pointer
 register CH4_READ_ADDR_t CH4_READ_ADDR at 0x50000100;

 type CH4_WRITE_ADDR_t {
	CH4_WRITE_ADDR = uint32(0);          // This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
 }

 // DMA Channel 4 Write Address pointer
 register CH4_WRITE_ADDR_t CH4_WRITE_ADDR at 0x50000104;

 type CH4_TRANS_COUNT_t {
	CH4_TRANS_COUNT = uint32(0);          // Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
 }

 // DMA Channel 4 Transfer Count
 register CH4_TRANS_COUNT_t CH4_TRANS_COUNT at 0x50000108;

 type CH4_CTRL_TRIG_t {
	EN            = false;              // DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY = false;              // HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE     = uint2(0);           // Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	INCR_READ     = false;              // If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_WRITE    = false;              // If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	RING_SIZE     = uint4(0);           // Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_SEL      = false;              // Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO      = uint4(0);           // When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
	TREQ_SEL      = uint6(0);           // Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	IRQ_QUIET     = false;              // In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP         = false;              // Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN      = false;              // If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY          = false;              // This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	_res1         = uint4(0);           // Reserved, 4 bits
	WRITE_ERROR   = false;              // If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR    = false;              // If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR     = false;              // Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
 }

 // DMA Channel 4 Control and Status
 register CH4_CTRL_TRIG_t CH4_CTRL_TRIG at 0x5000010c;

 type CH4_AL1_CTRL_t {
	CH4_AL1_CTRL = uint32(0);          // 
 }

 // Alias for channel 4 CTRL register
 register CH4_AL1_CTRL_t CH4_AL1_CTRL at 0x50000110;

 type CH4_AL1_READ_ADDR_t {
	CH4_AL1_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 4 READ_ADDR register
 register CH4_AL1_READ_ADDR_t CH4_AL1_READ_ADDR at 0x50000114;

 type CH4_AL1_WRITE_ADDR_t {
	CH4_AL1_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 4 WRITE_ADDR register
 register CH4_AL1_WRITE_ADDR_t CH4_AL1_WRITE_ADDR at 0x50000118;

 type CH4_AL1_TRANS_COUNT_TRIG_t {
	CH4_AL1_TRANS_COUNT_TRIG = uint32(0);          // 
 }

 // Alias for channel 4 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH4_AL1_TRANS_COUNT_TRIG_t CH4_AL1_TRANS_COUNT_TRIG at 0x5000011c;

 type CH4_AL2_CTRL_t {
	CH4_AL2_CTRL = uint32(0);          // 
 }

 // Alias for channel 4 CTRL register
 register CH4_AL2_CTRL_t CH4_AL2_CTRL at 0x50000120;

 type CH4_AL2_TRANS_COUNT_t {
	CH4_AL2_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 4 TRANS_COUNT register
 register CH4_AL2_TRANS_COUNT_t CH4_AL2_TRANS_COUNT at 0x50000124;

 type CH4_AL2_READ_ADDR_t {
	CH4_AL2_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 4 READ_ADDR register
 register CH4_AL2_READ_ADDR_t CH4_AL2_READ_ADDR at 0x50000128;

 type CH4_AL2_WRITE_ADDR_TRIG_t {
	CH4_AL2_WRITE_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 4 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH4_AL2_WRITE_ADDR_TRIG_t CH4_AL2_WRITE_ADDR_TRIG at 0x5000012c;

 type CH4_AL3_CTRL_t {
	CH4_AL3_CTRL = uint32(0);          // 
 }

 // Alias for channel 4 CTRL register
 register CH4_AL3_CTRL_t CH4_AL3_CTRL at 0x50000130;

 type CH4_AL3_WRITE_ADDR_t {
	CH4_AL3_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 4 WRITE_ADDR register
 register CH4_AL3_WRITE_ADDR_t CH4_AL3_WRITE_ADDR at 0x50000134;

 type CH4_AL3_TRANS_COUNT_t {
	CH4_AL3_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 4 TRANS_COUNT register
 register CH4_AL3_TRANS_COUNT_t CH4_AL3_TRANS_COUNT at 0x50000138;

 type CH4_AL3_READ_ADDR_TRIG_t {
	CH4_AL3_READ_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 4 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH4_AL3_READ_ADDR_TRIG_t CH4_AL3_READ_ADDR_TRIG at 0x5000013c;

 type CH5_READ_ADDR_t {
	CH5_READ_ADDR = uint32(0);          // This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
 }

 // DMA Channel 5 Read Address pointer
 register CH5_READ_ADDR_t CH5_READ_ADDR at 0x50000140;

 type CH5_WRITE_ADDR_t {
	CH5_WRITE_ADDR = uint32(0);          // This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
 }

 // DMA Channel 5 Write Address pointer
 register CH5_WRITE_ADDR_t CH5_WRITE_ADDR at 0x50000144;

 type CH5_TRANS_COUNT_t {
	CH5_TRANS_COUNT = uint32(0);          // Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
 }

 // DMA Channel 5 Transfer Count
 register CH5_TRANS_COUNT_t CH5_TRANS_COUNT at 0x50000148;

 type CH5_CTRL_TRIG_t {
	EN            = false;              // DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY = false;              // HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE     = uint2(0);           // Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	INCR_READ     = false;              // If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_WRITE    = false;              // If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	RING_SIZE     = uint4(0);           // Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_SEL      = false;              // Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO      = uint4(0);           // When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
	TREQ_SEL      = uint6(0);           // Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	IRQ_QUIET     = false;              // In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP         = false;              // Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN      = false;              // If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY          = false;              // This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	_res1         = uint4(0);           // Reserved, 4 bits
	WRITE_ERROR   = false;              // If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR    = false;              // If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR     = false;              // Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
 }

 // DMA Channel 5 Control and Status
 register CH5_CTRL_TRIG_t CH5_CTRL_TRIG at 0x5000014c;

 type CH5_AL1_CTRL_t {
	CH5_AL1_CTRL = uint32(0);          // 
 }

 // Alias for channel 5 CTRL register
 register CH5_AL1_CTRL_t CH5_AL1_CTRL at 0x50000150;

 type CH5_AL1_READ_ADDR_t {
	CH5_AL1_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 5 READ_ADDR register
 register CH5_AL1_READ_ADDR_t CH5_AL1_READ_ADDR at 0x50000154;

 type CH5_AL1_WRITE_ADDR_t {
	CH5_AL1_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 5 WRITE_ADDR register
 register CH5_AL1_WRITE_ADDR_t CH5_AL1_WRITE_ADDR at 0x50000158;

 type CH5_AL1_TRANS_COUNT_TRIG_t {
	CH5_AL1_TRANS_COUNT_TRIG = uint32(0);          // 
 }

 // Alias for channel 5 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH5_AL1_TRANS_COUNT_TRIG_t CH5_AL1_TRANS_COUNT_TRIG at 0x5000015c;

 type CH5_AL2_CTRL_t {
	CH5_AL2_CTRL = uint32(0);          // 
 }

 // Alias for channel 5 CTRL register
 register CH5_AL2_CTRL_t CH5_AL2_CTRL at 0x50000160;

 type CH5_AL2_TRANS_COUNT_t {
	CH5_AL2_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 5 TRANS_COUNT register
 register CH5_AL2_TRANS_COUNT_t CH5_AL2_TRANS_COUNT at 0x50000164;

 type CH5_AL2_READ_ADDR_t {
	CH5_AL2_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 5 READ_ADDR register
 register CH5_AL2_READ_ADDR_t CH5_AL2_READ_ADDR at 0x50000168;

 type CH5_AL2_WRITE_ADDR_TRIG_t {
	CH5_AL2_WRITE_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 5 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH5_AL2_WRITE_ADDR_TRIG_t CH5_AL2_WRITE_ADDR_TRIG at 0x5000016c;

 type CH5_AL3_CTRL_t {
	CH5_AL3_CTRL = uint32(0);          // 
 }

 // Alias for channel 5 CTRL register
 register CH5_AL3_CTRL_t CH5_AL3_CTRL at 0x50000170;

 type CH5_AL3_WRITE_ADDR_t {
	CH5_AL3_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 5 WRITE_ADDR register
 register CH5_AL3_WRITE_ADDR_t CH5_AL3_WRITE_ADDR at 0x50000174;

 type CH5_AL3_TRANS_COUNT_t {
	CH5_AL3_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 5 TRANS_COUNT register
 register CH5_AL3_TRANS_COUNT_t CH5_AL3_TRANS_COUNT at 0x50000178;

 type CH5_AL3_READ_ADDR_TRIG_t {
	CH5_AL3_READ_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 5 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH5_AL3_READ_ADDR_TRIG_t CH5_AL3_READ_ADDR_TRIG at 0x5000017c;

 type CH6_READ_ADDR_t {
	CH6_READ_ADDR = uint32(0);          // This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
 }

 // DMA Channel 6 Read Address pointer
 register CH6_READ_ADDR_t CH6_READ_ADDR at 0x50000180;

 type CH6_WRITE_ADDR_t {
	CH6_WRITE_ADDR = uint32(0);          // This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
 }

 // DMA Channel 6 Write Address pointer
 register CH6_WRITE_ADDR_t CH6_WRITE_ADDR at 0x50000184;

 type CH6_TRANS_COUNT_t {
	CH6_TRANS_COUNT = uint32(0);          // Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
 }

 // DMA Channel 6 Transfer Count
 register CH6_TRANS_COUNT_t CH6_TRANS_COUNT at 0x50000188;

 type CH6_CTRL_TRIG_t {
	EN            = false;              // DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY = false;              // HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE     = uint2(0);           // Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	INCR_READ     = false;              // If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_WRITE    = false;              // If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	RING_SIZE     = uint4(0);           // Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_SEL      = false;              // Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO      = uint4(0);           // When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
	TREQ_SEL      = uint6(0);           // Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	IRQ_QUIET     = false;              // In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP         = false;              // Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN      = false;              // If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY          = false;              // This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	_res1         = uint4(0);           // Reserved, 4 bits
	WRITE_ERROR   = false;              // If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR    = false;              // If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR     = false;              // Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
 }

 // DMA Channel 6 Control and Status
 register CH6_CTRL_TRIG_t CH6_CTRL_TRIG at 0x5000018c;

 type CH6_AL1_CTRL_t {
	CH6_AL1_CTRL = uint32(0);          // 
 }

 // Alias for channel 6 CTRL register
 register CH6_AL1_CTRL_t CH6_AL1_CTRL at 0x50000190;

 type CH6_AL1_READ_ADDR_t {
	CH6_AL1_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 6 READ_ADDR register
 register CH6_AL1_READ_ADDR_t CH6_AL1_READ_ADDR at 0x50000194;

 type CH6_AL1_WRITE_ADDR_t {
	CH6_AL1_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 6 WRITE_ADDR register
 register CH6_AL1_WRITE_ADDR_t CH6_AL1_WRITE_ADDR at 0x50000198;

 type CH6_AL1_TRANS_COUNT_TRIG_t {
	CH6_AL1_TRANS_COUNT_TRIG = uint32(0);          // 
 }

 // Alias for channel 6 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH6_AL1_TRANS_COUNT_TRIG_t CH6_AL1_TRANS_COUNT_TRIG at 0x5000019c;

 type CH6_AL2_CTRL_t {
	CH6_AL2_CTRL = uint32(0);          // 
 }

 // Alias for channel 6 CTRL register
 register CH6_AL2_CTRL_t CH6_AL2_CTRL at 0x500001a0;

 type CH6_AL2_TRANS_COUNT_t {
	CH6_AL2_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 6 TRANS_COUNT register
 register CH6_AL2_TRANS_COUNT_t CH6_AL2_TRANS_COUNT at 0x500001a4;

 type CH6_AL2_READ_ADDR_t {
	CH6_AL2_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 6 READ_ADDR register
 register CH6_AL2_READ_ADDR_t CH6_AL2_READ_ADDR at 0x500001a8;

 type CH6_AL2_WRITE_ADDR_TRIG_t {
	CH6_AL2_WRITE_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 6 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH6_AL2_WRITE_ADDR_TRIG_t CH6_AL2_WRITE_ADDR_TRIG at 0x500001ac;

 type CH6_AL3_CTRL_t {
	CH6_AL3_CTRL = uint32(0);          // 
 }

 // Alias for channel 6 CTRL register
 register CH6_AL3_CTRL_t CH6_AL3_CTRL at 0x500001b0;

 type CH6_AL3_WRITE_ADDR_t {
	CH6_AL3_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 6 WRITE_ADDR register
 register CH6_AL3_WRITE_ADDR_t CH6_AL3_WRITE_ADDR at 0x500001b4;

 type CH6_AL3_TRANS_COUNT_t {
	CH6_AL3_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 6 TRANS_COUNT register
 register CH6_AL3_TRANS_COUNT_t CH6_AL3_TRANS_COUNT at 0x500001b8;

 type CH6_AL3_READ_ADDR_TRIG_t {
	CH6_AL3_READ_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 6 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH6_AL3_READ_ADDR_TRIG_t CH6_AL3_READ_ADDR_TRIG at 0x500001bc;

 type CH7_READ_ADDR_t {
	CH7_READ_ADDR = uint32(0);          // This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
 }

 // DMA Channel 7 Read Address pointer
 register CH7_READ_ADDR_t CH7_READ_ADDR at 0x500001c0;

 type CH7_WRITE_ADDR_t {
	CH7_WRITE_ADDR = uint32(0);          // This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
 }

 // DMA Channel 7 Write Address pointer
 register CH7_WRITE_ADDR_t CH7_WRITE_ADDR at 0x500001c4;

 type CH7_TRANS_COUNT_t {
	CH7_TRANS_COUNT = uint32(0);          // Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
 }

 // DMA Channel 7 Transfer Count
 register CH7_TRANS_COUNT_t CH7_TRANS_COUNT at 0x500001c8;

 type CH7_CTRL_TRIG_t {
	EN            = false;              // DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY = false;              // HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE     = uint2(0);           // Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	INCR_READ     = false;              // If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_WRITE    = false;              // If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	RING_SIZE     = uint4(0);           // Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_SEL      = false;              // Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO      = uint4(0);           // When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
	TREQ_SEL      = uint6(0);           // Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	IRQ_QUIET     = false;              // In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP         = false;              // Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN      = false;              // If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY          = false;              // This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	_res1         = uint4(0);           // Reserved, 4 bits
	WRITE_ERROR   = false;              // If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR    = false;              // If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR     = false;              // Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
 }

 // DMA Channel 7 Control and Status
 register CH7_CTRL_TRIG_t CH7_CTRL_TRIG at 0x500001cc;

 type CH7_AL1_CTRL_t {
	CH7_AL1_CTRL = uint32(0);          // 
 }

 // Alias for channel 7 CTRL register
 register CH7_AL1_CTRL_t CH7_AL1_CTRL at 0x500001d0;

 type CH7_AL1_READ_ADDR_t {
	CH7_AL1_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 7 READ_ADDR register
 register CH7_AL1_READ_ADDR_t CH7_AL1_READ_ADDR at 0x500001d4;

 type CH7_AL1_WRITE_ADDR_t {
	CH7_AL1_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 7 WRITE_ADDR register
 register CH7_AL1_WRITE_ADDR_t CH7_AL1_WRITE_ADDR at 0x500001d8;

 type CH7_AL1_TRANS_COUNT_TRIG_t {
	CH7_AL1_TRANS_COUNT_TRIG = uint32(0);          // 
 }

 // Alias for channel 7 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH7_AL1_TRANS_COUNT_TRIG_t CH7_AL1_TRANS_COUNT_TRIG at 0x500001dc;

 type CH7_AL2_CTRL_t {
	CH7_AL2_CTRL = uint32(0);          // 
 }

 // Alias for channel 7 CTRL register
 register CH7_AL2_CTRL_t CH7_AL2_CTRL at 0x500001e0;

 type CH7_AL2_TRANS_COUNT_t {
	CH7_AL2_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 7 TRANS_COUNT register
 register CH7_AL2_TRANS_COUNT_t CH7_AL2_TRANS_COUNT at 0x500001e4;

 type CH7_AL2_READ_ADDR_t {
	CH7_AL2_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 7 READ_ADDR register
 register CH7_AL2_READ_ADDR_t CH7_AL2_READ_ADDR at 0x500001e8;

 type CH7_AL2_WRITE_ADDR_TRIG_t {
	CH7_AL2_WRITE_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 7 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH7_AL2_WRITE_ADDR_TRIG_t CH7_AL2_WRITE_ADDR_TRIG at 0x500001ec;

 type CH7_AL3_CTRL_t {
	CH7_AL3_CTRL = uint32(0);          // 
 }

 // Alias for channel 7 CTRL register
 register CH7_AL3_CTRL_t CH7_AL3_CTRL at 0x500001f0;

 type CH7_AL3_WRITE_ADDR_t {
	CH7_AL3_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 7 WRITE_ADDR register
 register CH7_AL3_WRITE_ADDR_t CH7_AL3_WRITE_ADDR at 0x500001f4;

 type CH7_AL3_TRANS_COUNT_t {
	CH7_AL3_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 7 TRANS_COUNT register
 register CH7_AL3_TRANS_COUNT_t CH7_AL3_TRANS_COUNT at 0x500001f8;

 type CH7_AL3_READ_ADDR_TRIG_t {
	CH7_AL3_READ_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 7 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH7_AL3_READ_ADDR_TRIG_t CH7_AL3_READ_ADDR_TRIG at 0x500001fc;

 type CH8_READ_ADDR_t {
	CH8_READ_ADDR = uint32(0);          // This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
 }

 // DMA Channel 8 Read Address pointer
 register CH8_READ_ADDR_t CH8_READ_ADDR at 0x50000200;

 type CH8_WRITE_ADDR_t {
	CH8_WRITE_ADDR = uint32(0);          // This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
 }

 // DMA Channel 8 Write Address pointer
 register CH8_WRITE_ADDR_t CH8_WRITE_ADDR at 0x50000204;

 type CH8_TRANS_COUNT_t {
	CH8_TRANS_COUNT = uint32(0);          // Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
 }

 // DMA Channel 8 Transfer Count
 register CH8_TRANS_COUNT_t CH8_TRANS_COUNT at 0x50000208;

 type CH8_CTRL_TRIG_t {
	EN            = false;              // DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY = false;              // HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE     = uint2(0);           // Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	INCR_READ     = false;              // If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_WRITE    = false;              // If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	RING_SIZE     = uint4(0);           // Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_SEL      = false;              // Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO      = uint4(0);           // When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
	TREQ_SEL      = uint6(0);           // Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	IRQ_QUIET     = false;              // In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP         = false;              // Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN      = false;              // If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY          = false;              // This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	_res1         = uint4(0);           // Reserved, 4 bits
	WRITE_ERROR   = false;              // If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR    = false;              // If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR     = false;              // Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
 }

 // DMA Channel 8 Control and Status
 register CH8_CTRL_TRIG_t CH8_CTRL_TRIG at 0x5000020c;

 type CH8_AL1_CTRL_t {
	CH8_AL1_CTRL = uint32(0);          // 
 }

 // Alias for channel 8 CTRL register
 register CH8_AL1_CTRL_t CH8_AL1_CTRL at 0x50000210;

 type CH8_AL1_READ_ADDR_t {
	CH8_AL1_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 8 READ_ADDR register
 register CH8_AL1_READ_ADDR_t CH8_AL1_READ_ADDR at 0x50000214;

 type CH8_AL1_WRITE_ADDR_t {
	CH8_AL1_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 8 WRITE_ADDR register
 register CH8_AL1_WRITE_ADDR_t CH8_AL1_WRITE_ADDR at 0x50000218;

 type CH8_AL1_TRANS_COUNT_TRIG_t {
	CH8_AL1_TRANS_COUNT_TRIG = uint32(0);          // 
 }

 // Alias for channel 8 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH8_AL1_TRANS_COUNT_TRIG_t CH8_AL1_TRANS_COUNT_TRIG at 0x5000021c;

 type CH8_AL2_CTRL_t {
	CH8_AL2_CTRL = uint32(0);          // 
 }

 // Alias for channel 8 CTRL register
 register CH8_AL2_CTRL_t CH8_AL2_CTRL at 0x50000220;

 type CH8_AL2_TRANS_COUNT_t {
	CH8_AL2_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 8 TRANS_COUNT register
 register CH8_AL2_TRANS_COUNT_t CH8_AL2_TRANS_COUNT at 0x50000224;

 type CH8_AL2_READ_ADDR_t {
	CH8_AL2_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 8 READ_ADDR register
 register CH8_AL2_READ_ADDR_t CH8_AL2_READ_ADDR at 0x50000228;

 type CH8_AL2_WRITE_ADDR_TRIG_t {
	CH8_AL2_WRITE_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 8 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH8_AL2_WRITE_ADDR_TRIG_t CH8_AL2_WRITE_ADDR_TRIG at 0x5000022c;

 type CH8_AL3_CTRL_t {
	CH8_AL3_CTRL = uint32(0);          // 
 }

 // Alias for channel 8 CTRL register
 register CH8_AL3_CTRL_t CH8_AL3_CTRL at 0x50000230;

 type CH8_AL3_WRITE_ADDR_t {
	CH8_AL3_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 8 WRITE_ADDR register
 register CH8_AL3_WRITE_ADDR_t CH8_AL3_WRITE_ADDR at 0x50000234;

 type CH8_AL3_TRANS_COUNT_t {
	CH8_AL3_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 8 TRANS_COUNT register
 register CH8_AL3_TRANS_COUNT_t CH8_AL3_TRANS_COUNT at 0x50000238;

 type CH8_AL3_READ_ADDR_TRIG_t {
	CH8_AL3_READ_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 8 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH8_AL3_READ_ADDR_TRIG_t CH8_AL3_READ_ADDR_TRIG at 0x5000023c;

 type CH9_READ_ADDR_t {
	CH9_READ_ADDR = uint32(0);          // This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
 }

 // DMA Channel 9 Read Address pointer
 register CH9_READ_ADDR_t CH9_READ_ADDR at 0x50000240;

 type CH9_WRITE_ADDR_t {
	CH9_WRITE_ADDR = uint32(0);          // This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
 }

 // DMA Channel 9 Write Address pointer
 register CH9_WRITE_ADDR_t CH9_WRITE_ADDR at 0x50000244;

 type CH9_TRANS_COUNT_t {
	CH9_TRANS_COUNT = uint32(0);          // Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
 }

 // DMA Channel 9 Transfer Count
 register CH9_TRANS_COUNT_t CH9_TRANS_COUNT at 0x50000248;

 type CH9_CTRL_TRIG_t {
	EN            = false;              // DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY = false;              // HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE     = uint2(0);           // Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	INCR_READ     = false;              // If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_WRITE    = false;              // If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	RING_SIZE     = uint4(0);           // Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_SEL      = false;              // Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO      = uint4(0);           // When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
	TREQ_SEL      = uint6(0);           // Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	IRQ_QUIET     = false;              // In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP         = false;              // Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN      = false;              // If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY          = false;              // This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	_res1         = uint4(0);           // Reserved, 4 bits
	WRITE_ERROR   = false;              // If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR    = false;              // If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR     = false;              // Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
 }

 // DMA Channel 9 Control and Status
 register CH9_CTRL_TRIG_t CH9_CTRL_TRIG at 0x5000024c;

 type CH9_AL1_CTRL_t {
	CH9_AL1_CTRL = uint32(0);          // 
 }

 // Alias for channel 9 CTRL register
 register CH9_AL1_CTRL_t CH9_AL1_CTRL at 0x50000250;

 type CH9_AL1_READ_ADDR_t {
	CH9_AL1_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 9 READ_ADDR register
 register CH9_AL1_READ_ADDR_t CH9_AL1_READ_ADDR at 0x50000254;

 type CH9_AL1_WRITE_ADDR_t {
	CH9_AL1_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 9 WRITE_ADDR register
 register CH9_AL1_WRITE_ADDR_t CH9_AL1_WRITE_ADDR at 0x50000258;

 type CH9_AL1_TRANS_COUNT_TRIG_t {
	CH9_AL1_TRANS_COUNT_TRIG = uint32(0);          // 
 }

 // Alias for channel 9 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH9_AL1_TRANS_COUNT_TRIG_t CH9_AL1_TRANS_COUNT_TRIG at 0x5000025c;

 type CH9_AL2_CTRL_t {
	CH9_AL2_CTRL = uint32(0);          // 
 }

 // Alias for channel 9 CTRL register
 register CH9_AL2_CTRL_t CH9_AL2_CTRL at 0x50000260;

 type CH9_AL2_TRANS_COUNT_t {
	CH9_AL2_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 9 TRANS_COUNT register
 register CH9_AL2_TRANS_COUNT_t CH9_AL2_TRANS_COUNT at 0x50000264;

 type CH9_AL2_READ_ADDR_t {
	CH9_AL2_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 9 READ_ADDR register
 register CH9_AL2_READ_ADDR_t CH9_AL2_READ_ADDR at 0x50000268;

 type CH9_AL2_WRITE_ADDR_TRIG_t {
	CH9_AL2_WRITE_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 9 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH9_AL2_WRITE_ADDR_TRIG_t CH9_AL2_WRITE_ADDR_TRIG at 0x5000026c;

 type CH9_AL3_CTRL_t {
	CH9_AL3_CTRL = uint32(0);          // 
 }

 // Alias for channel 9 CTRL register
 register CH9_AL3_CTRL_t CH9_AL3_CTRL at 0x50000270;

 type CH9_AL3_WRITE_ADDR_t {
	CH9_AL3_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 9 WRITE_ADDR register
 register CH9_AL3_WRITE_ADDR_t CH9_AL3_WRITE_ADDR at 0x50000274;

 type CH9_AL3_TRANS_COUNT_t {
	CH9_AL3_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 9 TRANS_COUNT register
 register CH9_AL3_TRANS_COUNT_t CH9_AL3_TRANS_COUNT at 0x50000278;

 type CH9_AL3_READ_ADDR_TRIG_t {
	CH9_AL3_READ_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 9 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH9_AL3_READ_ADDR_TRIG_t CH9_AL3_READ_ADDR_TRIG at 0x5000027c;

 type CH10_READ_ADDR_t {
	CH10_READ_ADDR = uint32(0);          // This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
 }

 // DMA Channel 10 Read Address pointer
 register CH10_READ_ADDR_t CH10_READ_ADDR at 0x50000280;

 type CH10_WRITE_ADDR_t {
	CH10_WRITE_ADDR = uint32(0);          // This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
 }

 // DMA Channel 10 Write Address pointer
 register CH10_WRITE_ADDR_t CH10_WRITE_ADDR at 0x50000284;

 type CH10_TRANS_COUNT_t {
	CH10_TRANS_COUNT = uint32(0);          // Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
 }

 // DMA Channel 10 Transfer Count
 register CH10_TRANS_COUNT_t CH10_TRANS_COUNT at 0x50000288;

 type CH10_CTRL_TRIG_t {
	EN            = false;              // DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY = false;              // HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE     = uint2(0);           // Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	INCR_READ     = false;              // If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_WRITE    = false;              // If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	RING_SIZE     = uint4(0);           // Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_SEL      = false;              // Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO      = uint4(0);           // When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
	TREQ_SEL      = uint6(0);           // Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	IRQ_QUIET     = false;              // In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP         = false;              // Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN      = false;              // If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY          = false;              // This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	_res1         = uint4(0);           // Reserved, 4 bits
	WRITE_ERROR   = false;              // If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR    = false;              // If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR     = false;              // Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
 }

 // DMA Channel 10 Control and Status
 register CH10_CTRL_TRIG_t CH10_CTRL_TRIG at 0x5000028c;

 type CH10_AL1_CTRL_t {
	CH10_AL1_CTRL = uint32(0);          // 
 }

 // Alias for channel 10 CTRL register
 register CH10_AL1_CTRL_t CH10_AL1_CTRL at 0x50000290;

 type CH10_AL1_READ_ADDR_t {
	CH10_AL1_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 10 READ_ADDR register
 register CH10_AL1_READ_ADDR_t CH10_AL1_READ_ADDR at 0x50000294;

 type CH10_AL1_WRITE_ADDR_t {
	CH10_AL1_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 10 WRITE_ADDR register
 register CH10_AL1_WRITE_ADDR_t CH10_AL1_WRITE_ADDR at 0x50000298;

 type CH10_AL1_TRANS_COUNT_TRIG_t {
	CH10_AL1_TRANS_COUNT_TRIG = uint32(0);          // 
 }

 // Alias for channel 10 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH10_AL1_TRANS_COUNT_TRIG_t CH10_AL1_TRANS_COUNT_TRIG at 0x5000029c;

 type CH10_AL2_CTRL_t {
	CH10_AL2_CTRL = uint32(0);          // 
 }

 // Alias for channel 10 CTRL register
 register CH10_AL2_CTRL_t CH10_AL2_CTRL at 0x500002a0;

 type CH10_AL2_TRANS_COUNT_t {
	CH10_AL2_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 10 TRANS_COUNT register
 register CH10_AL2_TRANS_COUNT_t CH10_AL2_TRANS_COUNT at 0x500002a4;

 type CH10_AL2_READ_ADDR_t {
	CH10_AL2_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 10 READ_ADDR register
 register CH10_AL2_READ_ADDR_t CH10_AL2_READ_ADDR at 0x500002a8;

 type CH10_AL2_WRITE_ADDR_TRIG_t {
	CH10_AL2_WRITE_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 10 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH10_AL2_WRITE_ADDR_TRIG_t CH10_AL2_WRITE_ADDR_TRIG at 0x500002ac;

 type CH10_AL3_CTRL_t {
	CH10_AL3_CTRL = uint32(0);          // 
 }

 // Alias for channel 10 CTRL register
 register CH10_AL3_CTRL_t CH10_AL3_CTRL at 0x500002b0;

 type CH10_AL3_WRITE_ADDR_t {
	CH10_AL3_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 10 WRITE_ADDR register
 register CH10_AL3_WRITE_ADDR_t CH10_AL3_WRITE_ADDR at 0x500002b4;

 type CH10_AL3_TRANS_COUNT_t {
	CH10_AL3_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 10 TRANS_COUNT register
 register CH10_AL3_TRANS_COUNT_t CH10_AL3_TRANS_COUNT at 0x500002b8;

 type CH10_AL3_READ_ADDR_TRIG_t {
	CH10_AL3_READ_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 10 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH10_AL3_READ_ADDR_TRIG_t CH10_AL3_READ_ADDR_TRIG at 0x500002bc;

 type CH11_READ_ADDR_t {
	CH11_READ_ADDR = uint32(0);          // This register updates automatically each time a read completes. The current value is the next address to be read by this channel.
 }

 // DMA Channel 11 Read Address pointer
 register CH11_READ_ADDR_t CH11_READ_ADDR at 0x500002c0;

 type CH11_WRITE_ADDR_t {
	CH11_WRITE_ADDR = uint32(0);          // This register updates automatically each time a write completes. The current value is the next address to be written by this channel.
 }

 // DMA Channel 11 Write Address pointer
 register CH11_WRITE_ADDR_t CH11_WRITE_ADDR at 0x500002c4;

 type CH11_TRANS_COUNT_t {
	CH11_TRANS_COUNT = uint32(0);          // Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
 }

 // DMA Channel 11 Transfer Count
 register CH11_TRANS_COUNT_t CH11_TRANS_COUNT at 0x500002c8;

 type CH11_CTRL_TRIG_t {
	EN            = false;              // DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY = false;              // HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE     = uint2(0);           // Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	INCR_READ     = false;              // If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_WRITE    = false;              // If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	RING_SIZE     = uint4(0);           // Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_SEL      = false;              // Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO      = uint4(0);           // When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.
	TREQ_SEL      = uint6(0);           // Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	IRQ_QUIET     = false;              // In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP         = false;              // Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN      = false;              // If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY          = false;              // This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	_res1         = uint4(0);           // Reserved, 4 bits
	WRITE_ERROR   = false;              // If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR    = false;              // If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR     = false;              // Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
 }

 // DMA Channel 11 Control and Status
 register CH11_CTRL_TRIG_t CH11_CTRL_TRIG at 0x500002cc;

 type CH11_AL1_CTRL_t {
	CH11_AL1_CTRL = uint32(0);          // 
 }

 // Alias for channel 11 CTRL register
 register CH11_AL1_CTRL_t CH11_AL1_CTRL at 0x500002d0;

 type CH11_AL1_READ_ADDR_t {
	CH11_AL1_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 11 READ_ADDR register
 register CH11_AL1_READ_ADDR_t CH11_AL1_READ_ADDR at 0x500002d4;

 type CH11_AL1_WRITE_ADDR_t {
	CH11_AL1_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 11 WRITE_ADDR register
 register CH11_AL1_WRITE_ADDR_t CH11_AL1_WRITE_ADDR at 0x500002d8;

 type CH11_AL1_TRANS_COUNT_TRIG_t {
	CH11_AL1_TRANS_COUNT_TRIG = uint32(0);          // 
 }

 // Alias for channel 11 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH11_AL1_TRANS_COUNT_TRIG_t CH11_AL1_TRANS_COUNT_TRIG at 0x500002dc;

 type CH11_AL2_CTRL_t {
	CH11_AL2_CTRL = uint32(0);          // 
 }

 // Alias for channel 11 CTRL register
 register CH11_AL2_CTRL_t CH11_AL2_CTRL at 0x500002e0;

 type CH11_AL2_TRANS_COUNT_t {
	CH11_AL2_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 11 TRANS_COUNT register
 register CH11_AL2_TRANS_COUNT_t CH11_AL2_TRANS_COUNT at 0x500002e4;

 type CH11_AL2_READ_ADDR_t {
	CH11_AL2_READ_ADDR = uint32(0);          // 
 }

 // Alias for channel 11 READ_ADDR register
 register CH11_AL2_READ_ADDR_t CH11_AL2_READ_ADDR at 0x500002e8;

 type CH11_AL2_WRITE_ADDR_TRIG_t {
	CH11_AL2_WRITE_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 11 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH11_AL2_WRITE_ADDR_TRIG_t CH11_AL2_WRITE_ADDR_TRIG at 0x500002ec;

 type CH11_AL3_CTRL_t {
	CH11_AL3_CTRL = uint32(0);          // 
 }

 // Alias for channel 11 CTRL register
 register CH11_AL3_CTRL_t CH11_AL3_CTRL at 0x500002f0;

 type CH11_AL3_WRITE_ADDR_t {
	CH11_AL3_WRITE_ADDR = uint32(0);          // 
 }

 // Alias for channel 11 WRITE_ADDR register
 register CH11_AL3_WRITE_ADDR_t CH11_AL3_WRITE_ADDR at 0x500002f4;

 type CH11_AL3_TRANS_COUNT_t {
	CH11_AL3_TRANS_COUNT = uint32(0);          // 
 }

 // Alias for channel 11 TRANS_COUNT register
 register CH11_AL3_TRANS_COUNT_t CH11_AL3_TRANS_COUNT at 0x500002f8;

 type CH11_AL3_READ_ADDR_TRIG_t {
	CH11_AL3_READ_ADDR_TRIG = uint32(0);          // 
 }

 // Alias for channel 11 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
 register CH11_AL3_READ_ADDR_TRIG_t CH11_AL3_READ_ADDR_TRIG at 0x500002fc;

 type DMA_INTR_t {
	INTR = uint16(0);          // Raw interrupt status for DMA Channels 0..15. Bit n corresponds to channel n. Ignores any masking or forcing. Channel interrupts can be cleared by writing a bit mask to INTR, INTS0 or INTS1. Channel interrupts can be routed to either of two system-level IRQs based on INTE0 and INTE1. This can be used vector different channel interrupts to different ISRs: this might be done to allow NVIC IRQ preemption for more time-critical channels, or to spread IRQ load across different cores. It is also valid to ignore this behaviour and just use INTE0/INTS0/IRQ 0.
 }

 // Interrupt Status (raw)
 register DMA_INTR_t DMA_INTR at 0x50000400;

 type INTE0_t {
	INTE0 = uint16(0);          // Set bit n to pass interrupts from channel n to DMA IRQ 0.
 }

 // Interrupt Enables for IRQ 0
 register INTE0_t INTE0 at 0x50000404;

 type INTF0_t {
	INTF0 = uint16(0);          // Write 1s to force the corresponding bits in INTE0. The interrupt remains asserted until INTF0 is cleared.
 }

 // Force Interrupts
 register INTF0_t INTF0 at 0x50000408;

 type INTS0_t {
	INTS0 = uint16(0);          // Indicates active channel interrupt requests which are currently causing IRQ 0 to be asserted. Channel interrupts can be cleared by writing a bit mask here.
 }

 // Interrupt Status for IRQ 0
 register INTS0_t INTS0 at 0x5000040c;

 type DMA_INTR1_t {
	INTR1 = uint16(0);          // Raw interrupt status for DMA Channels 0..15. Bit n corresponds to channel n. Ignores any masking or forcing. Channel interrupts can be cleared by writing a bit mask to INTR, INTS0 or INTS1. Channel interrupts can be routed to either of two system-level IRQs based on INTE0 and INTE1. This can be used vector different channel interrupts to different ISRs: this might be done to allow NVIC IRQ preemption for more time-critical channels, or to spread IRQ load across different cores. It is also valid to ignore this behaviour and just use INTE0/INTS0/IRQ 0.
 }

 // Interrupt Status (raw)
 register DMA_INTR1_t DMA_INTR1 at 0x50000410;

 type INTE1_t {
	INTE1 = uint16(0);          // Set bit n to pass interrupts from channel n to DMA IRQ 1.
 }

 // Interrupt Enables for IRQ 1
 register INTE1_t INTE1 at 0x50000414;

 type INTF1_t {
	INTF1 = uint16(0);          // Write 1s to force the corresponding bits in INTE0. The interrupt remains asserted until INTF0 is cleared.
 }

 // Force Interrupts for IRQ 1
 register INTF1_t INTF1 at 0x50000418;

 type INTS1_t {
	INTS1 = uint16(0);          // Indicates active channel interrupt requests which are currently causing IRQ 1 to be asserted. Channel interrupts can be cleared by writing a bit mask here.
 }

 // Interrupt Status (masked) for IRQ 1
 register INTS1_t INTS1 at 0x5000041c;

 type TIMER0_t {
	Y = uint16(0);          // Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
	X = uint16(0);          // Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
 }

 // Pacing (X/Y) Fractional Timer The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
 register TIMER0_t TIMER0 at 0x50000420;

 type TIMER1_t {
	Y = uint16(0);          // Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
	X = uint16(0);          // Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
 }

 // Pacing (X/Y) Fractional Timer The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
 register TIMER1_t TIMER1 at 0x50000424;

 type TIMER2_t {
	Y = uint16(0);          // Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
	X = uint16(0);          // Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
 }

 // Pacing (X/Y) Fractional Timer The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
 register TIMER2_t TIMER2 at 0x50000428;

 type TIMER3_t {
	Y = uint16(0);          // Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
	X = uint16(0);          // Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
 }

 // Pacing (X/Y) Fractional Timer The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
 register TIMER3_t TIMER3 at 0x5000042c;

 type MULTI_CHAN_TRIGGER_t {
	MULTI_CHAN_TRIGGER = uint16(0);          // Each bit in this register corresponds to a DMA channel. Writing a 1 to the relevant bit is the same as writing to that channel's trigger register; the channel will start if it is currently enabled and not already busy.
 }

 // Trigger one or more channels simultaneously
 register MULTI_CHAN_TRIGGER_t MULTI_CHAN_TRIGGER at 0x50000430;

 type SNIFF_CTRL_t {
	EN      = false;              // Enable sniffer
	DMACH   = uint4(0);           // DMA channel for Sniffer to observe
	CALC    = uint4(0);           // 
	BSWAP   = false;              // Locally perform a byte reverse on the sniffed data, before feeding into checksum. Note that the sniff hardware is downstream of the DMA channel byteswap performed in the read master: if channel CTRL_BSWAP and SNIFF_CTRL_BSWAP are both enabled, their effects cancel from the sniffer's point of view.
	OUT_REV = false;              // If set, the result appears bit-reversed when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus.
	OUT_INV = false;              // If set, the result appears inverted (bitwise complement) when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus.
 }

 // Sniffer Control
 register SNIFF_CTRL_t SNIFF_CTRL at 0x50000434;

 type SNIFF_DATA_t {
	SNIFF_DATA = uint32(0);          // Write an initial seed value here before starting a DMA transfer on the channel indicated by SNIFF_CTRL_DMACH. The hardware will update this register each time it observes a read from the indicated channel. Once the channel completes, the final result can be read from this register.
 }

 // Data accumulator for sniff hardware
 register SNIFF_DATA_t SNIFF_DATA at 0x50000438;

 type FIFO_LEVELS_t {
	TDF_LVL = uint8(0);           // Current Transfer-Data-FIFO fill level
	WAF_LVL = uint8(0);           // Current Write-Address-FIFO fill level
	RAF_LVL = uint8(0);           // Current Read-Address-FIFO fill level
 }

 // Debug RAF, WAF, TDF levels
 register FIFO_LEVELS_t FIFO_LEVELS at 0x50000440;

 type CHAN_ABORT_t {
	CHAN_ABORT = uint16(0);          // Each bit corresponds to a channel. Writing a 1 aborts whatever transfer sequence is in progress on that channel. The bit will remain high until any in-flight transfers have been flushed through the address and data FIFOs. After writing, this register must be polled until it returns all-zero. Until this point, it is unsafe to restart the channel.
 }

 // Abort an in-progress transfer sequence on one or more channels
 register CHAN_ABORT_t CHAN_ABORT at 0x50000444;

 type N_CHANNELS_t {
	N_CHANNELS = uint5(0);           // 
 }

 // The number of channels this DMA instance is equipped with. This DMA supports up to 16 hardware channels, but can be configured with as few as one, to minimise silicon area.
 register N_CHANNELS_t N_CHANNELS at 0x50000448;

 type CH0_DBG_CTDREQ_t {
	CH0_DBG_CTDREQ = uint6(0);           // 
 }

 // Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
 register CH0_DBG_CTDREQ_t CH0_DBG_CTDREQ at 0x50000800;

 type CH0_DBG_TCR_t {
	CH0_DBG_TCR = uint32(0);          // 
 }

 // Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
 register CH0_DBG_TCR_t CH0_DBG_TCR at 0x50000804;

 type CH1_DBG_CTDREQ_t {
	CH1_DBG_CTDREQ = uint6(0);           // 
 }

 // Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
 register CH1_DBG_CTDREQ_t CH1_DBG_CTDREQ at 0x50000840;

 type CH1_DBG_TCR_t {
	CH1_DBG_TCR = uint32(0);          // 
 }

 // Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
 register CH1_DBG_TCR_t CH1_DBG_TCR at 0x50000844;

 type CH2_DBG_CTDREQ_t {
	CH2_DBG_CTDREQ = uint6(0);           // 
 }

 // Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
 register CH2_DBG_CTDREQ_t CH2_DBG_CTDREQ at 0x50000880;

 type CH2_DBG_TCR_t {
	CH2_DBG_TCR = uint32(0);          // 
 }

 // Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
 register CH2_DBG_TCR_t CH2_DBG_TCR at 0x50000884;

 type CH3_DBG_CTDREQ_t {
	CH3_DBG_CTDREQ = uint6(0);           // 
 }

 // Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
 register CH3_DBG_CTDREQ_t CH3_DBG_CTDREQ at 0x500008c0;

 type CH3_DBG_TCR_t {
	CH3_DBG_TCR = uint32(0);          // 
 }

 // Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
 register CH3_DBG_TCR_t CH3_DBG_TCR at 0x500008c4;

 type CH4_DBG_CTDREQ_t {
	CH4_DBG_CTDREQ = uint6(0);           // 
 }

 // Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
 register CH4_DBG_CTDREQ_t CH4_DBG_CTDREQ at 0x50000900;

 type CH4_DBG_TCR_t {
	CH4_DBG_TCR = uint32(0);          // 
 }

 // Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
 register CH4_DBG_TCR_t CH4_DBG_TCR at 0x50000904;

 type CH5_DBG_CTDREQ_t {
	CH5_DBG_CTDREQ = uint6(0);           // 
 }

 // Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
 register CH5_DBG_CTDREQ_t CH5_DBG_CTDREQ at 0x50000940;

 type CH5_DBG_TCR_t {
	CH5_DBG_TCR = uint32(0);          // 
 }

 // Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
 register CH5_DBG_TCR_t CH5_DBG_TCR at 0x50000944;

 type CH6_DBG_CTDREQ_t {
	CH6_DBG_CTDREQ = uint6(0);           // 
 }

 // Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
 register CH6_DBG_CTDREQ_t CH6_DBG_CTDREQ at 0x50000980;

 type CH6_DBG_TCR_t {
	CH6_DBG_TCR = uint32(0);          // 
 }

 // Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
 register CH6_DBG_TCR_t CH6_DBG_TCR at 0x50000984;

 type CH7_DBG_CTDREQ_t {
	CH7_DBG_CTDREQ = uint6(0);           // 
 }

 // Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
 register CH7_DBG_CTDREQ_t CH7_DBG_CTDREQ at 0x500009c0;

 type CH7_DBG_TCR_t {
	CH7_DBG_TCR = uint32(0);          // 
 }

 // Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
 register CH7_DBG_TCR_t CH7_DBG_TCR at 0x500009c4;

 type CH8_DBG_CTDREQ_t {
	CH8_DBG_CTDREQ = uint6(0);           // 
 }

 // Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
 register CH8_DBG_CTDREQ_t CH8_DBG_CTDREQ at 0x50000a00;

 type CH8_DBG_TCR_t {
	CH8_DBG_TCR = uint32(0);          // 
 }

 // Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
 register CH8_DBG_TCR_t CH8_DBG_TCR at 0x50000a04;

 type CH9_DBG_CTDREQ_t {
	CH9_DBG_CTDREQ = uint6(0);           // 
 }

 // Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
 register CH9_DBG_CTDREQ_t CH9_DBG_CTDREQ at 0x50000a40;

 type CH9_DBG_TCR_t {
	CH9_DBG_TCR = uint32(0);          // 
 }

 // Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
 register CH9_DBG_TCR_t CH9_DBG_TCR at 0x50000a44;

 type CH10_DBG_CTDREQ_t {
	CH10_DBG_CTDREQ = uint6(0);           // 
 }

 // Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
 register CH10_DBG_CTDREQ_t CH10_DBG_CTDREQ at 0x50000a80;

 type CH10_DBG_TCR_t {
	CH10_DBG_TCR = uint32(0);          // 
 }

 // Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
 register CH10_DBG_TCR_t CH10_DBG_TCR at 0x50000a84;

 type CH11_DBG_CTDREQ_t {
	CH11_DBG_CTDREQ = uint6(0);           // 
 }

 // Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
 register CH11_DBG_CTDREQ_t CH11_DBG_CTDREQ at 0x50000ac0;

 type CH11_DBG_TCR_t {
	CH11_DBG_TCR = uint32(0);          // 
 }

 // Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
 register CH11_DBG_TCR_t CH11_DBG_TCR at 0x50000ac4;


/* Types and registers for TIMER 
  Controls time and alarms time is a 64 bit value indicating the time in usec since power-on timeh is the top 32 bits of time & timel is the bottom 32 bits to change time write to timelw before timehw to read time read from timelr before timehr An alarm is set by setting alarm_enable and writing to the corresponding alarm register When an alarm is pending, the corresponding alarm_running signal will be high An alarm can be cancelled before it has finished by clearing the alarm_enable When an alarm fires, the corresponding alarm_irq is set and alarm_running is cleared To clear the interrupt write a 1 to the corresponding alarm_irq
 */

 type TIMEHW_t {
	TIMEHW = uint32(0);          // 
 }

 // Write to bits 63:32 of time always write timelw before timehw
 register TIMEHW_t TIMEHW at 0x40054000;

 type TIMELW_t {
	TIMELW = uint32(0);          // 
 }

 // Write to bits 31:0 of time writes do not get copied to time until timehw is written
 register TIMELW_t TIMELW at 0x40054004;

 type TIMEHR_t {
	TIMEHR = uint32(0);          // 
 }

 // Read from bits 63:32 of time always read timelr before timehr
 register TIMEHR_t TIMEHR at 0x40054008;

 type TIMELR_t {
	TIMELR = uint32(0);          // 
 }

 // Read from bits 31:0 of time
 register TIMELR_t TIMELR at 0x4005400c;

 type ALARM0_t {
	ALARM0 = uint32(0);          // 
 }

 // Arm alarm 0, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM0 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
 register ALARM0_t ALARM0 at 0x40054010;

 type ALARM1_t {
	ALARM1 = uint32(0);          // 
 }

 // Arm alarm 1, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM1 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
 register ALARM1_t ALARM1 at 0x40054014;

 type ALARM2_t {
	ALARM2 = uint32(0);          // 
 }

 // Arm alarm 2, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM2 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
 register ALARM2_t ALARM2 at 0x40054018;

 type ALARM3_t {
	ALARM3 = uint32(0);          // 
 }

 // Arm alarm 3, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM3 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
 register ALARM3_t ALARM3 at 0x4005401c;

 type ARMED_t {
	ARMED = uint4(0);           // 
 }

 // Indicates the armed/disarmed status of each alarm. A write to the corresponding ALARMx register arms the alarm. Alarms automatically disarm upon firing, but writing ones here will disarm immediately without waiting to fire.
 register ARMED_t ARMED at 0x40054020;

 type TIMERAWH_t {
	TIMERAWH = uint32(0);          // 
 }

 // Raw read from bits 63:32 of time (no side effects)
 register TIMERAWH_t TIMERAWH at 0x40054024;

 type TIMERAWL_t {
	TIMERAWL = uint32(0);          // 
 }

 // Raw read from bits 31:0 of time (no side effects)
 register TIMERAWL_t TIMERAWL at 0x40054028;

 type DBGPAUSE_t {
	_res1 = false;              // Reserved, 1 bits
	DBG0  = false;              // Pause when processor 0 is in debug mode
	DBG1  = false;              // Pause when processor 1 is in debug mode
 }

 // Set bits high to enable pause when the corresponding debug ports are active
 register DBGPAUSE_t DBGPAUSE at 0x4005402c;

 type PAUSE_t {
	PAUSE = false;              // 
 }

 // Set high to pause the timer
 register PAUSE_t PAUSE at 0x40054030;

 type TIMER_INTR_t {
	ALARM_0 = false;              // 
	ALARM_1 = false;              // 
	ALARM_2 = false;              // 
	ALARM_3 = false;              // 
 }

 // Raw Interrupts
 register TIMER_INTR_t TIMER_INTR at 0x40054034;

 type TIMER_INTE_t {
	ALARM_0 = false;              // 
	ALARM_1 = false;              // 
	ALARM_2 = false;              // 
	ALARM_3 = false;              // 
 }

 // Interrupt Enable
 register TIMER_INTE_t TIMER_INTE at 0x40054038;

 type TIMER_INTF_t {
	ALARM_0 = false;              // 
	ALARM_1 = false;              // 
	ALARM_2 = false;              // 
	ALARM_3 = false;              // 
 }

 // Interrupt Force
 register TIMER_INTF_t TIMER_INTF at 0x4005403c;

 type TIMER_INTS_t {
	ALARM_0 = false;              // 
	ALARM_1 = false;              // 
	ALARM_2 = false;              // 
	ALARM_3 = false;              // 
 }

 // Interrupt status after masking & forcing
 register TIMER_INTS_t TIMER_INTS at 0x40054040;


/* Types and registers for PWM 
  Simple PWM
 */

 type CH0_CSR_t {
	EN         = false;              // Enable the PWM channel.
	PH_CORRECT = false;              // 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      = false;              // Invert output A
	B_INV      = false;              // Invert output B
	DIVMODE    = uint2(0);           // 
	PH_RET     = false;              // Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     = false;              // Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
 }

 // Control and status register
 register CH0_CSR_t CH0_CSR at 0x40050000;

 type CH0_DIV_t {
	FRAC = uint4(0);           // 
	INT  = uint8(0);           // 
 }

 // INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
 register CH0_DIV_t CH0_DIV at 0x40050004;

 type CH0_CTR_t {
	CH0_CTR = uint16(0);          // 
 }

 // Direct access to the PWM counter
 register CH0_CTR_t CH0_CTR at 0x40050008;

 type CH0_CC_t {
	A = uint16(0);          // 
	B = uint16(0);          // 
 }

 // Counter compare values
 register CH0_CC_t CH0_CC at 0x4005000c;

 type CH0_TOP_t {
	CH0_TOP = uint16(0);          // 
 }

 // Counter wrap value
 register CH0_TOP_t CH0_TOP at 0x40050010;

 type CH1_CSR_t {
	EN         = false;              // Enable the PWM channel.
	PH_CORRECT = false;              // 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      = false;              // Invert output A
	B_INV      = false;              // Invert output B
	DIVMODE    = uint2(0);           // 
	PH_RET     = false;              // Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     = false;              // Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
 }

 // Control and status register
 register CH1_CSR_t CH1_CSR at 0x40050014;

 type CH1_DIV_t {
	FRAC = uint4(0);           // 
	INT  = uint8(0);           // 
 }

 // INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
 register CH1_DIV_t CH1_DIV at 0x40050018;

 type CH1_CTR_t {
	CH1_CTR = uint16(0);          // 
 }

 // Direct access to the PWM counter
 register CH1_CTR_t CH1_CTR at 0x4005001c;

 type CH1_CC_t {
	A = uint16(0);          // 
	B = uint16(0);          // 
 }

 // Counter compare values
 register CH1_CC_t CH1_CC at 0x40050020;

 type CH1_TOP_t {
	CH1_TOP = uint16(0);          // 
 }

 // Counter wrap value
 register CH1_TOP_t CH1_TOP at 0x40050024;

 type CH2_CSR_t {
	EN         = false;              // Enable the PWM channel.
	PH_CORRECT = false;              // 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      = false;              // Invert output A
	B_INV      = false;              // Invert output B
	DIVMODE    = uint2(0);           // 
	PH_RET     = false;              // Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     = false;              // Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
 }

 // Control and status register
 register CH2_CSR_t CH2_CSR at 0x40050028;

 type CH2_DIV_t {
	FRAC = uint4(0);           // 
	INT  = uint8(0);           // 
 }

 // INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
 register CH2_DIV_t CH2_DIV at 0x4005002c;

 type CH2_CTR_t {
	CH2_CTR = uint16(0);          // 
 }

 // Direct access to the PWM counter
 register CH2_CTR_t CH2_CTR at 0x40050030;

 type CH2_CC_t {
	A = uint16(0);          // 
	B = uint16(0);          // 
 }

 // Counter compare values
 register CH2_CC_t CH2_CC at 0x40050034;

 type CH2_TOP_t {
	CH2_TOP = uint16(0);          // 
 }

 // Counter wrap value
 register CH2_TOP_t CH2_TOP at 0x40050038;

 type CH3_CSR_t {
	EN         = false;              // Enable the PWM channel.
	PH_CORRECT = false;              // 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      = false;              // Invert output A
	B_INV      = false;              // Invert output B
	DIVMODE    = uint2(0);           // 
	PH_RET     = false;              // Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     = false;              // Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
 }

 // Control and status register
 register CH3_CSR_t CH3_CSR at 0x4005003c;

 type CH3_DIV_t {
	FRAC = uint4(0);           // 
	INT  = uint8(0);           // 
 }

 // INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
 register CH3_DIV_t CH3_DIV at 0x40050040;

 type CH3_CTR_t {
	CH3_CTR = uint16(0);          // 
 }

 // Direct access to the PWM counter
 register CH3_CTR_t CH3_CTR at 0x40050044;

 type CH3_CC_t {
	A = uint16(0);          // 
	B = uint16(0);          // 
 }

 // Counter compare values
 register CH3_CC_t CH3_CC at 0x40050048;

 type CH3_TOP_t {
	CH3_TOP = uint16(0);          // 
 }

 // Counter wrap value
 register CH3_TOP_t CH3_TOP at 0x4005004c;

 type CH4_CSR_t {
	EN         = false;              // Enable the PWM channel.
	PH_CORRECT = false;              // 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      = false;              // Invert output A
	B_INV      = false;              // Invert output B
	DIVMODE    = uint2(0);           // 
	PH_RET     = false;              // Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     = false;              // Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
 }

 // Control and status register
 register CH4_CSR_t CH4_CSR at 0x40050050;

 type CH4_DIV_t {
	FRAC = uint4(0);           // 
	INT  = uint8(0);           // 
 }

 // INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
 register CH4_DIV_t CH4_DIV at 0x40050054;

 type CH4_CTR_t {
	CH4_CTR = uint16(0);          // 
 }

 // Direct access to the PWM counter
 register CH4_CTR_t CH4_CTR at 0x40050058;

 type CH4_CC_t {
	A = uint16(0);          // 
	B = uint16(0);          // 
 }

 // Counter compare values
 register CH4_CC_t CH4_CC at 0x4005005c;

 type CH4_TOP_t {
	CH4_TOP = uint16(0);          // 
 }

 // Counter wrap value
 register CH4_TOP_t CH4_TOP at 0x40050060;

 type CH5_CSR_t {
	EN         = false;              // Enable the PWM channel.
	PH_CORRECT = false;              // 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      = false;              // Invert output A
	B_INV      = false;              // Invert output B
	DIVMODE    = uint2(0);           // 
	PH_RET     = false;              // Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     = false;              // Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
 }

 // Control and status register
 register CH5_CSR_t CH5_CSR at 0x40050064;

 type CH5_DIV_t {
	FRAC = uint4(0);           // 
	INT  = uint8(0);           // 
 }

 // INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
 register CH5_DIV_t CH5_DIV at 0x40050068;

 type CH5_CTR_t {
	CH5_CTR = uint16(0);          // 
 }

 // Direct access to the PWM counter
 register CH5_CTR_t CH5_CTR at 0x4005006c;

 type CH5_CC_t {
	A = uint16(0);          // 
	B = uint16(0);          // 
 }

 // Counter compare values
 register CH5_CC_t CH5_CC at 0x40050070;

 type CH5_TOP_t {
	CH5_TOP = uint16(0);          // 
 }

 // Counter wrap value
 register CH5_TOP_t CH5_TOP at 0x40050074;

 type CH6_CSR_t {
	EN         = false;              // Enable the PWM channel.
	PH_CORRECT = false;              // 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      = false;              // Invert output A
	B_INV      = false;              // Invert output B
	DIVMODE    = uint2(0);           // 
	PH_RET     = false;              // Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     = false;              // Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
 }

 // Control and status register
 register CH6_CSR_t CH6_CSR at 0x40050078;

 type CH6_DIV_t {
	FRAC = uint4(0);           // 
	INT  = uint8(0);           // 
 }

 // INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
 register CH6_DIV_t CH6_DIV at 0x4005007c;

 type CH6_CTR_t {
	CH6_CTR = uint16(0);          // 
 }

 // Direct access to the PWM counter
 register CH6_CTR_t CH6_CTR at 0x40050080;

 type CH6_CC_t {
	A = uint16(0);          // 
	B = uint16(0);          // 
 }

 // Counter compare values
 register CH6_CC_t CH6_CC at 0x40050084;

 type CH6_TOP_t {
	CH6_TOP = uint16(0);          // 
 }

 // Counter wrap value
 register CH6_TOP_t CH6_TOP at 0x40050088;

 type CH7_CSR_t {
	EN         = false;              // Enable the PWM channel.
	PH_CORRECT = false;              // 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      = false;              // Invert output A
	B_INV      = false;              // Invert output B
	DIVMODE    = uint2(0);           // 
	PH_RET     = false;              // Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     = false;              // Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
 }

 // Control and status register
 register CH7_CSR_t CH7_CSR at 0x4005008c;

 type CH7_DIV_t {
	FRAC = uint4(0);           // 
	INT  = uint8(0);           // 
 }

 // INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
 register CH7_DIV_t CH7_DIV at 0x40050090;

 type CH7_CTR_t {
	CH7_CTR = uint16(0);          // 
 }

 // Direct access to the PWM counter
 register CH7_CTR_t CH7_CTR at 0x40050094;

 type CH7_CC_t {
	A = uint16(0);          // 
	B = uint16(0);          // 
 }

 // Counter compare values
 register CH7_CC_t CH7_CC at 0x40050098;

 type CH7_TOP_t {
	CH7_TOP = uint16(0);          // 
 }

 // Counter wrap value
 register CH7_TOP_t CH7_TOP at 0x4005009c;

 type EN_t {
	CH0 = false;              // 
	CH1 = false;              // 
	CH2 = false;              // 
	CH3 = false;              // 
	CH4 = false;              // 
	CH5 = false;              // 
	CH6 = false;              // 
	CH7 = false;              // 
 }

 // This register aliases the CSR_EN bits for all channels. Writing to this register allows multiple channels to be enabled or disabled simultaneously, so they can run in perfect sync. For each channel, there is only one physical EN register bit, which can be accessed through here or CHx_CSR.
 register EN_t EN at 0x400500a0;

 type PWM_INTR_t {
	CH0 = false;              // 
	CH1 = false;              // 
	CH2 = false;              // 
	CH3 = false;              // 
	CH4 = false;              // 
	CH5 = false;              // 
	CH6 = false;              // 
	CH7 = false;              // 
 }

 // Raw Interrupts
 register PWM_INTR_t PWM_INTR at 0x400500a4;

 type PWM_INTE_t {
	CH0 = false;              // 
	CH1 = false;              // 
	CH2 = false;              // 
	CH3 = false;              // 
	CH4 = false;              // 
	CH5 = false;              // 
	CH6 = false;              // 
	CH7 = false;              // 
 }

 // Interrupt Enable
 register PWM_INTE_t PWM_INTE at 0x400500a8;

 type PWM_INTF_t {
	CH0 = false;              // 
	CH1 = false;              // 
	CH2 = false;              // 
	CH3 = false;              // 
	CH4 = false;              // 
	CH5 = false;              // 
	CH6 = false;              // 
	CH7 = false;              // 
 }

 // Interrupt Force
 register PWM_INTF_t PWM_INTF at 0x400500ac;

 type PWM_INTS_t {
	CH0 = false;              // 
	CH1 = false;              // 
	CH2 = false;              // 
	CH3 = false;              // 
	CH4 = false;              // 
	CH5 = false;              // 
	CH6 = false;              // 
	CH7 = false;              // 
 }

 // Interrupt status after masking & forcing
 register PWM_INTS_t PWM_INTS at 0x400500b0;


/* Types and registers for ADC 
  Control and data interface to SAR ADC
 */

 type ADC_CS_t {
	EN         = false;              // Power on ADC and enable its clock. 1 - enabled. 0 - disabled.
	TS_EN      = false;              // Power on temperature sensor. 1 - enabled. 0 - disabled.
	START_ONCE = false;              // Start a single conversion. Self-clearing. Ignored if start_many is asserted.
	START_MANY = false;              // Continuously perform conversions whilst this bit is 1. A new conversion will start immediately after the previous finishes.
	_res1      = uint4(0);           // Reserved, 4 bits
	READY      = false;              // 1 if the ADC is ready to start a new conversion. Implies any previous conversion has completed. 0 whilst conversion in progress.
	ERR        = false;              // The most recent ADC conversion encountered an error; result is undefined or noisy.
	ERR_STICKY = false;              // Some past ADC conversion encountered an error. Write 1 to clear.
	_res2      = false;              // Reserved, 1 bits
	AINSEL     = uint3(0);           // Select analog mux input. Updated automatically in round-robin mode.
	_res3      = false;              // Reserved, 1 bits
	RROBIN     = uint5(0);           // Round-robin sampling. 1 bit per channel. Set all bits to 0 to disable. Otherwise, the ADC will cycle through each enabled channel in a round-robin fashion. The first channel to be sampled will be the one currently indicated by AINSEL. AINSEL will be updated after each conversion with the newly-selected channel.
 }

 // ADC Control and Status
 register ADC_CS_t ADC_CS at 0x4004c000;

 type RESULT_t {
	RESULT = uint12(0);          // 
 }

 // Result of most recent ADC conversion
 register RESULT_t RESULT at 0x4004c004;

 type FCS_t {
	EN      = false;              // If 1: write result to the FIFO after each conversion.
	SHIFT   = false;              // If 1: FIFO results are right-shifted to be one byte in size. Enables DMA to byte buffers.
	ERR     = false;              // If 1: conversion error bit appears in the FIFO alongside the result
	DREQ_EN = false;              // If 1: assert DMA requests when FIFO contains data
	_res1   = uint4(0);           // Reserved, 4 bits
	EMPTY   = false;              // 
	FULL    = false;              // 
	UNDER   = false;              // 1 if the FIFO has been underflowed. Write 1 to clear.
	OVER    = false;              // 1 if the FIFO has been overflowed. Write 1 to clear.
	_res2   = uint4(0);           // Reserved, 4 bits
	LEVEL   = uint4(0);           // The number of conversion results currently waiting in the FIFO
	_res3   = uint4(0);           // Reserved, 4 bits
	THRESH  = uint4(0);           // DREQ/IRQ asserted when level >= threshold
 }

 // FIFO control and status
 register FCS_t FCS at 0x4004c008;

 type FIFO_t {
	VAL   = uint12(0);          // 
	_res1 = uint3(0);           // Reserved, 3 bits
	ERR   = false;              // 1 if this particular sample experienced a conversion error. Remains in the same location if the sample is shifted.
 }

 // Conversion result FIFO
 register FIFO_t FIFO at 0x4004c00c;

 type ADC_DIV_t {
	FRAC = uint8(0);           // Fractional part of clock divisor. First-order delta-sigma.
	INT  = uint16(0);          // Integer part of clock divisor.
 }

 // Clock divider. If non-zero, CS_START_MANY will start conversions at regular intervals rather than back-to-back. The divider is reset when either of these fields are written. Total period is 1 + INT + FRAC / 256
 register ADC_DIV_t ADC_DIV at 0x4004c010;

 type ADC_INTR_t {
	FIFO = false;              // Triggered when the sample FIFO reaches a certain level. This level can be programmed via the FCS_THRESH field.
 }

 // Raw Interrupts
 register ADC_INTR_t ADC_INTR at 0x4004c014;

 type ADC_INTE_t {
	FIFO = false;              // Triggered when the sample FIFO reaches a certain level. This level can be programmed via the FCS_THRESH field.
 }

 // Interrupt Enable
 register ADC_INTE_t ADC_INTE at 0x4004c018;

 type ADC_INTF_t {
	FIFO = false;              // Triggered when the sample FIFO reaches a certain level. This level can be programmed via the FCS_THRESH field.
 }

 // Interrupt Force
 register ADC_INTF_t ADC_INTF at 0x4004c01c;

 type ADC_INTS_t {
	FIFO = false;              // Triggered when the sample FIFO reaches a certain level. This level can be programmed via the FCS_THRESH field.
 }

 // Interrupt status after masking & forcing
 register ADC_INTS_t ADC_INTS at 0x4004c020;


/* Types and registers for I2C0 
  DW_apb_i2c address block List of configuration constants for the Synopsys I2C hardware (you may see references to these in I2C register header; these are *fixed* values, set at hardware design time): IC_ULTRA_FAST_MODE ................ 0x0 IC_UFM_TBUF_CNT_DEFAULT ........... 0x8 IC_UFM_SCL_LOW_COUNT .............. 0x0008 IC_UFM_SCL_HIGH_COUNT ............. 0x0006 IC_TX_TL .......................... 0x0 IC_TX_CMD_BLOCK ................... 0x1 IC_HAS_DMA ........................ 0x1 IC_HAS_ASYNC_FIFO ................. 0x0 IC_SMBUS_ARP ...................... 0x0 IC_FIRST_DATA_BYTE_STATUS ......... 0x1 IC_INTR_IO ........................ 0x1 IC_MASTER_MODE .................... 0x1 IC_DEFAULT_ACK_GENERAL_CALL ....... 0x1 IC_INTR_POL ....................... 0x1 IC_OPTIONAL_SAR ................... 0x0 IC_DEFAULT_TAR_SLAVE_ADDR ......... 0x055 IC_DEFAULT_SLAVE_ADDR ............. 0x055 IC_DEFAULT_HS_SPKLEN .............. 0x1 IC_FS_SCL_HIGH_COUNT .............. 0x0006 IC_HS_SCL_LOW_COUNT ............... 0x0008 IC_DEVICE_ID_VALUE ................ 0x0 IC_10BITADDR_MASTER ............... 0x0 IC_CLK_FREQ_OPTIMIZATION .......... 0x0 IC_DEFAULT_FS_SPKLEN .............. 0x7 IC_ADD_ENCODED_PARAMS ............. 0x0 IC_DEFAULT_SDA_HOLD ............... 0x000001 IC_DEFAULT_SDA_SETUP .............. 0x64 IC_AVOID_RX_FIFO_FLUSH_ON_TX_ABRT . 0x0 IC_CLOCK_PERIOD ................... 100 IC_EMPTYFIFO_HOLD_MASTER_EN ....... 1 IC_RESTART_EN ..................... 0x1 IC_TX_CMD_BLOCK_DEFAULT ........... 0x0 IC_BUS_CLEAR_FEATURE .............. 0x0 IC_CAP_LOADING .................... 100 IC_FS_SCL_LOW_COUNT ............... 0x000d APB_DATA_WIDTH .................... 32 IC_SDA_STUCK_TIMEOUT_DEFAULT ...... 0xffffffff IC_SLV_DATA_NACK_ONLY ............. 0x1 IC_10BITADDR_SLAVE ................ 0x0 IC_CLK_TYPE ....................... 0x0 IC_SMBUS_UDID_MSB ................. 0x0 IC_SMBUS_SUSPEND_ALERT ............ 0x0 IC_HS_SCL_HIGH_COUNT .............. 0x0006 IC_SLV_RESTART_DET_EN ............. 0x1 IC_SMBUS .......................... 0x0 IC_OPTIONAL_SAR_DEFAULT ........... 0x0 IC_PERSISTANT_SLV_ADDR_DEFAULT .... 0x0 IC_USE_COUNTS ..................... 0x0 IC_RX_BUFFER_DEPTH ................ 16 IC_SCL_STUCK_TIMEOUT_DEFAULT ...... 0xffffffff IC_RX_FULL_HLD_BUS_EN ............. 0x1 IC_SLAVE_DISABLE .................. 0x1 IC_RX_TL .......................... 0x0 IC_DEVICE_ID ...................... 0x0 IC_HC_COUNT_VALUES ................ 0x0 I2C_DYNAMIC_TAR_UPDATE ............ 0 IC_SMBUS_CLK_LOW_MEXT_DEFAULT ..... 0xffffffff IC_SMBUS_CLK_LOW_SEXT_DEFAULT ..... 0xffffffff IC_HS_MASTER_CODE ................. 0x1 IC_SMBUS_RST_IDLE_CNT_DEFAULT ..... 0xffff IC_SMBUS_UDID_LSB_DEFAULT ......... 0xffffffff IC_SS_SCL_HIGH_COUNT .............. 0x0028 IC_SS_SCL_LOW_COUNT ............... 0x002f IC_MAX_SPEED_MODE ................. 0x2 IC_STAT_FOR_CLK_STRETCH ........... 0x0 IC_STOP_DET_IF_MASTER_ACTIVE ...... 0x0 IC_DEFAULT_UFM_SPKLEN ............. 0x1 IC_TX_BUFFER_DEPTH ................ 16
 */

 type IC_CON_t {
	MASTER_MODE               = false;              // This bit controls whether the DW_apb_i2c master is enabled. NOTE: Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'.
	SPEED                     = uint2(0);           // These bits control at which speed the DW_apb_i2c operates; its setting is relevant only if one is operating the DW_apb_i2c in master mode. Hardware protects against illegal values being programmed by software. These bits must be programmed appropriately for slave mode also, as it is used to capture correct value of spike filter as per the speed mode. This register should be programmed only with a value in the range of 1 to IC_MAX_SPEED_MODE; otherwise, hardware updates this register with the value of IC_MAX_SPEED_MODE. 1: standard mode (100 kbit/s) 2: fast mode (<=400 kbit/s) or fast mode plus (<=1000Kbit/s) 3: high speed mode (3.4 Mbit/s) Note: This field is not applicable when IC_ULTRA_FAST_MODE=1
	IC_10BITADDR_SLAVE        = false;              // When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit addressing transfers that match the full 10 bits of the IC_SAR register.
	IC_10BITADDR_MASTER       = false;              // Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing
	IC_RESTART_EN             = false;              // Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several DW_apb_i2c operations. When RESTART is disabled, the master is prohibited from performing the following functions: - Sending a START BYTE - Performing any high-speed mode operation - High-speed mode operation - Performing direction changes in combined format mode - Performing a read operation with a 10-bit address By replacing RESTART condition followed by a STOP and a subsequent START condition, split operations are broken down into multiple DW_apb_i2c transfers. If the above operations are performed, it will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. Reset value: ENABLED
	IC_SLAVE_DISABLE          = false;              // This bit controls whether I2C has its slave disabled, which means once the presetn signal is applied, then this bit is set and the slave is disabled. If this bit is set (slave is disabled), DW_apb_i2c functions only as a master and does not perform any action that requires a slave. NOTE: Software should ensure that if this bit is written with 0, then bit 0 should also be written with a 0.
	STOP_DET_IFADDRESSED      = false;              // In slave mode: - 1'b1: issues the STOP_DET interrupt only when it is addressed. - 1'b0: issues the STOP_DET irrespective of whether it's addressed or not. Reset value: 0x0 NOTE: During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR).
	TX_EMPTY_CTRL             = false;              // This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register. Reset value: 0x0.
	RX_FIFO_FULL_HLD_CTRL     = false;              // This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH, as described in the IC_RX_FULL_HLD_BUS_EN parameter. Reset value: 0x0.
	STOP_DET_IF_MASTER_ACTIVE = false;              // Master issues the STOP_DET interrupt irrespective of whether master is active or not
 }

 // I2C0 I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are read only.
 register IC_CON_t I2C0_IC_CON at 0x40044000;

 type IC_TAR_t {
	IC_TAR      = uint10(0);          // This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits. If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave.
	GC_OR_START = false;              // If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit indicates whether a General Call or START byte command is to be performed by the DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0
	SPECIAL     = false;              // This bit indicates whether software performs a Device-ID or General Call or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1: perform special I2C command as specified in Device_ID or GC_OR_START bit Reset value: 0x0
 }

 // I2C0 I2C Target Address Register This register is 12 bits wide, and bits 31:12 are reserved. This register can be written to only when IC_ENABLE[0] is set to 0. Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any write to this register if DW_apb_i2c is enabled as an I2C slave only.
 register IC_TAR_t I2C0_IC_TAR at 0x40044004;

 type IC_SAR_t {
	IC_SAR = uint10(0);          // The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. Note: The default values cannot be any of the reserved address locations: that is, 0x00 to 0x07, or 0x78 to 0x7f. The correct operation of the device is not guaranteed if you program the IC_SAR or IC_TAR to a reserved value. Refer to <<table_I2C_firstbyte_bit_defs>> for a complete list of these reserved values.
 }

 // I2C0 I2C Slave Address Register
 register IC_SAR_t I2C0_IC_SAR at 0x40044008;

 type IC_DATA_CMD_t {
	DAT             = uint8(0);           // This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the DW_apb_i2c. However, when you read this register, these bits return the value of data received on the DW_apb_i2c interface. Reset value: 0x0
	CMD             = false;              // This bit controls whether a read or a write is performed. This bit does not control the direction when the DW_apb_i2con acts as a slave. It controls only the direction when it acts as a master. When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a 'don't care' because writes to this register are not required. In slave-transmitter mode, a '0' indicates that the data in IC_DATA_CMD is to be transmitted. When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the IC_RAW_INTR_STAT register), unless bit 11 (SPECIAL) in the IC_TAR register has been cleared. If a '1' is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs. Reset value: 0x0
	STOP            = false;              // This bit controls whether a STOP is issued after the byte is sent or received. - 1 - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. - 0 - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. Reset value: 0x0
	RESTART         = false;              // This bit controls whether a RESTART is issued before the byte is sent or received. 1 - If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead. 0 - If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead. Reset value: 0x0
	FIRST_DATA_BYTE = false;              // Indicates the first data byte received after the address phase for receive transfer in Master receiver or Slave receiver mode. Reset value : 0x0 NOTE: In case of APB_DATA_WIDTH=8, 1. The user has to perform two APB Reads to IC_DATA_CMD in order to get status on 11 bit. 2. In order to read the 11 bit, the user has to perform the first data byte read [7:0] (offset 0x10) and then perform the second read [15:8] (offset 0x11) in order to know the status of 11 bit (whether the data received in previous read is a first data byte or not). 3. The 11th bit is an optional read field, user can ignore 2nd byte read [15:8] (offset 0x11) if not interested in FIRST_DATA_BYTE status.
 }

 // I2C0 I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO. The size of the register changes as follows: Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a read command should be written for every byte that is to be received; otherwise the DW_apb_i2c will stop acknowledging.
 register IC_DATA_CMD_t I2C0_IC_DATA_CMD at 0x40044010;

 type IC_SS_SCL_HCNT_t {
	IC_SS_SCL_HCNT = uint16(0);          // This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. NOTE: This register must not be programmed to a value higher than 65525, because DW_apb_i2c uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10.
 }

 // I2C0 Standard Speed I2C Clock SCL High Count Register
 register IC_SS_SCL_HCNT_t I2C0_IC_SS_SCL_HCNT at 0x40044014;

 type IC_SS_SCL_LCNT_t {
	IC_SS_SCL_LCNT = uint16(0);          // This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration' This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of DW_apb_i2c. The lower byte must be programmed first, and then the upper byte is programmed.
 }

 // I2C0 Standard Speed I2C Clock SCL Low Count Register
 register IC_SS_SCL_LCNT_t I2C0_IC_SS_SCL_LCNT at 0x40044018;

 type IC_FS_SCL_HCNT_t {
	IC_FS_SCL_HCNT = uint16(0);          // This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast mode or fast mode plus. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'. This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed.
 }

 // I2C0 Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register
 register IC_FS_SCL_HCNT_t I2C0_IC_FS_SCL_HCNT at 0x4004401c;

 type IC_FS_SCL_LCNT_t {
	IC_FS_SCL_LCNT = uint16(0);          // This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'. This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8.
 }

 // I2C0 Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register
 register IC_FS_SCL_LCNT_t I2C0_IC_FS_SCL_LCNT at 0x40044020;

 type IC_INTR_STAT_t {
	R_RX_UNDER    = false;              // See IC_RAW_INTR_STAT for a detailed description of R_RX_UNDER bit. Reset value: 0x0
	R_RX_OVER     = false;              // See IC_RAW_INTR_STAT for a detailed description of R_RX_OVER bit. Reset value: 0x0
	R_RX_FULL     = false;              // See IC_RAW_INTR_STAT for a detailed description of R_RX_FULL bit. Reset value: 0x0
	R_TX_OVER     = false;              // See IC_RAW_INTR_STAT for a detailed description of R_TX_OVER bit. Reset value: 0x0
	R_TX_EMPTY    = false;              // See IC_RAW_INTR_STAT for a detailed description of R_TX_EMPTY bit. Reset value: 0x0
	R_RD_REQ      = false;              // See IC_RAW_INTR_STAT for a detailed description of R_RD_REQ bit. Reset value: 0x0
	R_TX_ABRT     = false;              // See IC_RAW_INTR_STAT for a detailed description of R_TX_ABRT bit. Reset value: 0x0
	R_RX_DONE     = false;              // See IC_RAW_INTR_STAT for a detailed description of R_RX_DONE bit. Reset value: 0x0
	R_ACTIVITY    = false;              // See IC_RAW_INTR_STAT for a detailed description of R_ACTIVITY bit. Reset value: 0x0
	R_STOP_DET    = false;              // See IC_RAW_INTR_STAT for a detailed description of R_STOP_DET bit. Reset value: 0x0
	R_START_DET   = false;              // See IC_RAW_INTR_STAT for a detailed description of R_START_DET bit. Reset value: 0x0
	R_GEN_CALL    = false;              // See IC_RAW_INTR_STAT for a detailed description of R_GEN_CALL bit. Reset value: 0x0
	R_RESTART_DET = false;              // See IC_RAW_INTR_STAT for a detailed description of R_RESTART_DET bit. Reset value: 0x0
 }

 // I2C0 I2C Interrupt Status Register Each bit in this register has a corresponding mask bit in the IC_INTR_MASK register. These bits are cleared by reading the matching interrupt clear register. The unmasked raw versions of these bits are available in the IC_RAW_INTR_STAT register.
 register IC_INTR_STAT_t I2C0_IC_INTR_STAT at 0x4004402c;

 type IC_INTR_MASK_t {
	M_RX_UNDER    = false;              // This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register. Reset value: 0x1
	M_RX_OVER     = false;              // This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register. Reset value: 0x1
	M_RX_FULL     = false;              // This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register. Reset value: 0x1
	M_TX_OVER     = false;              // This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register. Reset value: 0x1
	M_TX_EMPTY    = false;              // This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register. Reset value: 0x1
	M_RD_REQ      = false;              // This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register. Reset value: 0x1
	M_TX_ABRT     = false;              // This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register. Reset value: 0x1
	M_RX_DONE     = false;              // This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register. Reset value: 0x1
	M_ACTIVITY    = false;              // This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register. Reset value: 0x0
	M_STOP_DET    = false;              // This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register. Reset value: 0x0
	M_START_DET   = false;              // This bit masks the R_START_DET interrupt in IC_INTR_STAT register. Reset value: 0x0
	M_GEN_CALL    = false;              // This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register. Reset value: 0x1
	M_RESTART_DET = false;              // This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register. Reset value: 0x0
 }

 // I2C0 I2C Interrupt Mask Register. These bits mask their corresponding interrupt status bits. This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt.
 register IC_INTR_MASK_t I2C0_IC_INTR_MASK at 0x40044030;

 type IC_RAW_INTR_STAT_t {
	RX_UNDER    = false;              // Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. Reset value: 0x0
	RX_OVER     = false;              // Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and an additional byte is received from an external I2C device. The DW_apb_i2c acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. Note: If bit 9 of the IC_CON register (RX_FIFO_FULL_HLD_CTRL) is programmed to HIGH, then the RX_OVER interrupt never occurs, because the Rx FIFO never overflows. Reset value: 0x0
	RX_FULL     = false;              // Set when the receive buffer reaches or goes above the RX_TL threshold in the IC_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (IC_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the IC_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. Reset value: 0x0
	TX_OVER     = false;              // Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. Reset value: 0x0
	TX_EMPTY    = false;              // The behavior of the TX_EMPTY interrupt status differs based on the TX_EMPTY_CTRL selection in the IC_CON register. - When TX_EMPTY_CTRL = 0: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register. - When TX_EMPTY_CTRL = 1: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register and the transmission of the address/data from the internal shift register for the most recently popped command is completed. It is automatically cleared by hardware when the buffer level goes above the threshold. When IC_ENABLE[0] is set to 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer any activity, then with ic_en=0, this bit is set to 0. Reset value: 0x0.
	RD_REQ      = false;              // This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C master is attempting to read data from DW_apb_i2c. The DW_apb_i2c holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the IC_DATA_CMD register. This bit is set to 0 just after the processor reads the IC_CLR_RD_REQ register. Reset value: 0x0
	TX_ABRT     = false;              // This bit indicates if DW_apb_i2c, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a 'transmit abort'. When this bit is set to 1, the IC_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places. Note: The DW_apb_i2c flushes/resets/empties the TX_FIFO and RX_FIFO whenever there is a transmit abort caused by any of the events tracked by the IC_TX_ABRT_SOURCE register. The FIFOs remains in this flushed state until the register IC_CLR_TX_ABRT is read. Once this read is performed, the Tx FIFO is then ready to accept more data bytes from the APB interface. Reset value: 0x0
	RX_DONE     = false;              // When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. Reset value: 0x0
	ACTIVITY    = false;              // This bit captures DW_apb_i2c activity and stays set until it is cleared. There are four ways to clear it: - Disabling the DW_apb_i2c - Reading the IC_CLR_ACTIVITY register - Reading the IC_CLR_INTR register - System reset Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the DW_apb_i2c module is idle, this bit remains set until cleared, indicating that there was activity on the bus. Reset value: 0x0
	STOP_DET    = false;              // Indicates whether a STOP condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode. In Slave Mode: - If IC_CON[7]=1'b1 (STOP_DET_IFADDRESSED), the STOP_DET interrupt will be issued only if slave is addressed. Note: During a general call address, this slave does not issue a STOP_DET interrupt if STOP_DET_IF_ADDRESSED=1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR). - If IC_CON[7]=1'b0 (STOP_DET_IFADDRESSED), the STOP_DET interrupt is issued irrespective of whether it is being addressed. In Master Mode: - If IC_CON[10]=1'b1 (STOP_DET_IF_MASTER_ACTIVE),the STOP_DET interrupt will be issued only if Master is active. - If IC_CON[10]=1'b0 (STOP_DET_IFADDRESSED),the STOP_DET interrupt will be issued irrespective of whether master is active or not. Reset value: 0x0
	START_DET   = false;              // Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode. Reset value: 0x0
	GEN_CALL    = false;              // Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling DW_apb_i2c or when the CPU reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores the received data in the Rx buffer. Reset value: 0x0
	RESTART_DET = false;              // Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed. Enabled only when IC_SLV_RESTART_DET_EN=1. Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt. Reset value: 0x0
 }

 // I2C0 I2C Raw Interrupt Status Register Unlike the IC_INTR_STAT register, these bits are not masked so they always show the true status of the DW_apb_i2c.
 register IC_RAW_INTR_STAT_t I2C0_IC_RAW_INTR_STAT at 0x40044034;

 type IC_RX_TL_t {
	RX_TL = uint8(0);           // Receive FIFO Threshold Level. Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 255 sets the threshold for 256 entries.
 }

 // I2C0 I2C Receive FIFO Threshold Register
 register IC_RX_TL_t I2C0_IC_RX_TL at 0x40044038;

 type IC_TX_TL_t {
	TX_TL = uint8(0);           // Transmit FIFO Threshold Level. Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 255 sets the threshold for 255 entries.
 }

 // I2C0 I2C Transmit FIFO Threshold Register
 register IC_TX_TL_t I2C0_IC_TX_TL at 0x4004403c;

 type IC_CLR_INTR_t {
	CLR_INTR = false;              // Read this register to clear the combined interrupt, all individual interrupts, and the IC_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE. Reset value: 0x0
 }

 // I2C0 Clear Combined and Individual Interrupt Register
 register IC_CLR_INTR_t I2C0_IC_CLR_INTR at 0x40044040;

 type IC_CLR_RX_UNDER_t {
	CLR_RX_UNDER = false;              // Read this register to clear the RX_UNDER interrupt (bit 0) of the IC_RAW_INTR_STAT register. Reset value: 0x0
 }

 // I2C0 Clear RX_UNDER Interrupt Register
 register IC_CLR_RX_UNDER_t I2C0_IC_CLR_RX_UNDER at 0x40044044;

 type IC_CLR_RX_OVER_t {
	CLR_RX_OVER = false;              // Read this register to clear the RX_OVER interrupt (bit 1) of the IC_RAW_INTR_STAT register. Reset value: 0x0
 }

 // I2C0 Clear RX_OVER Interrupt Register
 register IC_CLR_RX_OVER_t I2C0_IC_CLR_RX_OVER at 0x40044048;

 type IC_CLR_TX_OVER_t {
	CLR_TX_OVER = false;              // Read this register to clear the TX_OVER interrupt (bit 3) of the IC_RAW_INTR_STAT register. Reset value: 0x0
 }

 // I2C0 Clear TX_OVER Interrupt Register
 register IC_CLR_TX_OVER_t I2C0_IC_CLR_TX_OVER at 0x4004404c;

 type IC_CLR_RD_REQ_t {
	CLR_RD_REQ = false;              // Read this register to clear the RD_REQ interrupt (bit 5) of the IC_RAW_INTR_STAT register. Reset value: 0x0
 }

 // I2C0 Clear RD_REQ Interrupt Register
 register IC_CLR_RD_REQ_t I2C0_IC_CLR_RD_REQ at 0x40044050;

 type IC_CLR_TX_ABRT_t {
	CLR_TX_ABRT = false;              // Read this register to clear the TX_ABRT interrupt (bit 6) of the IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE. Reset value: 0x0
 }

 // I2C0 Clear TX_ABRT Interrupt Register
 register IC_CLR_TX_ABRT_t I2C0_IC_CLR_TX_ABRT at 0x40044054;

 type IC_CLR_RX_DONE_t {
	CLR_RX_DONE = false;              // Read this register to clear the RX_DONE interrupt (bit 7) of the IC_RAW_INTR_STAT register. Reset value: 0x0
 }

 // I2C0 Clear RX_DONE Interrupt Register
 register IC_CLR_RX_DONE_t I2C0_IC_CLR_RX_DONE at 0x40044058;

 type IC_CLR_ACTIVITY_t {
	CLR_ACTIVITY = false;              // Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register. Reset value: 0x0
 }

 // I2C0 Clear ACTIVITY Interrupt Register
 register IC_CLR_ACTIVITY_t I2C0_IC_CLR_ACTIVITY at 0x4004405c;

 type IC_CLR_STOP_DET_t {
	CLR_STOP_DET = false;              // Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register. Reset value: 0x0
 }

 // I2C0 Clear STOP_DET Interrupt Register
 register IC_CLR_STOP_DET_t I2C0_IC_CLR_STOP_DET at 0x40044060;

 type IC_CLR_START_DET_t {
	CLR_START_DET = false;              // Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register. Reset value: 0x0
 }

 // I2C0 Clear START_DET Interrupt Register
 register IC_CLR_START_DET_t I2C0_IC_CLR_START_DET at 0x40044064;

 type IC_CLR_GEN_CALL_t {
	CLR_GEN_CALL = false;              // Read this register to clear the GEN_CALL interrupt (bit 11) of IC_RAW_INTR_STAT register. Reset value: 0x0
 }

 // I2C0 Clear GEN_CALL Interrupt Register
 register IC_CLR_GEN_CALL_t I2C0_IC_CLR_GEN_CALL at 0x40044068;

 type IC_ENABLE_t {
	ENABLE       = false;              // Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable DW_apb_i2c while it is active. However, it is important that care be taken to ensure that DW_apb_i2c is disabled properly. A recommended procedure is described in 'Disabling DW_apb_i2c'. When DW_apb_i2c is disabled, the following occurs: - The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT register are still active until DW_apb_i2c goes into IDLE state. If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the DW_apb_i2c stops the current transfer at the end of the current byte and does not acknowledge the transfer. In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to asynchronous (1), there is a two ic_clk delay when enabling or disabling the DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c, refer to 'Disabling DW_apb_i2c' Reset value: 0x0
	ABORT        = false;              // When set, the controller initiates the transfer abort. - 0: ABORT not initiated or ABORT done - 1: ABORT operation in progress The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation. For a detailed description on how to abort I2C transfers, refer to 'Aborting I2C Transfers'. Reset value: 0x0
	TX_CMD_BLOCK = false;              // In Master mode: - 1'b1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit. - 1'b0: The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. Note: To block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value: IC_TX_CMD_BLOCK_DEFAULT
 }

 // I2C0 I2C Enable Register
 register IC_ENABLE_t I2C0_IC_ENABLE at 0x4004406c;

 type IC_STATUS_t {
	ACTIVITY     = false;              // I2C Activity Status. Reset value: 0x0
	TFNF         = false;              // Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full. - 0: Transmit FIFO is full - 1: Transmit FIFO is not full Reset value: 0x1
	TFE          = false;              // Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt. - 0: Transmit FIFO is not empty - 1: Transmit FIFO is empty Reset value: 0x1
	RFNE         = false;              // Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty. - 0: Receive FIFO is empty - 1: Receive FIFO is not empty Reset value: 0x0
	RFF          = false;              // Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared. - 0: Receive FIFO is not full - 1: Receive FIFO is full Reset value: 0x0
	MST_ACTIVITY = false;              // Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Master FSM is in IDLE state so the Master part of DW_apb_i2c is not Active - 1: Master FSM is not in IDLE state so the Master part of DW_apb_i2c is Active Note: IC_STATUS[0]-that is, ACTIVITY bit-is the OR of SLV_ACTIVITY and MST_ACTIVITY bits. Reset value: 0x0
	SLV_ACTIVITY = false;              // Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Slave FSM is in IDLE state so the Slave part of DW_apb_i2c is not Active - 1: Slave FSM is not in IDLE state so the Slave part of DW_apb_i2c is Active Reset value: 0x0
 }

 // I2C0 I2C Status Register This is a read-only register used to indicate the current transfer status and FIFO status. The status register may be read at any time. None of the bits in this register request an interrupt. When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state machines goes to idle and ic_en=0: - Bits 5 and 6 are set to 0
 register IC_STATUS_t I2C0_IC_STATUS at 0x40044070;

 type IC_TXFLR_t {
	TXFLR = uint5(0);           // Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO. Reset value: 0x0
 }

 // I2C0 I2C Transmit FIFO Level Register This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is disabled - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO.
 register IC_TXFLR_t I2C0_IC_TXFLR at 0x40044074;

 type IC_RXFLR_t {
	RXFLR = uint5(0);           // Receive FIFO Level. Contains the number of valid data entries in the receive FIFO. Reset value: 0x0
 }

 // I2C0 I2C Receive FIFO Level Register This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever: - The I2C is disabled - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO.
 register IC_RXFLR_t I2C0_IC_RXFLR at 0x40044078;

 type IC_SDA_HOLD_t {
	IC_SDA_TX_HOLD = uint16(0);          // Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a transmitter. Reset value: IC_DEFAULT_SDA_HOLD[15:0].
	IC_SDA_RX_HOLD = uint8(0);           // Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a receiver. Reset value: IC_DEFAULT_SDA_HOLD[23:16].
 }

 // I2C0 I2C SDA Hold Time Length Register The bits [15:0] of this register are used to control the hold time of SDA during transmit in both slave and master mode (after SCL goes from HIGH to LOW). The bits [23:16] of this register are used to extend the SDA transition (if any) whenever SCL is HIGH in the receiver in either master or slave mode. Writes to this register succeed only when IC_ENABLE[0]=0. The values in this register are in units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode (one cycle in master mode, seven cycles in slave mode) for the value to be implemented. The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part of scl. Therefore the programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl period measured in ic_clk cycles.
 register IC_SDA_HOLD_t I2C0_IC_SDA_HOLD at 0x4004407c;

 type IC_TX_ABRT_SOURCE_t {
	ABRT_7B_ADDR_NOACK   = false;              // This field indicates that the Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
	ABRT_10ADDR1_NOACK   = false;              // This field indicates that the Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
	ABRT_10ADDR2_NOACK   = false;              // This field indicates that the Master is in 10-bit address mode and that the second address byte of the 10-bit address was not acknowledged by any slave. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
	ABRT_TXDATA_NOACK    = false;              // This field indicates the master-mode only bit. When the master receives an acknowledgement for the address, but when it sends data byte(s) following the address, it did not receive an acknowledge from the remote slave(s). Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter
	ABRT_GCALL_NOACK     = false;              // This field indicates that DW_apb_i2c in master mode has sent a General Call and no slave on the bus acknowledged the General Call. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter
	ABRT_GCALL_READ      = false;              // This field indicates that DW_apb_i2c in the master mode has sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1). Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter
	ABRT_HS_ACKDET       = false;              // This field indicates that the Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior). Reset value: 0x0 Role of DW_apb_i2c: Master
	ABRT_SBYTE_ACKDET    = false;              // This field indicates that the Master has sent a START Byte and the START Byte was acknowledged (wrong behavior). Reset value: 0x0 Role of DW_apb_i2c: Master
	ABRT_HS_NORSTRT      = false;              // This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to use the master to transfer data in High Speed mode. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
	ABRT_SBYTE_NORSTRT   = false;              // To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets reasserted. When this field is set to 1, the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to send a START Byte. Reset value: 0x0 Role of DW_apb_i2c: Master
	ABRT_10B_RD_NORSTRT  = false;              // This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the master sends a read command in 10-bit addressing mode. Reset value: 0x0 Role of DW_apb_i2c: Master-Receiver
	ABRT_MASTER_DIS      = false;              // This field indicates that the User tries to initiate a Master operation with the Master mode disabled. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter or Master-Receiver
	ARB_LOST             = false;              // This field specifies that the Master has lost arbitration, or if IC_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter
	ABRT_SLVFLUSH_TXFIFO = false;              // This field specifies that the Slave has received a read command and some data exists in the TX FIFO, so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO. Reset value: 0x0 Role of DW_apb_i2c: Slave-Transmitter
	ABRT_SLV_ARBLOST     = false;              // This field indicates that a Slave has lost the bus while transmitting data to a remote master. IC_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never 'owns' the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then DW_apb_i2c no longer own the bus. Reset value: 0x0 Role of DW_apb_i2c: Slave-Transmitter
	ABRT_SLVRD_INTX      = false;              // 1: When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of IC_DATA_CMD register. Reset value: 0x0 Role of DW_apb_i2c: Slave-Transmitter
	ABRT_USER_ABRT       = false;              // This is a master-mode-only bit. Master has detected the transfer abort (IC_ENABLE[1]) Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter
	_res1                = uint6(0);           // Reserved, 6 bits
	TX_FLUSH_CNT         = uint9(0);           // This field indicates the number of Tx FIFO Data Commands which are flushed due to TX_ABRT interrupt. It is cleared whenever I2C is disabled. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter
 }

 // I2C0 I2C Transmit Abort Source Register This register has 32 bits that indicate the source of the TX_ABRT bit. Except for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the IC_CLR_INTR register is read. To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, Bit 9 clears for one cycle and is then re-asserted.
 register IC_TX_ABRT_SOURCE_t I2C0_IC_TX_ABRT_SOURCE at 0x40044080;

 type IC_SLV_DATA_NACK_ONLY_t {
	NACK = false;              // Generate NACK. This NACK generation only occurs when DW_apb_i2c is a slave-receiver. If this register is set to a value of 1, it can only generate a NACK after a data byte is received; hence, the data transfer is aborted and the data received is not pushed to the receive buffer. When the register is set to a value of 0, it generates NACK/ACK, depending on normal criteria. - 1: generate NACK after data byte received - 0: generate NACK/ACK normally Reset value: 0x0
 }

 // I2C0 Generate Slave Data NACK Register The register is used to generate a NACK for the data part of a transfer when DW_apb_i2c is acting as a slave-receiver. This register only exists when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this parameter disabled, this register does not exist and writing to the register's address has no effect. A write can occur on this register if both of the following conditions are met: - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) - Slave part is inactive (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register read-back location for the internal slv_activity signal; the user should poll this before writing the ic_slv_data_nack_only bit.
 register IC_SLV_DATA_NACK_ONLY_t I2C0_IC_SLV_DATA_NACK_ONLY at 0x40044084;

 type IC_DMA_CR_t {
	RDMAE = false;              // Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. Reset value: 0x0
	TDMAE = false;              // Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. Reset value: 0x0
 }

 // I2C0 DMA Control Register The register is used to enable the DMA Controller interface operation. There is a separate bit for transmit and receive. This can be programmed regardless of the state of IC_ENABLE.
 register IC_DMA_CR_t I2C0_IC_DMA_CR at 0x40044088;

 type IC_DMA_TDLR_t {
	DMATDL = uint4(0);           // Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1. Reset value: 0x0
 }

 // I2C0 DMA Transmit Data Level Register
 register IC_DMA_TDLR_t I2C0_IC_DMA_TDLR at 0x4004408c;

 type IC_DMA_RDLR_t {
	DMARDL = uint4(0);           // Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO. Reset value: 0x0
 }

 // I2C0 I2C Receive Data Level Register
 register IC_DMA_RDLR_t I2C0_IC_DMA_RDLR at 0x40044090;

 type IC_SDA_SETUP_t {
	SDA_SETUP = uint8(0);           // SDA Setup. It is recommended that if the required delay is 1000ns, then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11. IC_SDA_SETUP must be programmed with a minimum value of 2.
 }

 // I2C0 I2C SDA Setup Register This register controls the amount of time delay (in terms of number of ic_clk clock periods) introduced in the rising edge of SCL - relative to SDA changing - when DW_apb_i2c services a read request in a slave-transmitter operation. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2. Writes to this register succeed only when IC_ENABLE[0] = 0. Note: The length of setup time is calculated using [(IC_SDA_SETUP - 1) * (ic_clk_period)], so if the user requires 10 ic_clk periods of setup time, they should program a value of 11. The IC_SDA_SETUP register is only used by the DW_apb_i2c when operating as a slave transmitter.
 register IC_SDA_SETUP_t I2C0_IC_SDA_SETUP at 0x40044094;

 type IC_ACK_GENERAL_CALL_t {
	ACK_GEN_CALL = false;              // ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with a NACK (by negating ic_data_oe).
 }

 // I2C0 I2C ACK General Call Register The register controls whether DW_apb_i2c responds with a ACK or NACK when it receives an I2C General Call address. This register is applicable only when the DW_apb_i2c is in slave mode.
 register IC_ACK_GENERAL_CALL_t I2C0_IC_ACK_GENERAL_CALL at 0x40044098;

 type IC_ENABLE_STATUS_t {
	IC_EN                   = false;              // ic_en Status. This bit always reflects the value driven on the output port ic_en. - When read as 1, DW_apb_i2c is deemed to be in an enabled state. - When read as 0, DW_apb_i2c is deemed completely inactive. Note: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1). Reset value: 0x0
	SLV_DISABLED_WHILE_BUSY = false;              // Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting bit 0 of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while: (a) DW_apb_i2c is receiving the address byte of the Slave-Transmitter operation from a remote master; OR, (b) address and data bytes of the Slave-Receiver operation from a remote master. When read as 1, DW_apb_i2c is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in DW_apb_i2c (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect. Note: If the remote I2C master terminates the transfer with a STOP condition before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit will also be set to 1. When read as 0, DW_apb_i2c is deemed to have been disabled when there is master activity, or when the I2C bus is idle. Note: The CPU can safely read this bit when IC_EN (bit 0) is read as 0. Reset value: 0x0
	SLV_RX_DATA_LOST        = false;              // Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting bit 0 of IC_ENABLE from 1 to 0. When read as 1, DW_apb_i2c is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK. Note: If the remote I2C master terminates the transfer with a STOP condition before the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit is also set to 1. When read as 0, DW_apb_i2c is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer. Note: The CPU can safely read this bit when IC_EN (bit 0) is read as 0. Reset value: 0x0
 }

 // I2C0 I2C Enable Status Register The register is used to report the DW_apb_i2c hardware status when the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is disabled. If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced to 1. If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is read as '0'. Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read as 0 because disabling the DW_apb_i2c depends on I2C bus activities.
 register IC_ENABLE_STATUS_t I2C0_IC_ENABLE_STATUS at 0x4004409c;

 type IC_FS_SPKLEN_t {
	IC_FS_SPKLEN = uint8(0);           // This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. or more information, refer to 'Spike Suppression'.
 }

 // I2C0 I2C SS, FS or FM+ spike suppression limit This register is used to store the duration, measured in ic_clk cycles, of the longest spike that is filtered out by the spike suppression logic when the component is operating in SS, FS or FM+ modes. The relevant I2C requirement is tSP (table 4) as detailed in the I2C Bus Specification. This register must be programmed with a minimum value of 1.
 register IC_FS_SPKLEN_t I2C0_IC_FS_SPKLEN at 0x400440a0;

 type IC_CLR_RESTART_DET_t {
	CLR_RESTART_DET = false;              // Read this register to clear the RESTART_DET interrupt (bit 12) of IC_RAW_INTR_STAT register. Reset value: 0x0
 }

 // I2C0 Clear RESTART_DET Interrupt Register
 register IC_CLR_RESTART_DET_t I2C0_IC_CLR_RESTART_DET at 0x400440a8;

 type IC_COMP_PARAM_1_t {
	APB_DATA_WIDTH     = uint2(0);           // APB data bus width is 32 bits
	MAX_SPEED_MODE     = uint2(0);           // MAX SPEED MODE = FAST MODE
	HC_COUNT_VALUES    = false;              // Programmable count values for each mode.
	INTR_IO            = false;              // COMBINED Interrupt outputs
	HAS_DMA            = false;              // DMA handshaking signals are enabled
	ADD_ENCODED_PARAMS = false;              // Encoded parameters not visible
	RX_BUFFER_DEPTH    = uint8(0);           // RX Buffer Depth = 16
	TX_BUFFER_DEPTH    = uint8(0);           // TX Buffer Depth = 16
 }

 // I2C0 Component Parameter Register 1 Note This register is not implemented and therefore reads as 0. If it was implemented it would be a constant read-only register that contains encoded information about the component's parameter settings. Fields shown below are the settings for those parameters
 register IC_COMP_PARAM_1_t I2C0_IC_COMP_PARAM_1 at 0x400440f4;

 type IC_COMP_VERSION_t {
	IC_COMP_VERSION = uint32(0);          // 
 }

 // I2C0 I2C Component Version Register
 register IC_COMP_VERSION_t I2C0_IC_COMP_VERSION at 0x400440f8;

 type IC_COMP_TYPE_t {
	IC_COMP_TYPE = uint32(0);          // Designware Component Type number = 0x44_57_01_40. This assigned unique hex value is constant and is derived from the two ASCII letters 'DW' followed by a 16-bit unsigned number.
 }

 // I2C0 I2C Component Type Register
 register IC_COMP_TYPE_t I2C0_IC_COMP_TYPE at 0x400440fc;


/* Types and registers for I2C1  */

 // I2C1 I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are read only.
 register IC_CON_t I2C1_IC_CON at 0x40048000;

 // I2C1 I2C Target Address Register This register is 12 bits wide, and bits 31:12 are reserved. This register can be written to only when IC_ENABLE[0] is set to 0. Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any write to this register if DW_apb_i2c is enabled as an I2C slave only.
 register IC_TAR_t I2C1_IC_TAR at 0x40048004;

 // I2C1 I2C Slave Address Register
 register IC_SAR_t I2C1_IC_SAR at 0x40048008;

 // I2C1 I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO. The size of the register changes as follows: Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a read command should be written for every byte that is to be received; otherwise the DW_apb_i2c will stop acknowledging.
 register IC_DATA_CMD_t I2C1_IC_DATA_CMD at 0x40048010;

 // I2C1 Standard Speed I2C Clock SCL High Count Register
 register IC_SS_SCL_HCNT_t I2C1_IC_SS_SCL_HCNT at 0x40048014;

 // I2C1 Standard Speed I2C Clock SCL Low Count Register
 register IC_SS_SCL_LCNT_t I2C1_IC_SS_SCL_LCNT at 0x40048018;

 // I2C1 Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register
 register IC_FS_SCL_HCNT_t I2C1_IC_FS_SCL_HCNT at 0x4004801c;

 // I2C1 Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register
 register IC_FS_SCL_LCNT_t I2C1_IC_FS_SCL_LCNT at 0x40048020;

 // I2C1 I2C Interrupt Status Register Each bit in this register has a corresponding mask bit in the IC_INTR_MASK register. These bits are cleared by reading the matching interrupt clear register. The unmasked raw versions of these bits are available in the IC_RAW_INTR_STAT register.
 register IC_INTR_STAT_t I2C1_IC_INTR_STAT at 0x4004802c;

 // I2C1 I2C Interrupt Mask Register. These bits mask their corresponding interrupt status bits. This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt.
 register IC_INTR_MASK_t I2C1_IC_INTR_MASK at 0x40048030;

 // I2C1 I2C Raw Interrupt Status Register Unlike the IC_INTR_STAT register, these bits are not masked so they always show the true status of the DW_apb_i2c.
 register IC_RAW_INTR_STAT_t I2C1_IC_RAW_INTR_STAT at 0x40048034;

 // I2C1 I2C Receive FIFO Threshold Register
 register IC_RX_TL_t I2C1_IC_RX_TL at 0x40048038;

 // I2C1 I2C Transmit FIFO Threshold Register
 register IC_TX_TL_t I2C1_IC_TX_TL at 0x4004803c;

 // I2C1 Clear Combined and Individual Interrupt Register
 register IC_CLR_INTR_t I2C1_IC_CLR_INTR at 0x40048040;

 // I2C1 Clear RX_UNDER Interrupt Register
 register IC_CLR_RX_UNDER_t I2C1_IC_CLR_RX_UNDER at 0x40048044;

 // I2C1 Clear RX_OVER Interrupt Register
 register IC_CLR_RX_OVER_t I2C1_IC_CLR_RX_OVER at 0x40048048;

 // I2C1 Clear TX_OVER Interrupt Register
 register IC_CLR_TX_OVER_t I2C1_IC_CLR_TX_OVER at 0x4004804c;

 // I2C1 Clear RD_REQ Interrupt Register
 register IC_CLR_RD_REQ_t I2C1_IC_CLR_RD_REQ at 0x40048050;

 // I2C1 Clear TX_ABRT Interrupt Register
 register IC_CLR_TX_ABRT_t I2C1_IC_CLR_TX_ABRT at 0x40048054;

 // I2C1 Clear RX_DONE Interrupt Register
 register IC_CLR_RX_DONE_t I2C1_IC_CLR_RX_DONE at 0x40048058;

 // I2C1 Clear ACTIVITY Interrupt Register
 register IC_CLR_ACTIVITY_t I2C1_IC_CLR_ACTIVITY at 0x4004805c;

 // I2C1 Clear STOP_DET Interrupt Register
 register IC_CLR_STOP_DET_t I2C1_IC_CLR_STOP_DET at 0x40048060;

 // I2C1 Clear START_DET Interrupt Register
 register IC_CLR_START_DET_t I2C1_IC_CLR_START_DET at 0x40048064;

 // I2C1 Clear GEN_CALL Interrupt Register
 register IC_CLR_GEN_CALL_t I2C1_IC_CLR_GEN_CALL at 0x40048068;

 // I2C1 I2C Enable Register
 register IC_ENABLE_t I2C1_IC_ENABLE at 0x4004806c;

 // I2C1 I2C Status Register This is a read-only register used to indicate the current transfer status and FIFO status. The status register may be read at any time. None of the bits in this register request an interrupt. When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state machines goes to idle and ic_en=0: - Bits 5 and 6 are set to 0
 register IC_STATUS_t I2C1_IC_STATUS at 0x40048070;

 // I2C1 I2C Transmit FIFO Level Register This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is disabled - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO.
 register IC_TXFLR_t I2C1_IC_TXFLR at 0x40048074;

 // I2C1 I2C Receive FIFO Level Register This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever: - The I2C is disabled - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO.
 register IC_RXFLR_t I2C1_IC_RXFLR at 0x40048078;

 // I2C1 I2C SDA Hold Time Length Register The bits [15:0] of this register are used to control the hold time of SDA during transmit in both slave and master mode (after SCL goes from HIGH to LOW). The bits [23:16] of this register are used to extend the SDA transition (if any) whenever SCL is HIGH in the receiver in either master or slave mode. Writes to this register succeed only when IC_ENABLE[0]=0. The values in this register are in units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode (one cycle in master mode, seven cycles in slave mode) for the value to be implemented. The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part of scl. Therefore the programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl period measured in ic_clk cycles.
 register IC_SDA_HOLD_t I2C1_IC_SDA_HOLD at 0x4004807c;

 // I2C1 I2C Transmit Abort Source Register This register has 32 bits that indicate the source of the TX_ABRT bit. Except for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the IC_CLR_INTR register is read. To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, Bit 9 clears for one cycle and is then re-asserted.
 register IC_TX_ABRT_SOURCE_t I2C1_IC_TX_ABRT_SOURCE at 0x40048080;

 // I2C1 Generate Slave Data NACK Register The register is used to generate a NACK for the data part of a transfer when DW_apb_i2c is acting as a slave-receiver. This register only exists when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this parameter disabled, this register does not exist and writing to the register's address has no effect. A write can occur on this register if both of the following conditions are met: - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) - Slave part is inactive (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register read-back location for the internal slv_activity signal; the user should poll this before writing the ic_slv_data_nack_only bit.
 register IC_SLV_DATA_NACK_ONLY_t I2C1_IC_SLV_DATA_NACK_ONLY at 0x40048084;

 // I2C1 DMA Control Register The register is used to enable the DMA Controller interface operation. There is a separate bit for transmit and receive. This can be programmed regardless of the state of IC_ENABLE.
 register IC_DMA_CR_t I2C1_IC_DMA_CR at 0x40048088;

 // I2C1 DMA Transmit Data Level Register
 register IC_DMA_TDLR_t I2C1_IC_DMA_TDLR at 0x4004808c;

 // I2C1 I2C Receive Data Level Register
 register IC_DMA_RDLR_t I2C1_IC_DMA_RDLR at 0x40048090;

 // I2C1 I2C SDA Setup Register This register controls the amount of time delay (in terms of number of ic_clk clock periods) introduced in the rising edge of SCL - relative to SDA changing - when DW_apb_i2c services a read request in a slave-transmitter operation. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2. Writes to this register succeed only when IC_ENABLE[0] = 0. Note: The length of setup time is calculated using [(IC_SDA_SETUP - 1) * (ic_clk_period)], so if the user requires 10 ic_clk periods of setup time, they should program a value of 11. The IC_SDA_SETUP register is only used by the DW_apb_i2c when operating as a slave transmitter.
 register IC_SDA_SETUP_t I2C1_IC_SDA_SETUP at 0x40048094;

 // I2C1 I2C ACK General Call Register The register controls whether DW_apb_i2c responds with a ACK or NACK when it receives an I2C General Call address. This register is applicable only when the DW_apb_i2c is in slave mode.
 register IC_ACK_GENERAL_CALL_t I2C1_IC_ACK_GENERAL_CALL at 0x40048098;

 // I2C1 I2C Enable Status Register The register is used to report the DW_apb_i2c hardware status when the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is disabled. If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced to 1. If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is read as '0'. Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read as 0 because disabling the DW_apb_i2c depends on I2C bus activities.
 register IC_ENABLE_STATUS_t I2C1_IC_ENABLE_STATUS at 0x4004809c;

 // I2C1 I2C SS, FS or FM+ spike suppression limit This register is used to store the duration, measured in ic_clk cycles, of the longest spike that is filtered out by the spike suppression logic when the component is operating in SS, FS or FM+ modes. The relevant I2C requirement is tSP (table 4) as detailed in the I2C Bus Specification. This register must be programmed with a minimum value of 1.
 register IC_FS_SPKLEN_t I2C1_IC_FS_SPKLEN at 0x400480a0;

 // I2C1 Clear RESTART_DET Interrupt Register
 register IC_CLR_RESTART_DET_t I2C1_IC_CLR_RESTART_DET at 0x400480a8;

 // I2C1 Component Parameter Register 1 Note This register is not implemented and therefore reads as 0. If it was implemented it would be a constant read-only register that contains encoded information about the component's parameter settings. Fields shown below are the settings for those parameters
 register IC_COMP_PARAM_1_t I2C1_IC_COMP_PARAM_1 at 0x400480f4;

 // I2C1 I2C Component Version Register
 register IC_COMP_VERSION_t I2C1_IC_COMP_VERSION at 0x400480f8;

 // I2C1 I2C Component Type Register
 register IC_COMP_TYPE_t I2C1_IC_COMP_TYPE at 0x400480fc;


/* Types and registers for SPI0  */

 type SSPCR0_t {
	DSS = uint4(0);           // Data Size Select: 0000 Reserved, undefined operation. 0001 Reserved, undefined operation. 0010 Reserved, undefined operation. 0011 4-bit data. 0100 5-bit data. 0101 6-bit data. 0110 7-bit data. 0111 8-bit data. 1000 9-bit data. 1001 10-bit data. 1010 11-bit data. 1011 12-bit data. 1100 13-bit data. 1101 14-bit data. 1110 15-bit data. 1111 16-bit data.
	FRF = uint2(0);           // Frame format: 00 Motorola SPI frame format. 01 TI synchronous serial frame format. 10 National Microwire frame format. 11 Reserved, undefined operation.
	SPO = false;              // SSPCLKOUT polarity, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10.
	SPH = false;              // SSPCLKOUT phase, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10.
	SCR = uint8(0);           // Serial clock rate. The value SCR is used to generate the transmit and receive bit rate of the PrimeCell SSP. The bit rate is: F SSPCLK CPSDVSR x (1+SCR) where CPSDVSR is an even value from 2-254, programmed through the SSPCPSR register and SCR is a value from 0-255.
 }

 // SPI0 Control register 0, SSPCR0 on page 3-4
 register SSPCR0_t SPI0_SSPCR0 at 0x4003c000;

 type SSPCR1_t {
	LBM = false;              // Loop back mode: 0 Normal serial port operation enabled. 1 Output of transmit serial shifter is connected to input of receive serial shifter internally.
	SSE = false;              // Synchronous serial port enable: 0 SSP operation disabled. 1 SSP operation enabled.
	MS  = false;              // Master or slave mode select. This bit can be modified only when the PrimeCell SSP is disabled, SSE=0: 0 Device configured as master, default. 1 Device configured as slave.
	SOD = false;              // Slave-mode output disable. This bit is relevant only in the slave mode, MS=1. In multiple-slave systems, it is possible for an PrimeCell SSP master to broadcast a message to all slaves in the system while ensuring that only one slave drives data onto its serial output line. In such systems the RXD lines from multiple slaves could be tied together. To operate in such systems, the SOD bit can be set if the PrimeCell SSP slave is not supposed to drive the SSPTXD line: 0 SSP can drive the SSPTXD output in slave mode. 1 SSP must not drive the SSPTXD output in slave mode.
 }

 // SPI0 Control register 1, SSPCR1 on page 3-5
 register SSPCR1_t SPI0_SSPCR1 at 0x4003c004;

 type SSPDR_t {
	DATA = uint16(0);          // Transmit/Receive FIFO: Read Receive FIFO. Write Transmit FIFO. You must right-justify data when the PrimeCell SSP is programmed for a data size that is less than 16 bits. Unused bits at the top are ignored by transmit logic. The receive logic automatically right-justifies.
 }

 // SPI0 Data register, SSPDR on page 3-6
 register SSPDR_t SPI0_SSPDR at 0x4003c008;

 type SSPSR_t {
	TFE = false;              // Transmit FIFO empty, RO: 0 Transmit FIFO is not empty. 1 Transmit FIFO is empty.
	TNF = false;              // Transmit FIFO not full, RO: 0 Transmit FIFO is full. 1 Transmit FIFO is not full.
	RNE = false;              // Receive FIFO not empty, RO: 0 Receive FIFO is empty. 1 Receive FIFO is not empty.
	RFF = false;              // Receive FIFO full, RO: 0 Receive FIFO is not full. 1 Receive FIFO is full.
	BSY = false;              // PrimeCell SSP busy flag, RO: 0 SSP is idle. 1 SSP is currently transmitting and/or receiving a frame or the transmit FIFO is not empty.
 }

 // SPI0 Status register, SSPSR on page 3-7
 register SSPSR_t SPI0_SSPSR at 0x4003c00c;

 type SSPCPSR_t {
	CPSDVSR = uint8(0);           // Clock prescale divisor. Must be an even number from 2-254, depending on the frequency of SSPCLK. The least significant bit always returns zero on reads.
 }

 // SPI0 Clock prescale register, SSPCPSR on page 3-8
 register SSPCPSR_t SPI0_SSPCPSR at 0x4003c010;

 type SSPIMSC_t {
	RORIM = false;              // Receive overrun interrupt mask: 0 Receive FIFO written to while full condition interrupt is masked. 1 Receive FIFO written to while full condition interrupt is not masked.
	RTIM  = false;              // Receive timeout interrupt mask: 0 Receive FIFO not empty and no read prior to timeout period interrupt is masked. 1 Receive FIFO not empty and no read prior to timeout period interrupt is not masked.
	RXIM  = false;              // Receive FIFO interrupt mask: 0 Receive FIFO half full or less condition interrupt is masked. 1 Receive FIFO half full or less condition interrupt is not masked.
	TXIM  = false;              // Transmit FIFO interrupt mask: 0 Transmit FIFO half empty or less condition interrupt is masked. 1 Transmit FIFO half empty or less condition interrupt is not masked.
 }

 // SPI0 Interrupt mask set or clear register, SSPIMSC on page 3-9
 register SSPIMSC_t SPI0_SSPIMSC at 0x4003c014;

 type SSPRIS_t {
	RORRIS = false;              // Gives the raw interrupt state, prior to masking, of the SSPRORINTR interrupt
	RTRIS  = false;              // Gives the raw interrupt state, prior to masking, of the SSPRTINTR interrupt
	RXRIS  = false;              // Gives the raw interrupt state, prior to masking, of the SSPRXINTR interrupt
	TXRIS  = false;              // Gives the raw interrupt state, prior to masking, of the SSPTXINTR interrupt
 }

 // SPI0 Raw interrupt status register, SSPRIS on page 3-10
 register SSPRIS_t SPI0_SSPRIS at 0x4003c018;

 type SSPMIS_t {
	RORMIS = false;              // Gives the receive over run masked interrupt status, after masking, of the SSPRORINTR interrupt
	RTMIS  = false;              // Gives the receive timeout masked interrupt state, after masking, of the SSPRTINTR interrupt
	RXMIS  = false;              // Gives the receive FIFO masked interrupt state, after masking, of the SSPRXINTR interrupt
	TXMIS  = false;              // Gives the transmit FIFO masked interrupt state, after masking, of the SSPTXINTR interrupt
 }

 // SPI0 Masked interrupt status register, SSPMIS on page 3-11
 register SSPMIS_t SPI0_SSPMIS at 0x4003c01c;

 type SSPICR_t {
	RORIC = false;              // Clears the SSPRORINTR interrupt
	RTIC  = false;              // Clears the SSPRTINTR interrupt
 }

 // SPI0 Interrupt clear register, SSPICR on page 3-11
 register SSPICR_t SPI0_SSPICR at 0x4003c020;

 type SSPDMACR_t {
	RXDMAE = false;              // Receive DMA Enable. If this bit is set to 1, DMA for the receive FIFO is enabled.
	TXDMAE = false;              // Transmit DMA Enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.
 }

 // SPI0 DMA control register, SSPDMACR on page 3-12
 register SSPDMACR_t SPI0_SSPDMACR at 0x4003c024;

 type SSPPERIPHID0_t {
	PARTNUMBER0 = uint8(0);           // These bits read back as 0x22
 }

 // SPI0 Peripheral identification registers, SSPPeriphID0-3 on page 3-13
 register SSPPERIPHID0_t SPI0_SSPPERIPHID0 at 0x4003cfe0;

 type SSPPERIPHID1_t {
	PARTNUMBER1 = uint4(0);           // These bits read back as 0x0
	DESIGNER0   = uint4(0);           // These bits read back as 0x1
 }

 // SPI0 Peripheral identification registers, SSPPeriphID0-3 on page 3-13
 register SSPPERIPHID1_t SPI0_SSPPERIPHID1 at 0x4003cfe4;

 type SSPPERIPHID2_t {
	DESIGNER1 = uint4(0);           // These bits read back as 0x4
	REVISION  = uint4(0);           // These bits return the peripheral revision
 }

 // SPI0 Peripheral identification registers, SSPPeriphID0-3 on page 3-13
 register SSPPERIPHID2_t SPI0_SSPPERIPHID2 at 0x4003cfe8;

 type SSPPERIPHID3_t {
	CONFIGURATION = uint8(0);           // These bits read back as 0x00
 }

 // SPI0 Peripheral identification registers, SSPPeriphID0-3 on page 3-13
 register SSPPERIPHID3_t SPI0_SSPPERIPHID3 at 0x4003cfec;

 type SSPPCELLID0_t {
	SSPPCELLID0 = uint8(0);           // These bits read back as 0x0D
 }

 // SPI0 PrimeCell identification registers, SSPPCellID0-3 on page 3-16
 register SSPPCELLID0_t SPI0_SSPPCELLID0 at 0x4003cff0;

 type SSPPCELLID1_t {
	SSPPCELLID1 = uint8(0);           // These bits read back as 0xF0
 }

 // SPI0 PrimeCell identification registers, SSPPCellID0-3 on page 3-16
 register SSPPCELLID1_t SPI0_SSPPCELLID1 at 0x4003cff4;

 type SSPPCELLID2_t {
	SSPPCELLID2 = uint8(0);           // These bits read back as 0x05
 }

 // SPI0 PrimeCell identification registers, SSPPCellID0-3 on page 3-16
 register SSPPCELLID2_t SPI0_SSPPCELLID2 at 0x4003cff8;

 type SSPPCELLID3_t {
	SSPPCELLID3 = uint8(0);           // These bits read back as 0xB1
 }

 // SPI0 PrimeCell identification registers, SSPPCellID0-3 on page 3-16
 register SSPPCELLID3_t SPI0_SSPPCELLID3 at 0x4003cffc;


/* Types and registers for SPI1  */

 // SPI1 Control register 0, SSPCR0 on page 3-4
 register SSPCR0_t SPI1_SSPCR0 at 0x40040000;

 // SPI1 Control register 1, SSPCR1 on page 3-5
 register SSPCR1_t SPI1_SSPCR1 at 0x40040004;

 // SPI1 Data register, SSPDR on page 3-6
 register SSPDR_t SPI1_SSPDR at 0x40040008;

 // SPI1 Status register, SSPSR on page 3-7
 register SSPSR_t SPI1_SSPSR at 0x4004000c;

 // SPI1 Clock prescale register, SSPCPSR on page 3-8
 register SSPCPSR_t SPI1_SSPCPSR at 0x40040010;

 // SPI1 Interrupt mask set or clear register, SSPIMSC on page 3-9
 register SSPIMSC_t SPI1_SSPIMSC at 0x40040014;

 // SPI1 Raw interrupt status register, SSPRIS on page 3-10
 register SSPRIS_t SPI1_SSPRIS at 0x40040018;

 // SPI1 Masked interrupt status register, SSPMIS on page 3-11
 register SSPMIS_t SPI1_SSPMIS at 0x4004001c;

 // SPI1 Interrupt clear register, SSPICR on page 3-11
 register SSPICR_t SPI1_SSPICR at 0x40040020;

 // SPI1 DMA control register, SSPDMACR on page 3-12
 register SSPDMACR_t SPI1_SSPDMACR at 0x40040024;

 // SPI1 Peripheral identification registers, SSPPeriphID0-3 on page 3-13
 register SSPPERIPHID0_t SPI1_SSPPERIPHID0 at 0x40040fe0;

 // SPI1 Peripheral identification registers, SSPPeriphID0-3 on page 3-13
 register SSPPERIPHID1_t SPI1_SSPPERIPHID1 at 0x40040fe4;

 // SPI1 Peripheral identification registers, SSPPeriphID0-3 on page 3-13
 register SSPPERIPHID2_t SPI1_SSPPERIPHID2 at 0x40040fe8;

 // SPI1 Peripheral identification registers, SSPPeriphID0-3 on page 3-13
 register SSPPERIPHID3_t SPI1_SSPPERIPHID3 at 0x40040fec;

 // SPI1 PrimeCell identification registers, SSPPCellID0-3 on page 3-16
 register SSPPCELLID0_t SPI1_SSPPCELLID0 at 0x40040ff0;

 // SPI1 PrimeCell identification registers, SSPPCellID0-3 on page 3-16
 register SSPPCELLID1_t SPI1_SSPPCELLID1 at 0x40040ff4;

 // SPI1 PrimeCell identification registers, SSPPCellID0-3 on page 3-16
 register SSPPCELLID2_t SPI1_SSPPCELLID2 at 0x40040ff8;

 // SPI1 PrimeCell identification registers, SSPPCellID0-3 on page 3-16
 register SSPPCELLID3_t SPI1_SSPPCELLID3 at 0x40040ffc;


/* Types and registers for PIO0 
  Programmable IO block
 */

 type PIO0_CTRL_t {
	SM_ENABLE      = uint4(0);           // Enable/disable each of the four state machines by writing 1/0 to each of these four bits. When disabled, a state machine will cease executing instructions, except those written directly to SMx_INSTR by the system. Multiple bits can be set/cleared at once to run/halt multiple state machines simultaneously.
	SM_RESTART     = uint4(0);           // Write 1 to instantly clear internal SM state which may be otherwise difficult to access and will affect future execution. Specifically, the following are cleared: input and output shift counters; the contents of the input shift register; the delay counter; the waiting-on-IRQ state; any stalled instruction written to SMx_INSTR or run by OUT/MOV EXEC; any pin write left asserted due to OUT_STICKY. The program counter, the contents of the output shift register and the X/Y scratch registers are not affected.
	CLKDIV_RESTART = uint4(0);           // Restart a state machine's clock divider from an initial phase of 0. Clock dividers are free-running, so once started, their output (including fractional jitter) is completely determined by the integer/fractional divisor configured in SMx_CLKDIV. This means that, if multiple clock dividers with the same divisor are restarted simultaneously, by writing multiple 1 bits to this field, the execution clocks of those state machines will run in precise lockstep. Note that setting/clearing SM_ENABLE does not stop the clock divider from running, so once multiple state machines' clocks are synchronised, it is safe to disable/reenable a state machine, whilst keeping the clock dividers in sync. Note also that CLKDIV_RESTART can be written to whilst the state machine is running, and this is useful to resynchronise clock dividers after the divisors (SMx_CLKDIV) have been changed on-the-fly.
 }

 // PIO0 PIO control register
 register PIO0_CTRL_t PIO0_PIO0_CTRL at 0x50200000;

 type FSTAT_t {
	RXFULL  = uint4(0);           // State machine RX FIFO is full
	_res1   = uint4(0);           // Reserved, 4 bits
	RXEMPTY = uint4(0);           // State machine RX FIFO is empty
	_res2   = uint4(0);           // Reserved, 4 bits
	TXFULL  = uint4(0);           // State machine TX FIFO is full
	_res3   = uint4(0);           // Reserved, 4 bits
	TXEMPTY = uint4(0);           // State machine TX FIFO is empty
 }

 // PIO0 FIFO status register
 register FSTAT_t PIO0_FSTAT at 0x50200004;

 type FDEBUG_t {
	RXSTALL = uint4(0);           // State machine has stalled on full RX FIFO during a blocking PUSH, or an IN with autopush enabled. This flag is also set when a nonblocking PUSH to a full FIFO took place, in which case the state machine has dropped data. Write 1 to clear.
	_res1   = uint4(0);           // Reserved, 4 bits
	RXUNDER = uint4(0);           // RX FIFO underflow (i.e. read-on-empty by the system) has occurred. Write 1 to clear. Note that read-on-empty does not perturb the state of the FIFO in any way, but the data returned by reading from an empty FIFO is undefined, so this flag generally only becomes set due to some kind of software error.
	_res2   = uint4(0);           // Reserved, 4 bits
	TXOVER  = uint4(0);           // TX FIFO overflow (i.e. write-on-full by the system) has occurred. Write 1 to clear. Note that write-on-full does not alter the state or contents of the FIFO in any way, but the data that the system attempted to write is dropped, so if this flag is set, your software has quite likely dropped some data on the floor.
	_res3   = uint4(0);           // Reserved, 4 bits
	TXSTALL = uint4(0);           // State machine has stalled on empty TX FIFO during a blocking PULL, or an OUT with autopull enabled. Write 1 to clear.
 }

 // PIO0 FIFO debug register
 register FDEBUG_t PIO0_FDEBUG at 0x50200008;

 type FLEVEL_t {
	TX0 = uint4(0);           // 
	RX0 = uint4(0);           // 
	TX1 = uint4(0);           // 
	RX1 = uint4(0);           // 
	TX2 = uint4(0);           // 
	RX2 = uint4(0);           // 
	TX3 = uint4(0);           // 
	RX3 = uint4(0);           // 
 }

 // PIO0 FIFO levels
 register FLEVEL_t PIO0_FLEVEL at 0x5020000c;

 type TXF0_t {
	TXF0 = uint32(0);          // 
 }

 // PIO0 Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
 register TXF0_t PIO0_TXF0 at 0x50200010;

 type TXF1_t {
	TXF1 = uint32(0);          // 
 }

 // PIO0 Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
 register TXF1_t PIO0_TXF1 at 0x50200014;

 type TXF2_t {
	TXF2 = uint32(0);          // 
 }

 // PIO0 Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
 register TXF2_t PIO0_TXF2 at 0x50200018;

 type TXF3_t {
	TXF3 = uint32(0);          // 
 }

 // PIO0 Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
 register TXF3_t PIO0_TXF3 at 0x5020001c;

 type RXF0_t {
	RXF0 = uint32(0);          // 
 }

 // PIO0 Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
 register RXF0_t PIO0_RXF0 at 0x50200020;

 type RXF1_t {
	RXF1 = uint32(0);          // 
 }

 // PIO0 Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
 register RXF1_t PIO0_RXF1 at 0x50200024;

 type RXF2_t {
	RXF2 = uint32(0);          // 
 }

 // PIO0 Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
 register RXF2_t PIO0_RXF2 at 0x50200028;

 type RXF3_t {
	RXF3 = uint32(0);          // 
 }

 // PIO0 Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
 register RXF3_t PIO0_RXF3 at 0x5020002c;

 type IRQ_t {
	IRQ = uint8(0);           // 
 }

 // PIO0 State machine IRQ flags register. Write 1 to clear. There are 8 state machine IRQ flags, which can be set, cleared, and waited on by the state machines. There's no fixed association between flags and state machines -- any state machine can use any flag. Any of the 8 flags can be used for timing synchronisation between state machines, using IRQ and WAIT instructions. The lower four of these flags are also routed out to system-level interrupt requests, alongside FIFO status interrupts -- see e.g. IRQ0_INTE.
 register IRQ_t PIO0_IRQ at 0x50200030;

 type IRQ_FORCE_t {
	IRQ_FORCE = uint8(0);           // 
 }

 // PIO0 Writing a 1 to each of these bits will forcibly assert the corresponding IRQ. Note this is different to the INTF register: writing here affects PIO internal state. INTF just asserts the processor-facing IRQ signal for testing ISRs, and is not visible to the state machines.
 register IRQ_FORCE_t PIO0_IRQ_FORCE at 0x50200034;

 type INPUT_SYNC_BYPASS_t {
	INPUT_SYNC_BYPASS = uint32(0);          // 
 }

 // PIO0 There is a 2-flipflop synchronizer on each GPIO input, which protects PIO logic from metastabilities. This increases input delay, and for fast synchronous IO (e.g. SPI) these synchronizers may need to be bypassed. Each bit in this register corresponds to one GPIO. 0 -> input is synchronized (default) 1 -> synchronizer is bypassed If in doubt, leave this register as all zeroes.
 register INPUT_SYNC_BYPASS_t PIO0_INPUT_SYNC_BYPASS at 0x50200038;

 type DBG_PADOUT_t {
	DBG_PADOUT = uint32(0);          // 
 }

 // PIO0 Read to sample the pad output values PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.
 register DBG_PADOUT_t PIO0_DBG_PADOUT at 0x5020003c;

 type DBG_PADOE_t {
	DBG_PADOE = uint32(0);          // 
 }

 // PIO0 Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.
 register DBG_PADOE_t PIO0_DBG_PADOE at 0x50200040;

 type DBG_CFGINFO_t {
	FIFO_DEPTH = uint6(0);           // The depth of the state machine TX/RX FIFOs, measured in words. Joining fifos via SHIFTCTRL_FJOIN gives one FIFO with double this depth.
	_res1      = uint2(0);           // Reserved, 2 bits
	SM_COUNT   = uint4(0);           // The number of state machines this PIO instance is equipped with.
	_res2      = uint4(0);           // Reserved, 4 bits
	IMEM_SIZE  = uint6(0);           // The size of the instruction memory, measured in units of one instruction
 }

 // PIO0 The PIO hardware has some free parameters that may vary between chip products. These should be provided in the chip datasheet, but are also exposed here.
 register DBG_CFGINFO_t PIO0_DBG_CFGINFO at 0x50200044;

 type INSTR_MEM0_t {
	INSTR_MEM0 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 0
 register INSTR_MEM0_t PIO0_INSTR_MEM0 at 0x50200048;

 type INSTR_MEM1_t {
	INSTR_MEM1 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 1
 register INSTR_MEM1_t PIO0_INSTR_MEM1 at 0x5020004c;

 type INSTR_MEM2_t {
	INSTR_MEM2 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 2
 register INSTR_MEM2_t PIO0_INSTR_MEM2 at 0x50200050;

 type INSTR_MEM3_t {
	INSTR_MEM3 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 3
 register INSTR_MEM3_t PIO0_INSTR_MEM3 at 0x50200054;

 type INSTR_MEM4_t {
	INSTR_MEM4 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 4
 register INSTR_MEM4_t PIO0_INSTR_MEM4 at 0x50200058;

 type INSTR_MEM5_t {
	INSTR_MEM5 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 5
 register INSTR_MEM5_t PIO0_INSTR_MEM5 at 0x5020005c;

 type INSTR_MEM6_t {
	INSTR_MEM6 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 6
 register INSTR_MEM6_t PIO0_INSTR_MEM6 at 0x50200060;

 type INSTR_MEM7_t {
	INSTR_MEM7 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 7
 register INSTR_MEM7_t PIO0_INSTR_MEM7 at 0x50200064;

 type INSTR_MEM8_t {
	INSTR_MEM8 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 8
 register INSTR_MEM8_t PIO0_INSTR_MEM8 at 0x50200068;

 type INSTR_MEM9_t {
	INSTR_MEM9 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 9
 register INSTR_MEM9_t PIO0_INSTR_MEM9 at 0x5020006c;

 type INSTR_MEM10_t {
	INSTR_MEM10 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 10
 register INSTR_MEM10_t PIO0_INSTR_MEM10 at 0x50200070;

 type INSTR_MEM11_t {
	INSTR_MEM11 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 11
 register INSTR_MEM11_t PIO0_INSTR_MEM11 at 0x50200074;

 type INSTR_MEM12_t {
	INSTR_MEM12 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 12
 register INSTR_MEM12_t PIO0_INSTR_MEM12 at 0x50200078;

 type INSTR_MEM13_t {
	INSTR_MEM13 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 13
 register INSTR_MEM13_t PIO0_INSTR_MEM13 at 0x5020007c;

 type INSTR_MEM14_t {
	INSTR_MEM14 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 14
 register INSTR_MEM14_t PIO0_INSTR_MEM14 at 0x50200080;

 type INSTR_MEM15_t {
	INSTR_MEM15 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 15
 register INSTR_MEM15_t PIO0_INSTR_MEM15 at 0x50200084;

 type INSTR_MEM16_t {
	INSTR_MEM16 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 16
 register INSTR_MEM16_t PIO0_INSTR_MEM16 at 0x50200088;

 type INSTR_MEM17_t {
	INSTR_MEM17 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 17
 register INSTR_MEM17_t PIO0_INSTR_MEM17 at 0x5020008c;

 type INSTR_MEM18_t {
	INSTR_MEM18 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 18
 register INSTR_MEM18_t PIO0_INSTR_MEM18 at 0x50200090;

 type INSTR_MEM19_t {
	INSTR_MEM19 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 19
 register INSTR_MEM19_t PIO0_INSTR_MEM19 at 0x50200094;

 type INSTR_MEM20_t {
	INSTR_MEM20 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 20
 register INSTR_MEM20_t PIO0_INSTR_MEM20 at 0x50200098;

 type INSTR_MEM21_t {
	INSTR_MEM21 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 21
 register INSTR_MEM21_t PIO0_INSTR_MEM21 at 0x5020009c;

 type INSTR_MEM22_t {
	INSTR_MEM22 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 22
 register INSTR_MEM22_t PIO0_INSTR_MEM22 at 0x502000a0;

 type INSTR_MEM23_t {
	INSTR_MEM23 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 23
 register INSTR_MEM23_t PIO0_INSTR_MEM23 at 0x502000a4;

 type INSTR_MEM24_t {
	INSTR_MEM24 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 24
 register INSTR_MEM24_t PIO0_INSTR_MEM24 at 0x502000a8;

 type INSTR_MEM25_t {
	INSTR_MEM25 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 25
 register INSTR_MEM25_t PIO0_INSTR_MEM25 at 0x502000ac;

 type INSTR_MEM26_t {
	INSTR_MEM26 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 26
 register INSTR_MEM26_t PIO0_INSTR_MEM26 at 0x502000b0;

 type INSTR_MEM27_t {
	INSTR_MEM27 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 27
 register INSTR_MEM27_t PIO0_INSTR_MEM27 at 0x502000b4;

 type INSTR_MEM28_t {
	INSTR_MEM28 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 28
 register INSTR_MEM28_t PIO0_INSTR_MEM28 at 0x502000b8;

 type INSTR_MEM29_t {
	INSTR_MEM29 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 29
 register INSTR_MEM29_t PIO0_INSTR_MEM29 at 0x502000bc;

 type INSTR_MEM30_t {
	INSTR_MEM30 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 30
 register INSTR_MEM30_t PIO0_INSTR_MEM30 at 0x502000c0;

 type INSTR_MEM31_t {
	INSTR_MEM31 = uint16(0);          // 
 }

 // PIO0 Write-only access to instruction memory location 31
 register INSTR_MEM31_t PIO0_INSTR_MEM31 at 0x502000c4;

 type SM0_CLKDIV_t {
	_res1 = uint8(0);           // Reserved, 8 bits
	FRAC  = uint8(0);           // Fractional part of clock divisor
	INT   = uint16(0);          // Effective frequency is sysclk/(int + frac/256). Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0.
 }

 // PIO0 Clock divisor register for state machine 0 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
 register SM0_CLKDIV_t PIO0_SM0_CLKDIV at 0x502000c8;

 type SM0_EXECCTRL_t {
	STATUS_N      = uint4(0);           // Comparison level for the MOV x, STATUS instruction
	STATUS_SEL    = false;              // Comparison used for the MOV x, STATUS instruction.
	_res1         = uint2(0);           // Reserved, 2 bits
	WRAP_BOTTOM   = uint5(0);           // After reaching wrap_top, execution is wrapped to this address.
	WRAP_TOP      = uint5(0);           // After reaching this address, execution is wrapped to wrap_bottom. If the instruction is a jump, and the jump condition is true, the jump takes priority.
	OUT_STICKY    = false;              // Continuously assert the most recent OUT/SET to the pins
	INLINE_OUT_EN = false;              // If 1, use a bit of OUT data as an auxiliary write enable When used in conjunction with OUT_STICKY, writes with an enable of 0 will deassert the latest pin write. This can create useful masking/override behaviour due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
	OUT_EN_SEL    = uint5(0);           // Which data bit to use for inline OUT enable
	JMP_PIN       = uint5(0);           // The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
	SIDE_PINDIR   = false;              // If 1, side-set data is asserted to pin directions, instead of pin values
	SIDE_EN       = false;              // If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
	EXEC_STALLED  = false;              // If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
 }

 // PIO0 Execution/behavioural settings for state machine 0
 register SM0_EXECCTRL_t PIO0_SM0_EXECCTRL at 0x502000cc;

 type SM0_SHIFTCTRL_t {
	_res1        = uint16(0);          // Reserved, 16 bits
	AUTOPUSH     = false;              // Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
	AUTOPULL     = false;              // Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
	IN_SHIFTDIR  = false;              // 1 = shift input shift register to right (data enters from left). 0 = to left.
	OUT_SHIFTDIR = false;              // 1 = shift out of output shift register to right. 0 = to left.
	PUSH_THRESH  = uint5(0);           // Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. Write 0 for value of 32.
	PULL_THRESH  = uint5(0);           // Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. Write 0 for value of 32.
	FJOIN_TX     = false;              // When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. RX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed.
	FJOIN_RX     = false;              // When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. TX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed.
 }

 // PIO0 Control behaviour of the input/output shift registers for state machine 0
 register SM0_SHIFTCTRL_t PIO0_SM0_SHIFTCTRL at 0x502000d0;

 type SM0_ADDR_t {
	SM0_ADDR = uint5(0);           // 
 }

 // PIO0 Current instruction address of state machine 0
 register SM0_ADDR_t PIO0_SM0_ADDR at 0x502000d4;

 type SM0_INSTR_t {
	SM0_INSTR = uint16(0);          // 
 }

 // PIO0 Read to see the instruction currently addressed by state machine 0's program counter Write to execute an instruction immediately (including jumps) and then resume execution.
 register SM0_INSTR_t PIO0_SM0_INSTR at 0x502000d8;

 type SM0_PINCTRL_t {
	OUT_BASE      = uint5(0);           // The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
	SET_BASE      = uint5(0);           // The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
	SIDESET_BASE  = uint5(0);           // The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
	IN_BASE       = uint5(0);           // The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
	OUT_COUNT     = uint6(0);           // The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
	SET_COUNT     = uint3(0);           // The number of pins asserted by a SET. In the range 0 to 5 inclusive.
	SIDESET_COUNT = uint3(0);           // The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
 }

 // PIO0 State machine pin control
 register SM0_PINCTRL_t PIO0_SM0_PINCTRL at 0x502000dc;

 type SM1_CLKDIV_t {
	_res1 = uint8(0);           // Reserved, 8 bits
	FRAC  = uint8(0);           // Fractional part of clock divisor
	INT   = uint16(0);          // Effective frequency is sysclk/(int + frac/256). Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0.
 }

 // PIO0 Clock divisor register for state machine 1 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
 register SM1_CLKDIV_t PIO0_SM1_CLKDIV at 0x502000e0;

 type SM1_EXECCTRL_t {
	STATUS_N      = uint4(0);           // Comparison level for the MOV x, STATUS instruction
	STATUS_SEL    = false;              // Comparison used for the MOV x, STATUS instruction.
	_res1         = uint2(0);           // Reserved, 2 bits
	WRAP_BOTTOM   = uint5(0);           // After reaching wrap_top, execution is wrapped to this address.
	WRAP_TOP      = uint5(0);           // After reaching this address, execution is wrapped to wrap_bottom. If the instruction is a jump, and the jump condition is true, the jump takes priority.
	OUT_STICKY    = false;              // Continuously assert the most recent OUT/SET to the pins
	INLINE_OUT_EN = false;              // If 1, use a bit of OUT data as an auxiliary write enable When used in conjunction with OUT_STICKY, writes with an enable of 0 will deassert the latest pin write. This can create useful masking/override behaviour due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
	OUT_EN_SEL    = uint5(0);           // Which data bit to use for inline OUT enable
	JMP_PIN       = uint5(0);           // The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
	SIDE_PINDIR   = false;              // If 1, side-set data is asserted to pin directions, instead of pin values
	SIDE_EN       = false;              // If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
	EXEC_STALLED  = false;              // If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
 }

 // PIO0 Execution/behavioural settings for state machine 1
 register SM1_EXECCTRL_t PIO0_SM1_EXECCTRL at 0x502000e4;

 type SM1_SHIFTCTRL_t {
	_res1        = uint16(0);          // Reserved, 16 bits
	AUTOPUSH     = false;              // Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
	AUTOPULL     = false;              // Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
	IN_SHIFTDIR  = false;              // 1 = shift input shift register to right (data enters from left). 0 = to left.
	OUT_SHIFTDIR = false;              // 1 = shift out of output shift register to right. 0 = to left.
	PUSH_THRESH  = uint5(0);           // Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. Write 0 for value of 32.
	PULL_THRESH  = uint5(0);           // Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. Write 0 for value of 32.
	FJOIN_TX     = false;              // When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. RX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed.
	FJOIN_RX     = false;              // When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. TX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed.
 }

 // PIO0 Control behaviour of the input/output shift registers for state machine 1
 register SM1_SHIFTCTRL_t PIO0_SM1_SHIFTCTRL at 0x502000e8;

 type SM1_ADDR_t {
	SM1_ADDR = uint5(0);           // 
 }

 // PIO0 Current instruction address of state machine 1
 register SM1_ADDR_t PIO0_SM1_ADDR at 0x502000ec;

 type SM1_INSTR_t {
	SM1_INSTR = uint16(0);          // 
 }

 // PIO0 Read to see the instruction currently addressed by state machine 1's program counter Write to execute an instruction immediately (including jumps) and then resume execution.
 register SM1_INSTR_t PIO0_SM1_INSTR at 0x502000f0;

 type SM1_PINCTRL_t {
	OUT_BASE      = uint5(0);           // The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
	SET_BASE      = uint5(0);           // The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
	SIDESET_BASE  = uint5(0);           // The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
	IN_BASE       = uint5(0);           // The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
	OUT_COUNT     = uint6(0);           // The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
	SET_COUNT     = uint3(0);           // The number of pins asserted by a SET. In the range 0 to 5 inclusive.
	SIDESET_COUNT = uint3(0);           // The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
 }

 // PIO0 State machine pin control
 register SM1_PINCTRL_t PIO0_SM1_PINCTRL at 0x502000f4;

 type SM2_CLKDIV_t {
	_res1 = uint8(0);           // Reserved, 8 bits
	FRAC  = uint8(0);           // Fractional part of clock divisor
	INT   = uint16(0);          // Effective frequency is sysclk/(int + frac/256). Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0.
 }

 // PIO0 Clock divisor register for state machine 2 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
 register SM2_CLKDIV_t PIO0_SM2_CLKDIV at 0x502000f8;

 type SM2_EXECCTRL_t {
	STATUS_N      = uint4(0);           // Comparison level for the MOV x, STATUS instruction
	STATUS_SEL    = false;              // Comparison used for the MOV x, STATUS instruction.
	_res1         = uint2(0);           // Reserved, 2 bits
	WRAP_BOTTOM   = uint5(0);           // After reaching wrap_top, execution is wrapped to this address.
	WRAP_TOP      = uint5(0);           // After reaching this address, execution is wrapped to wrap_bottom. If the instruction is a jump, and the jump condition is true, the jump takes priority.
	OUT_STICKY    = false;              // Continuously assert the most recent OUT/SET to the pins
	INLINE_OUT_EN = false;              // If 1, use a bit of OUT data as an auxiliary write enable When used in conjunction with OUT_STICKY, writes with an enable of 0 will deassert the latest pin write. This can create useful masking/override behaviour due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
	OUT_EN_SEL    = uint5(0);           // Which data bit to use for inline OUT enable
	JMP_PIN       = uint5(0);           // The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
	SIDE_PINDIR   = false;              // If 1, side-set data is asserted to pin directions, instead of pin values
	SIDE_EN       = false;              // If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
	EXEC_STALLED  = false;              // If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
 }

 // PIO0 Execution/behavioural settings for state machine 2
 register SM2_EXECCTRL_t PIO0_SM2_EXECCTRL at 0x502000fc;

 type SM2_SHIFTCTRL_t {
	_res1        = uint16(0);          // Reserved, 16 bits
	AUTOPUSH     = false;              // Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
	AUTOPULL     = false;              // Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
	IN_SHIFTDIR  = false;              // 1 = shift input shift register to right (data enters from left). 0 = to left.
	OUT_SHIFTDIR = false;              // 1 = shift out of output shift register to right. 0 = to left.
	PUSH_THRESH  = uint5(0);           // Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. Write 0 for value of 32.
	PULL_THRESH  = uint5(0);           // Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. Write 0 for value of 32.
	FJOIN_TX     = false;              // When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. RX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed.
	FJOIN_RX     = false;              // When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. TX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed.
 }

 // PIO0 Control behaviour of the input/output shift registers for state machine 2
 register SM2_SHIFTCTRL_t PIO0_SM2_SHIFTCTRL at 0x50200100;

 type SM2_ADDR_t {
	SM2_ADDR = uint5(0);           // 
 }

 // PIO0 Current instruction address of state machine 2
 register SM2_ADDR_t PIO0_SM2_ADDR at 0x50200104;

 type SM2_INSTR_t {
	SM2_INSTR = uint16(0);          // 
 }

 // PIO0 Read to see the instruction currently addressed by state machine 2's program counter Write to execute an instruction immediately (including jumps) and then resume execution.
 register SM2_INSTR_t PIO0_SM2_INSTR at 0x50200108;

 type SM2_PINCTRL_t {
	OUT_BASE      = uint5(0);           // The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
	SET_BASE      = uint5(0);           // The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
	SIDESET_BASE  = uint5(0);           // The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
	IN_BASE       = uint5(0);           // The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
	OUT_COUNT     = uint6(0);           // The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
	SET_COUNT     = uint3(0);           // The number of pins asserted by a SET. In the range 0 to 5 inclusive.
	SIDESET_COUNT = uint3(0);           // The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
 }

 // PIO0 State machine pin control
 register SM2_PINCTRL_t PIO0_SM2_PINCTRL at 0x5020010c;

 type SM3_CLKDIV_t {
	_res1 = uint8(0);           // Reserved, 8 bits
	FRAC  = uint8(0);           // Fractional part of clock divisor
	INT   = uint16(0);          // Effective frequency is sysclk/(int + frac/256). Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0.
 }

 // PIO0 Clock divisor register for state machine 3 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
 register SM3_CLKDIV_t PIO0_SM3_CLKDIV at 0x50200110;

 type SM3_EXECCTRL_t {
	STATUS_N      = uint4(0);           // Comparison level for the MOV x, STATUS instruction
	STATUS_SEL    = false;              // Comparison used for the MOV x, STATUS instruction.
	_res1         = uint2(0);           // Reserved, 2 bits
	WRAP_BOTTOM   = uint5(0);           // After reaching wrap_top, execution is wrapped to this address.
	WRAP_TOP      = uint5(0);           // After reaching this address, execution is wrapped to wrap_bottom. If the instruction is a jump, and the jump condition is true, the jump takes priority.
	OUT_STICKY    = false;              // Continuously assert the most recent OUT/SET to the pins
	INLINE_OUT_EN = false;              // If 1, use a bit of OUT data as an auxiliary write enable When used in conjunction with OUT_STICKY, writes with an enable of 0 will deassert the latest pin write. This can create useful masking/override behaviour due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
	OUT_EN_SEL    = uint5(0);           // Which data bit to use for inline OUT enable
	JMP_PIN       = uint5(0);           // The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
	SIDE_PINDIR   = false;              // If 1, side-set data is asserted to pin directions, instead of pin values
	SIDE_EN       = false;              // If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
	EXEC_STALLED  = false;              // If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
 }

 // PIO0 Execution/behavioural settings for state machine 3
 register SM3_EXECCTRL_t PIO0_SM3_EXECCTRL at 0x50200114;

 type SM3_SHIFTCTRL_t {
	_res1        = uint16(0);          // Reserved, 16 bits
	AUTOPUSH     = false;              // Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
	AUTOPULL     = false;              // Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
	IN_SHIFTDIR  = false;              // 1 = shift input shift register to right (data enters from left). 0 = to left.
	OUT_SHIFTDIR = false;              // 1 = shift out of output shift register to right. 0 = to left.
	PUSH_THRESH  = uint5(0);           // Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. Write 0 for value of 32.
	PULL_THRESH  = uint5(0);           // Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. Write 0 for value of 32.
	FJOIN_TX     = false;              // When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. RX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed.
	FJOIN_RX     = false;              // When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. TX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed.
 }

 // PIO0 Control behaviour of the input/output shift registers for state machine 3
 register SM3_SHIFTCTRL_t PIO0_SM3_SHIFTCTRL at 0x50200118;

 type SM3_ADDR_t {
	SM3_ADDR = uint5(0);           // 
 }

 // PIO0 Current instruction address of state machine 3
 register SM3_ADDR_t PIO0_SM3_ADDR at 0x5020011c;

 type SM3_INSTR_t {
	SM3_INSTR = uint16(0);          // 
 }

 // PIO0 Read to see the instruction currently addressed by state machine 3's program counter Write to execute an instruction immediately (including jumps) and then resume execution.
 register SM3_INSTR_t PIO0_SM3_INSTR at 0x50200120;

 type SM3_PINCTRL_t {
	OUT_BASE      = uint5(0);           // The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
	SET_BASE      = uint5(0);           // The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
	SIDESET_BASE  = uint5(0);           // The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
	IN_BASE       = uint5(0);           // The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
	OUT_COUNT     = uint6(0);           // The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
	SET_COUNT     = uint3(0);           // The number of pins asserted by a SET. In the range 0 to 5 inclusive.
	SIDESET_COUNT = uint3(0);           // The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
 }

 // PIO0 State machine pin control
 register SM3_PINCTRL_t PIO0_SM3_PINCTRL at 0x50200124;

 type PIO0_INTR_t {
	SM0_RXNEMPTY = false;              // 
	SM1_RXNEMPTY = false;              // 
	SM2_RXNEMPTY = false;              // 
	SM3_RXNEMPTY = false;              // 
	SM0_TXNFULL  = false;              // 
	SM1_TXNFULL  = false;              // 
	SM2_TXNFULL  = false;              // 
	SM3_TXNFULL  = false;              // 
	SM0          = false;              // 
	SM1          = false;              // 
	SM2          = false;              // 
	SM3          = false;              // 
 }

 // PIO0 Raw Interrupts
 register PIO0_INTR_t PIO0_PIO0_INTR at 0x50200128;

 type IRQ0_INTE_t {
	SM0_RXNEMPTY = false;              // 
	SM1_RXNEMPTY = false;              // 
	SM2_RXNEMPTY = false;              // 
	SM3_RXNEMPTY = false;              // 
	SM0_TXNFULL  = false;              // 
	SM1_TXNFULL  = false;              // 
	SM2_TXNFULL  = false;              // 
	SM3_TXNFULL  = false;              // 
	SM0          = false;              // 
	SM1          = false;              // 
	SM2          = false;              // 
	SM3          = false;              // 
 }

 // PIO0 Interrupt Enable for irq0
 register IRQ0_INTE_t PIO0_IRQ0_INTE at 0x5020012c;

 type IRQ0_INTF_t {
	SM0_RXNEMPTY = false;              // 
	SM1_RXNEMPTY = false;              // 
	SM2_RXNEMPTY = false;              // 
	SM3_RXNEMPTY = false;              // 
	SM0_TXNFULL  = false;              // 
	SM1_TXNFULL  = false;              // 
	SM2_TXNFULL  = false;              // 
	SM3_TXNFULL  = false;              // 
	SM0          = false;              // 
	SM1          = false;              // 
	SM2          = false;              // 
	SM3          = false;              // 
 }

 // PIO0 Interrupt Force for irq0
 register IRQ0_INTF_t PIO0_IRQ0_INTF at 0x50200130;

 type IRQ0_INTS_t {
	SM0_RXNEMPTY = false;              // 
	SM1_RXNEMPTY = false;              // 
	SM2_RXNEMPTY = false;              // 
	SM3_RXNEMPTY = false;              // 
	SM0_TXNFULL  = false;              // 
	SM1_TXNFULL  = false;              // 
	SM2_TXNFULL  = false;              // 
	SM3_TXNFULL  = false;              // 
	SM0          = false;              // 
	SM1          = false;              // 
	SM2          = false;              // 
	SM3          = false;              // 
 }

 // PIO0 Interrupt status after masking & forcing for irq0
 register IRQ0_INTS_t PIO0_IRQ0_INTS at 0x50200134;

 type IRQ1_INTE_t {
	SM0_RXNEMPTY = false;              // 
	SM1_RXNEMPTY = false;              // 
	SM2_RXNEMPTY = false;              // 
	SM3_RXNEMPTY = false;              // 
	SM0_TXNFULL  = false;              // 
	SM1_TXNFULL  = false;              // 
	SM2_TXNFULL  = false;              // 
	SM3_TXNFULL  = false;              // 
	SM0          = false;              // 
	SM1          = false;              // 
	SM2          = false;              // 
	SM3          = false;              // 
 }

 // PIO0 Interrupt Enable for irq1
 register IRQ1_INTE_t PIO0_IRQ1_INTE at 0x50200138;

 type IRQ1_INTF_t {
	SM0_RXNEMPTY = false;              // 
	SM1_RXNEMPTY = false;              // 
	SM2_RXNEMPTY = false;              // 
	SM3_RXNEMPTY = false;              // 
	SM0_TXNFULL  = false;              // 
	SM1_TXNFULL  = false;              // 
	SM2_TXNFULL  = false;              // 
	SM3_TXNFULL  = false;              // 
	SM0          = false;              // 
	SM1          = false;              // 
	SM2          = false;              // 
	SM3          = false;              // 
 }

 // PIO0 Interrupt Force for irq1
 register IRQ1_INTF_t PIO0_IRQ1_INTF at 0x5020013c;

 type IRQ1_INTS_t {
	SM0_RXNEMPTY = false;              // 
	SM1_RXNEMPTY = false;              // 
	SM2_RXNEMPTY = false;              // 
	SM3_RXNEMPTY = false;              // 
	SM0_TXNFULL  = false;              // 
	SM1_TXNFULL  = false;              // 
	SM2_TXNFULL  = false;              // 
	SM3_TXNFULL  = false;              // 
	SM0          = false;              // 
	SM1          = false;              // 
	SM2          = false;              // 
	SM3          = false;              // 
 }

 // PIO0 Interrupt status after masking & forcing for irq1
 register IRQ1_INTS_t PIO0_IRQ1_INTS at 0x50200140;


/* Types and registers for PIO1  */

 // PIO1 PIO control register
 register PIO0_CTRL_t PIO1_CTRL at 0x50300000;

 // PIO1 FIFO status register
 register FSTAT_t PIO1_FSTAT at 0x50300004;

 // PIO1 FIFO debug register
 register FDEBUG_t PIO1_FDEBUG at 0x50300008;

 // PIO1 FIFO levels
 register FLEVEL_t PIO1_FLEVEL at 0x5030000c;

 // PIO1 Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
 register TXF0_t PIO1_TXF0 at 0x50300010;

 // PIO1 Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
 register TXF1_t PIO1_TXF1 at 0x50300014;

 // PIO1 Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
 register TXF2_t PIO1_TXF2 at 0x50300018;

 // PIO1 Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
 register TXF3_t PIO1_TXF3 at 0x5030001c;

 // PIO1 Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
 register RXF0_t PIO1_RXF0 at 0x50300020;

 // PIO1 Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
 register RXF1_t PIO1_RXF1 at 0x50300024;

 // PIO1 Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
 register RXF2_t PIO1_RXF2 at 0x50300028;

 // PIO1 Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
 register RXF3_t PIO1_RXF3 at 0x5030002c;

 // PIO1 State machine IRQ flags register. Write 1 to clear. There are 8 state machine IRQ flags, which can be set, cleared, and waited on by the state machines. There's no fixed association between flags and state machines -- any state machine can use any flag. Any of the 8 flags can be used for timing synchronisation between state machines, using IRQ and WAIT instructions. The lower four of these flags are also routed out to system-level interrupt requests, alongside FIFO status interrupts -- see e.g. IRQ0_INTE.
 register IRQ_t PIO1_IRQ at 0x50300030;

 // PIO1 Writing a 1 to each of these bits will forcibly assert the corresponding IRQ. Note this is different to the INTF register: writing here affects PIO internal state. INTF just asserts the processor-facing IRQ signal for testing ISRs, and is not visible to the state machines.
 register IRQ_FORCE_t PIO1_IRQ_FORCE at 0x50300034;

 // PIO1 There is a 2-flipflop synchronizer on each GPIO input, which protects PIO logic from metastabilities. This increases input delay, and for fast synchronous IO (e.g. SPI) these synchronizers may need to be bypassed. Each bit in this register corresponds to one GPIO. 0 -> input is synchronized (default) 1 -> synchronizer is bypassed If in doubt, leave this register as all zeroes.
 register INPUT_SYNC_BYPASS_t PIO1_INPUT_SYNC_BYPASS at 0x50300038;

 // PIO1 Read to sample the pad output values PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.
 register DBG_PADOUT_t PIO1_DBG_PADOUT at 0x5030003c;

 // PIO1 Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.
 register DBG_PADOE_t PIO1_DBG_PADOE at 0x50300040;

 // PIO1 The PIO hardware has some free parameters that may vary between chip products. These should be provided in the chip datasheet, but are also exposed here.
 register DBG_CFGINFO_t PIO1_DBG_CFGINFO at 0x50300044;

 // PIO1 Write-only access to instruction memory location 0
 register INSTR_MEM0_t PIO1_INSTR_MEM0 at 0x50300048;

 // PIO1 Write-only access to instruction memory location 1
 register INSTR_MEM1_t PIO1_INSTR_MEM1 at 0x5030004c;

 // PIO1 Write-only access to instruction memory location 2
 register INSTR_MEM2_t PIO1_INSTR_MEM2 at 0x50300050;

 // PIO1 Write-only access to instruction memory location 3
 register INSTR_MEM3_t PIO1_INSTR_MEM3 at 0x50300054;

 // PIO1 Write-only access to instruction memory location 4
 register INSTR_MEM4_t PIO1_INSTR_MEM4 at 0x50300058;

 // PIO1 Write-only access to instruction memory location 5
 register INSTR_MEM5_t PIO1_INSTR_MEM5 at 0x5030005c;

 // PIO1 Write-only access to instruction memory location 6
 register INSTR_MEM6_t PIO1_INSTR_MEM6 at 0x50300060;

 // PIO1 Write-only access to instruction memory location 7
 register INSTR_MEM7_t PIO1_INSTR_MEM7 at 0x50300064;

 // PIO1 Write-only access to instruction memory location 8
 register INSTR_MEM8_t PIO1_INSTR_MEM8 at 0x50300068;

 // PIO1 Write-only access to instruction memory location 9
 register INSTR_MEM9_t PIO1_INSTR_MEM9 at 0x5030006c;

 // PIO1 Write-only access to instruction memory location 10
 register INSTR_MEM10_t PIO1_INSTR_MEM10 at 0x50300070;

 // PIO1 Write-only access to instruction memory location 11
 register INSTR_MEM11_t PIO1_INSTR_MEM11 at 0x50300074;

 // PIO1 Write-only access to instruction memory location 12
 register INSTR_MEM12_t PIO1_INSTR_MEM12 at 0x50300078;

 // PIO1 Write-only access to instruction memory location 13
 register INSTR_MEM13_t PIO1_INSTR_MEM13 at 0x5030007c;

 // PIO1 Write-only access to instruction memory location 14
 register INSTR_MEM14_t PIO1_INSTR_MEM14 at 0x50300080;

 // PIO1 Write-only access to instruction memory location 15
 register INSTR_MEM15_t PIO1_INSTR_MEM15 at 0x50300084;

 // PIO1 Write-only access to instruction memory location 16
 register INSTR_MEM16_t PIO1_INSTR_MEM16 at 0x50300088;

 // PIO1 Write-only access to instruction memory location 17
 register INSTR_MEM17_t PIO1_INSTR_MEM17 at 0x5030008c;

 // PIO1 Write-only access to instruction memory location 18
 register INSTR_MEM18_t PIO1_INSTR_MEM18 at 0x50300090;

 // PIO1 Write-only access to instruction memory location 19
 register INSTR_MEM19_t PIO1_INSTR_MEM19 at 0x50300094;

 // PIO1 Write-only access to instruction memory location 20
 register INSTR_MEM20_t PIO1_INSTR_MEM20 at 0x50300098;

 // PIO1 Write-only access to instruction memory location 21
 register INSTR_MEM21_t PIO1_INSTR_MEM21 at 0x5030009c;

 // PIO1 Write-only access to instruction memory location 22
 register INSTR_MEM22_t PIO1_INSTR_MEM22 at 0x503000a0;

 // PIO1 Write-only access to instruction memory location 23
 register INSTR_MEM23_t PIO1_INSTR_MEM23 at 0x503000a4;

 // PIO1 Write-only access to instruction memory location 24
 register INSTR_MEM24_t PIO1_INSTR_MEM24 at 0x503000a8;

 // PIO1 Write-only access to instruction memory location 25
 register INSTR_MEM25_t PIO1_INSTR_MEM25 at 0x503000ac;

 // PIO1 Write-only access to instruction memory location 26
 register INSTR_MEM26_t PIO1_INSTR_MEM26 at 0x503000b0;

 // PIO1 Write-only access to instruction memory location 27
 register INSTR_MEM27_t PIO1_INSTR_MEM27 at 0x503000b4;

 // PIO1 Write-only access to instruction memory location 28
 register INSTR_MEM28_t PIO1_INSTR_MEM28 at 0x503000b8;

 // PIO1 Write-only access to instruction memory location 29
 register INSTR_MEM29_t PIO1_INSTR_MEM29 at 0x503000bc;

 // PIO1 Write-only access to instruction memory location 30
 register INSTR_MEM30_t PIO1_INSTR_MEM30 at 0x503000c0;

 // PIO1 Write-only access to instruction memory location 31
 register INSTR_MEM31_t PIO1_INSTR_MEM31 at 0x503000c4;

 // PIO1 Clock divisor register for state machine 0 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
 register SM0_CLKDIV_t PIO1_SM0_CLKDIV at 0x503000c8;

 // PIO1 Execution/behavioural settings for state machine 0
 register SM0_EXECCTRL_t PIO1_SM0_EXECCTRL at 0x503000cc;

 // PIO1 Control behaviour of the input/output shift registers for state machine 0
 register SM0_SHIFTCTRL_t PIO1_SM0_SHIFTCTRL at 0x503000d0;

 // PIO1 Current instruction address of state machine 0
 register SM0_ADDR_t PIO1_SM0_ADDR at 0x503000d4;

 // PIO1 Read to see the instruction currently addressed by state machine 0's program counter Write to execute an instruction immediately (including jumps) and then resume execution.
 register SM0_INSTR_t PIO1_SM0_INSTR at 0x503000d8;

 // PIO1 State machine pin control
 register SM0_PINCTRL_t PIO1_SM0_PINCTRL at 0x503000dc;

 // PIO1 Clock divisor register for state machine 1 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
 register SM1_CLKDIV_t PIO1_SM1_CLKDIV at 0x503000e0;

 // PIO1 Execution/behavioural settings for state machine 1
 register SM1_EXECCTRL_t PIO1_SM1_EXECCTRL at 0x503000e4;

 // PIO1 Control behaviour of the input/output shift registers for state machine 1
 register SM1_SHIFTCTRL_t PIO1_SM1_SHIFTCTRL at 0x503000e8;

 // PIO1 Current instruction address of state machine 1
 register SM1_ADDR_t PIO1_SM1_ADDR at 0x503000ec;

 // PIO1 Read to see the instruction currently addressed by state machine 1's program counter Write to execute an instruction immediately (including jumps) and then resume execution.
 register SM1_INSTR_t PIO1_SM1_INSTR at 0x503000f0;

 // PIO1 State machine pin control
 register SM1_PINCTRL_t PIO1_SM1_PINCTRL at 0x503000f4;

 // PIO1 Clock divisor register for state machine 2 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
 register SM2_CLKDIV_t PIO1_SM2_CLKDIV at 0x503000f8;

 // PIO1 Execution/behavioural settings for state machine 2
 register SM2_EXECCTRL_t PIO1_SM2_EXECCTRL at 0x503000fc;

 // PIO1 Control behaviour of the input/output shift registers for state machine 2
 register SM2_SHIFTCTRL_t PIO1_SM2_SHIFTCTRL at 0x50300100;

 // PIO1 Current instruction address of state machine 2
 register SM2_ADDR_t PIO1_SM2_ADDR at 0x50300104;

 // PIO1 Read to see the instruction currently addressed by state machine 2's program counter Write to execute an instruction immediately (including jumps) and then resume execution.
 register SM2_INSTR_t PIO1_SM2_INSTR at 0x50300108;

 // PIO1 State machine pin control
 register SM2_PINCTRL_t PIO1_SM2_PINCTRL at 0x5030010c;

 // PIO1 Clock divisor register for state machine 3 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
 register SM3_CLKDIV_t PIO1_SM3_CLKDIV at 0x50300110;

 // PIO1 Execution/behavioural settings for state machine 3
 register SM3_EXECCTRL_t PIO1_SM3_EXECCTRL at 0x50300114;

 // PIO1 Control behaviour of the input/output shift registers for state machine 3
 register SM3_SHIFTCTRL_t PIO1_SM3_SHIFTCTRL at 0x50300118;

 // PIO1 Current instruction address of state machine 3
 register SM3_ADDR_t PIO1_SM3_ADDR at 0x5030011c;

 // PIO1 Read to see the instruction currently addressed by state machine 3's program counter Write to execute an instruction immediately (including jumps) and then resume execution.
 register SM3_INSTR_t PIO1_SM3_INSTR at 0x50300120;

 // PIO1 State machine pin control
 register SM3_PINCTRL_t PIO1_SM3_PINCTRL at 0x50300124;

 // PIO1 Raw Interrupts
 register PIO0_INTR_t PIO1_INTR at 0x50300128;

 // PIO1 Interrupt Enable for irq0
 register IRQ0_INTE_t PIO1_IRQ0_INTE at 0x5030012c;

 // PIO1 Interrupt Force for irq0
 register IRQ0_INTF_t PIO1_IRQ0_INTF at 0x50300130;

 // PIO1 Interrupt status after masking & forcing for irq0
 register IRQ0_INTS_t PIO1_IRQ0_INTS at 0x50300134;

 // PIO1 Interrupt Enable for irq1
 register IRQ1_INTE_t PIO1_IRQ1_INTE at 0x50300138;

 // PIO1 Interrupt Force for irq1
 register IRQ1_INTF_t PIO1_IRQ1_INTF at 0x5030013c;

 // PIO1 Interrupt status after masking & forcing for irq1
 register IRQ1_INTS_t PIO1_IRQ1_INTS at 0x50300140;


/* Types and registers for BUSCTRL 
  Register block for busfabric control signals and performance counters
 */

 type BUS_PRIORITY_t {
	PROC0 = false;              // 0 - low priority, 1 - high priority
	_res1 = uint3(0);           // Reserved, 3 bits
	PROC1 = false;              // 0 - low priority, 1 - high priority
	_res2 = uint3(0);           // Reserved, 3 bits
	DMA_R = false;              // 0 - low priority, 1 - high priority
	_res3 = uint3(0);           // Reserved, 3 bits
	DMA_W = false;              // 0 - low priority, 1 - high priority
 }

 // Set the priority of each master for bus arbitration.
 register BUS_PRIORITY_t BUS_PRIORITY at 0x40030000;

 type BUS_PRIORITY_ACK_t {
	BUS_PRIORITY_ACK = false;              // Goes to 1 once all arbiters have registered the new global priority levels. Arbiters update their local priority when servicing a new nonsequential access. In normal circumstances this will happen almost immediately.
 }

 // Bus priority acknowledge
 register BUS_PRIORITY_ACK_t BUS_PRIORITY_ACK at 0x40030004;

 type PERFCTR0_t {
	PERFCTR0 = uint24(0);          // Busfabric saturating performance counter 0 Count some event signal from the busfabric arbiters. Write any value to clear. Select an event to count using PERFSEL0
 }

 // Bus fabric performance counter 0
 register PERFCTR0_t PERFCTR0 at 0x40030008;

 type PERFSEL0_t {
	PERFSEL0 = uint5(0);           // Select an event for PERFCTR0. Count either contested accesses, or all accesses, on a downstream port of the main crossbar.
 }

 // Bus fabric performance event select for PERFCTR0
 register PERFSEL0_t PERFSEL0 at 0x4003000c;

 type PERFCTR1_t {
	PERFCTR1 = uint24(0);          // Busfabric saturating performance counter 1 Count some event signal from the busfabric arbiters. Write any value to clear. Select an event to count using PERFSEL1
 }

 // Bus fabric performance counter 1
 register PERFCTR1_t PERFCTR1 at 0x40030010;

 type PERFSEL1_t {
	PERFSEL1 = uint5(0);           // Select an event for PERFCTR1. Count either contested accesses, or all accesses, on a downstream port of the main crossbar.
 }

 // Bus fabric performance event select for PERFCTR1
 register PERFSEL1_t PERFSEL1 at 0x40030014;

 type PERFCTR2_t {
	PERFCTR2 = uint24(0);          // Busfabric saturating performance counter 2 Count some event signal from the busfabric arbiters. Write any value to clear. Select an event to count using PERFSEL2
 }

 // Bus fabric performance counter 2
 register PERFCTR2_t PERFCTR2 at 0x40030018;

 type PERFSEL2_t {
	PERFSEL2 = uint5(0);           // Select an event for PERFCTR2. Count either contested accesses, or all accesses, on a downstream port of the main crossbar.
 }

 // Bus fabric performance event select for PERFCTR2
 register PERFSEL2_t PERFSEL2 at 0x4003001c;

 type PERFCTR3_t {
	PERFCTR3 = uint24(0);          // Busfabric saturating performance counter 3 Count some event signal from the busfabric arbiters. Write any value to clear. Select an event to count using PERFSEL3
 }

 // Bus fabric performance counter 3
 register PERFCTR3_t PERFCTR3 at 0x40030020;

 type PERFSEL3_t {
	PERFSEL3 = uint5(0);           // Select an event for PERFCTR3. Count either contested accesses, or all accesses, on a downstream port of the main crossbar.
 }

 // Bus fabric performance event select for PERFCTR3
 register PERFSEL3_t PERFSEL3 at 0x40030024;


/* Types and registers for SIO 
  Single-cycle IO block Provides core-local and inter-core hardware for the two processors, with single-cycle access.
 */

 type SIO_CPUID_t {
	CPUID = uint32(0);          // Value is 0 when read from processor core 0, and 1 when read from processor core 1.
 }

 // Processor core identifier
 register SIO_CPUID_t SIO_CPUID at 0xd0000000;

 type GPIO_IN_t {
	IO0       = false;              // 
	IO1       = false;              // 
	IO2       = false;              // 
	IO3       = false;              // 
	IO4       = false;              // 
	IO5       = false;              // 
	IO6       = false;              // 
	IO7       = false;              // 
	IO8       = false;              // 
	IO9       = false;              // 
	IO10      = false;              // 
	IO11      = false;              // 
	IO12      = false;              // 
	IO13      = false;              // 
	IO14      = false;              // 
	IO15      = false;              // 
	IO16      = false;              // 
	IO17      = false;              // 
	IO18      = false;              // 
	IO19      = false;              // 
	IO20      = false;              // 
	IO21      = false;              // 
	IO22      = false;              // 
	IO23      = false;              // 
	IO24      = false;              // 
	IO25      = false;              // 
	IO26      = false;              // 
	IO27      = false;              // 
	IO28      = false;              // 
	IO29      = false;              // 
	_reserved = uint2(0);           // 
 }

 // Input value for GPIO pins
 register GPIO_IN_t GPIO_IN at 0xd0000004;

 type GPIO_HI_IN_t {
	GPIO_HI_IN = uint6(0);           // Input value on QSPI IO in order 0..5: SCLK, SSn, SD0, SD1, SD2, SD3
 }

 // Input value for QSPI pins
 register GPIO_HI_IN_t GPIO_HI_IN at 0xd0000008;

 type GPIO_OUT_t {
	IO0       = false;              // 
	IO1       = false;              // 
	IO2       = false;              // 
	IO3       = false;              // 
	IO4       = false;              // 
	IO5       = false;              // 
	IO6       = false;              // 
	IO7       = false;              // 
	IO8       = false;              // 
	IO9       = false;              // 
	IO10      = false;              // 
	IO11      = false;              // 
	IO12      = false;              // 
	IO13      = false;              // 
	IO14      = false;              // 
	IO15      = false;              // 
	IO16      = false;              // 
	IO17      = false;              // 
	IO18      = false;              // 
	IO19      = false;              // 
	IO20      = false;              // 
	IO21      = false;              // 
	IO22      = false;              // 
	IO23      = false;              // 
	IO24      = false;              // 
	IO25      = false;              // 
	IO26      = false;              // 
	IO27      = false;              // 
	IO28      = false;              // 
	IO29      = false;              // 
	_reserved = uint2(0);           // 
 }

 // GPIO output value: Set output level (1/0 -> high/low) for GPIO0...29. Reading back gives the last value written, NOT the input value from the pins. If core 0 and core 1 both write to GPIO_OUT simultaneously (or to a SET/CLR/XOR alias), the result is as though the write from core 0 took place first, and the write from core 1 was then applied to that intermediate result.
 register GPIO_OUT_t GPIO_OUT at 0xd0000010;

 type GPIO_OUT_SET_t {
	IO0       = false;              // 
	IO1       = false;              // 
	IO2       = false;              // 
	IO3       = false;              // 
	IO4       = false;              // 
	IO5       = false;              // 
	IO6       = false;              // 
	IO7       = false;              // 
	IO8       = false;              // 
	IO9       = false;              // 
	IO10      = false;              // 
	IO11      = false;              // 
	IO12      = false;              // 
	IO13      = false;              // 
	IO14      = false;              // 
	IO15      = false;              // 
	IO16      = false;              // 
	IO17      = false;              // 
	IO18      = false;              // 
	IO19      = false;              // 
	IO20      = false;              // 
	IO21      = false;              // 
	IO22      = false;              // 
	IO23      = false;              // 
	IO24      = false;              // 
	IO25      = false;              // 
	IO26      = false;              // 
	IO27      = false;              // 
	IO28      = false;              // 
	IO29      = false;              // 
	_reserved = uint2(0);           // 
 }

 // GPIO output value set: Perform an atomic bit-set on GPIO_OUT, i.e. `GPIO_OUT |= wdata`
 register GPIO_OUT_SET_t GPIO_OUT_SET at 0xd0000014;

 type GPIO_OUT_CLR_t {
	IO0       = false;              // 
	IO1       = false;              // 
	IO2       = false;              // 
	IO3       = false;              // 
	IO4       = false;              // 
	IO5       = false;              // 
	IO6       = false;              // 
	IO7       = false;              // 
	IO8       = false;              // 
	IO9       = false;              // 
	IO10      = false;              // 
	IO11      = false;              // 
	IO12      = false;              // 
	IO13      = false;              // 
	IO14      = false;              // 
	IO15      = false;              // 
	IO16      = false;              // 
	IO17      = false;              // 
	IO18      = false;              // 
	IO19      = false;              // 
	IO20      = false;              // 
	IO21      = false;              // 
	IO22      = false;              // 
	IO23      = false;              // 
	IO24      = false;              // 
	IO25      = false;              // 
	IO26      = false;              // 
	IO27      = false;              // 
	IO28      = false;              // 
	IO29      = false;              // 
	_reserved = uint2(0);           // 
 }

 // GPIO output value clear
 register GPIO_OUT_CLR_t GPIO_OUT_CLR at 0xd0000018;

 type GPIO_OUT_XOR_t {
	IO0       = false;              // 
	IO1       = false;              // 
	IO2       = false;              // 
	IO3       = false;              // 
	IO4       = false;              // 
	IO5       = false;              // 
	IO6       = false;              // 
	IO7       = false;              // 
	IO8       = false;              // 
	IO9       = false;              // 
	IO10      = false;              // 
	IO11      = false;              // 
	IO12      = false;              // 
	IO13      = false;              // 
	IO14      = false;              // 
	IO15      = false;              // 
	IO16      = false;              // 
	IO17      = false;              // 
	IO18      = false;              // 
	IO19      = false;              // 
	IO20      = false;              // 
	IO21      = false;              // 
	IO22      = false;              // 
	IO23      = false;              // 
	IO24      = false;              // 
	IO25      = false;              // 
	IO26      = false;              // 
	IO27      = false;              // 
	IO28      = false;              // 
	IO29      = false;              // 
	_reserved = uint2(0);           // 
 }

 // GPIO output value XOR
 register GPIO_OUT_XOR_t GPIO_OUT_XOR at 0xd000001c;

 type GPIO_OE_t {
	IO0       = false;              // 
	IO1       = false;              // 
	IO2       = false;              // 
	IO3       = false;              // 
	IO4       = false;              // 
	IO5       = false;              // 
	IO6       = false;              // 
	IO7       = false;              // 
	IO8       = false;              // 
	IO9       = false;              // 
	IO10      = false;              // 
	IO11      = false;              // 
	IO12      = false;              // 
	IO13      = false;              // 
	IO14      = false;              // 
	IO15      = false;              // 
	IO16      = false;              // 
	IO17      = false;              // 
	IO18      = false;              // 
	IO19      = false;              // 
	IO20      = false;              // 
	IO21      = false;              // 
	IO22      = false;              // 
	IO23      = false;              // 
	IO24      = false;              // 
	IO25      = false;              // 
	IO26      = false;              // 
	IO27      = false;              // 
	IO28      = false;              // 
	IO29      = false;              // 
	_reserved = uint2(0);           // 
 }

 // GPIO output enable: Set output enable (1/0 -> output/input) for GPIO0...29.
 register GPIO_OE_t GPIO_OE at 0xd0000020;

 type GPIO_OE_SET_t {
	IO0       = false;              // 
	IO1       = false;              // 
	IO2       = false;              // 
	IO3       = false;              // 
	IO4       = false;              // 
	IO5       = false;              // 
	IO6       = false;              // 
	IO7       = false;              // 
	IO8       = false;              // 
	IO9       = false;              // 
	IO10      = false;              // 
	IO11      = false;              // 
	IO12      = false;              // 
	IO13      = false;              // 
	IO14      = false;              // 
	IO15      = false;              // 
	IO16      = false;              // 
	IO17      = false;              // 
	IO18      = false;              // 
	IO19      = false;              // 
	IO20      = false;              // 
	IO21      = false;              // 
	IO22      = false;              // 
	IO23      = false;              // 
	IO24      = false;              // 
	IO25      = false;              // 
	IO26      = false;              // 
	IO27      = false;              // 
	IO28      = false;              // 
	IO29      = false;              // 
	_reserved = uint2(0);           // 
 }

 // GPIO output enable set: Perform an atomic bit-set on GPIO_OE, i.e. `GPIO_OE |= wdata`
 register GPIO_OE_SET_t GPIO_OE_SET at 0xd0000024;

 type GPIO_OE_CLR_t {
	IO0       = false;              // 
	IO1       = false;              // 
	IO2       = false;              // 
	IO3       = false;              // 
	IO4       = false;              // 
	IO5       = false;              // 
	IO6       = false;              // 
	IO7       = false;              // 
	IO8       = false;              // 
	IO9       = false;              // 
	IO10      = false;              // 
	IO11      = false;              // 
	IO12      = false;              // 
	IO13      = false;              // 
	IO14      = false;              // 
	IO15      = false;              // 
	IO16      = false;              // 
	IO17      = false;              // 
	IO18      = false;              // 
	IO19      = false;              // 
	IO20      = false;              // 
	IO21      = false;              // 
	IO22      = false;              // 
	IO23      = false;              // 
	IO24      = false;              // 
	IO25      = false;              // 
	IO26      = false;              // 
	IO27      = false;              // 
	IO28      = false;              // 
	IO29      = false;              // 
	_reserved = uint2(0);           // 
 }

 // GPIO output enable clear: Perform an atomic bit-clear on GPIO_OE, i.e. `GPIO_OE &= ~wdata`
 register GPIO_OE_CLR_t GPIO_OE_CLR at 0xd0000028;

 type GPIO_OE_XOR_t {
	IO0       = false;              // 
	IO1       = false;              // 
	IO2       = false;              // 
	IO3       = false;              // 
	IO4       = false;              // 
	IO5       = false;              // 
	IO6       = false;              // 
	IO7       = false;              // 
	IO8       = false;              // 
	IO9       = false;              // 
	IO10      = false;              // 
	IO11      = false;              // 
	IO12      = false;              // 
	IO13      = false;              // 
	IO14      = false;              // 
	IO15      = false;              // 
	IO16      = false;              // 
	IO17      = false;              // 
	IO18      = false;              // 
	IO19      = false;              // 
	IO20      = false;              // 
	IO21      = false;              // 
	IO22      = false;              // 
	IO23      = false;              // 
	IO24      = false;              // 
	IO25      = false;              // 
	IO26      = false;              // 
	IO27      = false;              // 
	IO28      = false;              // 
	IO29      = false;              // 
	_reserved = uint2(0);           // 
 }

 // GPIO output enable XOR: Perform an atomic bitwise XOR on GPIO_OE, i.e. `GPIO_OE ^= wdata`
 register GPIO_OE_XOR_t GPIO_OE_XOR at 0xd000002c;

 type GPIO_HI_OUT_t {
	GPIO_HI_OUT = uint6(0);           // Set output level (1/0 -> high/low) for QSPI IO0...5. Reading back gives the last value written, NOT the input value from the pins. If core 0 and core 1 both write to GPIO_HI_OUT simultaneously (or to a SET/CLR/XOR alias), the result is as though the write from core 0 took place first, and the write from core 1 was then applied to that intermediate result.
 }

 // QSPI output value
 register GPIO_HI_OUT_t GPIO_HI_OUT at 0xd0000030;

 type GPIO_HI_OUT_SET_t {
	GPIO_HI_OUT_SET = uint6(0);           // Perform an atomic bit-set on GPIO_HI_OUT, i.e. `GPIO_HI_OUT |= wdata`
 }

 // QSPI output value set
 register GPIO_HI_OUT_SET_t GPIO_HI_OUT_SET at 0xd0000034;

 type GPIO_HI_OUT_CLR_t {
	GPIO_HI_OUT_CLR = uint6(0);           // Perform an atomic bit-clear on GPIO_HI_OUT, i.e. `GPIO_HI_OUT &= ~wdata`
 }

 // QSPI output value clear
 register GPIO_HI_OUT_CLR_t GPIO_HI_OUT_CLR at 0xd0000038;

 type GPIO_HI_OUT_XOR_t {
	GPIO_HI_OUT_XOR = uint6(0);           // Perform an atomic bitwise XOR on GPIO_HI_OUT, i.e. `GPIO_HI_OUT ^= wdata`
 }

 // QSPI output value XOR
 register GPIO_HI_OUT_XOR_t GPIO_HI_OUT_XOR at 0xd000003c;

 type GPIO_HI_OE_t {
	GPIO_HI_OE = uint6(0);           // Set output enable (1/0 -> output/input) for QSPI IO0...5. Reading back gives the last value written. If core 0 and core 1 both write to GPIO_HI_OE simultaneously (or to a SET/CLR/XOR alias), the result is as though the write from core 0 took place first, and the write from core 1 was then applied to that intermediate result.
 }

 // QSPI output enable
 register GPIO_HI_OE_t GPIO_HI_OE at 0xd0000040;

 type GPIO_HI_OE_SET_t {
	GPIO_HI_OE_SET = uint6(0);           // Perform an atomic bit-set on GPIO_HI_OE, i.e. `GPIO_HI_OE |= wdata`
 }

 // QSPI output enable set
 register GPIO_HI_OE_SET_t GPIO_HI_OE_SET at 0xd0000044;

 type GPIO_HI_OE_CLR_t {
	GPIO_HI_OE_CLR = uint6(0);           // Perform an atomic bit-clear on GPIO_HI_OE, i.e. `GPIO_HI_OE &= ~wdata`
 }

 // QSPI output enable clear
 register GPIO_HI_OE_CLR_t GPIO_HI_OE_CLR at 0xd0000048;

 type GPIO_HI_OE_XOR_t {
	GPIO_HI_OE_XOR = uint6(0);           // Perform an atomic bitwise XOR on GPIO_HI_OE, i.e. `GPIO_HI_OE ^= wdata`
 }

 // QSPI output enable XOR
 register GPIO_HI_OE_XOR_t GPIO_HI_OE_XOR at 0xd000004c;

 type FIFO_ST_t {
	VLD = false;              // Value is 1 if this core's RX FIFO is not empty (i.e. if FIFO_RD is valid)
	RDY = false;              // Value is 1 if this core's TX FIFO is not full (i.e. if FIFO_WR is ready for more data)
	WOF = false;              // Sticky flag indicating the TX FIFO was written when full. This write was ignored by the FIFO.
	ROE = false;              // Sticky flag indicating the RX FIFO was read when empty. This read was ignored by the FIFO.
 }

 // Status register for inter-core FIFOs (mailboxes). There is one FIFO in the core 0 -> core 1 direction, and one core 1 -> core 0. Both are 32 bits wide and 8 words deep. Core 0 can see the read side of the 1->0 FIFO (RX), and the write side of 0->1 FIFO (TX). Core 1 can see the read side of the 0->1 FIFO (RX), and the write side of 1->0 FIFO (TX). The SIO IRQ for each core is the logical OR of the VLD, WOF and ROE fields of its FIFO_ST register.
 register FIFO_ST_t FIFO_ST at 0xd0000050;

 type FIFO_WR_t {
	FIFO_WR = uint32(0);          // 
 }

 // Write access to this core's TX FIFO
 register FIFO_WR_t FIFO_WR at 0xd0000054;

 type FIFO_RD_t {
	FIFO_RD = uint32(0);          // 
 }

 // Read access to this core's RX FIFO
 register FIFO_RD_t FIFO_RD at 0xd0000058;

 type SPINLOCK_ST_t {
	SPINLOCK_ST = uint32(0);          // 
 }

 // Spinlock state A bitmap containing the state of all 32 spinlocks (1=locked). Mainly intended for debugging.
 register SPINLOCK_ST_t SPINLOCK_ST at 0xd000005c;

 type DIV_UDIVIDEND_t {
	DIV_UDIVIDEND = uint32(0);          // 
 }

 // Divider unsigned dividend Write to the DIVIDEND operand of the divider, i.e. the p in `p / q`. Any operand write starts a new calculation. The results appear in QUOTIENT, REMAINDER. UDIVIDEND/SDIVIDEND are aliases of the same internal register. The U alias starts an unsigned calculation, and the S alias starts a signed calculation.
 register DIV_UDIVIDEND_t DIV_UDIVIDEND at 0xd0000060;

 type DIV_UDIVISOR_t {
	DIV_UDIVISOR = uint32(0);          // 
 }

 // Divider unsigned divisor Write to the DIVISOR operand of the divider, i.e. the q in `p / q`. Any operand write starts a new calculation. The results appear in QUOTIENT, REMAINDER. UDIVISOR/SDIVISOR are aliases of the same internal register. The U alias starts an unsigned calculation, and the S alias starts a signed calculation.
 register DIV_UDIVISOR_t DIV_UDIVISOR at 0xd0000064;

 type DIV_SDIVIDEND_t {
	DIV_SDIVIDEND = uint32(0);          // 
 }

 // Divider signed dividend The same as UDIVIDEND, but starts a signed calculation, rather than unsigned.
 register DIV_SDIVIDEND_t DIV_SDIVIDEND at 0xd0000068;

 type DIV_SDIVISOR_t {
	DIV_SDIVISOR = uint32(0);          // 
 }

 // Divider signed divisor The same as UDIVISOR, but starts a signed calculation, rather than unsigned.
 register DIV_SDIVISOR_t DIV_SDIVISOR at 0xd000006c;

 type DIV_QUOTIENT_t {
	DIV_QUOTIENT = uint32(0);          // 
 }

 // Divider result quotient The result of `DIVIDEND / DIVISOR` (division). Contents undefined while CSR_READY is low. For signed calculations, QUOTIENT is negative when the signs of DIVIDEND and DIVISOR differ. This register can be written to directly, for context save/restore purposes. This halts any in-progress calculation and sets the CSR_READY and CSR_DIRTY flags. Reading from QUOTIENT clears the CSR_DIRTY flag, so should read results in the order REMAINDER, QUOTIENT if CSR_DIRTY is used.
 register DIV_QUOTIENT_t DIV_QUOTIENT at 0xd0000070;

 type DIV_REMAINDER_t {
	DIV_REMAINDER = uint32(0);          // 
 }

 // Divider result remainder The result of `DIVIDEND % DIVISOR` (modulo). Contents undefined while CSR_READY is low. For signed calculations, REMAINDER is negative only when DIVIDEND is negative. This register can be written to directly, for context save/restore purposes. This halts any in-progress calculation and sets the CSR_READY and CSR_DIRTY flags.
 register DIV_REMAINDER_t DIV_REMAINDER at 0xd0000074;

 type DIV_CSR_t {
	READY = false;              // Reads as 0 when a calculation is in progress, 1 otherwise. Writing an operand (xDIVIDEND, xDIVISOR) will immediately start a new calculation, no matter if one is already in progress. Writing to a result register will immediately terminate any in-progress calculation and set the READY and DIRTY flags.
	DIRTY = false;              // Changes to 1 when any register is written, and back to 0 when QUOTIENT is read. Software can use this flag to make save/restore more efficient (skip if not DIRTY). If the flag is used in this way, it's recommended to either read QUOTIENT only, or REMAINDER and then QUOTIENT, to prevent data loss on context switch.
 }

 // Control and status register for divider.
 register DIV_CSR_t DIV_CSR at 0xd0000078;

 type INTERP0_ACCUM0_t {
	INTERP0_ACCUM0 = uint32(0);          // 
 }

 // Read/write access to accumulator 0
 register INTERP0_ACCUM0_t INTERP0_ACCUM0 at 0xd0000080;

 type INTERP0_ACCUM1_t {
	INTERP0_ACCUM1 = uint32(0);          // 
 }

 // Read/write access to accumulator 1
 register INTERP0_ACCUM1_t INTERP0_ACCUM1 at 0xd0000084;

 type INTERP0_BASE0_t {
	INTERP0_BASE0 = uint32(0);          // 
 }

 // Read/write access to BASE0 register.
 register INTERP0_BASE0_t INTERP0_BASE0 at 0xd0000088;

 type INTERP0_BASE1_t {
	INTERP0_BASE1 = uint32(0);          // 
 }

 // Read/write access to BASE1 register.
 register INTERP0_BASE1_t INTERP0_BASE1 at 0xd000008c;

 type INTERP0_BASE2_t {
	INTERP0_BASE2 = uint32(0);          // 
 }

 // Read/write access to BASE2 register.
 register INTERP0_BASE2_t INTERP0_BASE2 at 0xd0000090;

 type INTERP0_POP_LANE0_t {
	INTERP0_POP_LANE0 = uint32(0);          // 
 }

 // Read LANE0 result, and simultaneously write lane results to both accumulators (POP).
 register INTERP0_POP_LANE0_t INTERP0_POP_LANE0 at 0xd0000094;

 type INTERP0_POP_LANE1_t {
	INTERP0_POP_LANE1 = uint32(0);          // 
 }

 // Read LANE1 result, and simultaneously write lane results to both accumulators (POP).
 register INTERP0_POP_LANE1_t INTERP0_POP_LANE1 at 0xd0000098;

 type INTERP0_POP_FULL_t {
	INTERP0_POP_FULL = uint32(0);          // 
 }

 // Read FULL result, and simultaneously write lane results to both accumulators (POP).
 register INTERP0_POP_FULL_t INTERP0_POP_FULL at 0xd000009c;

 type INTERP0_PEEK_LANE0_t {
	INTERP0_PEEK_LANE0 = uint32(0);          // 
 }

 // Read LANE0 result, without altering any internal state (PEEK).
 register INTERP0_PEEK_LANE0_t INTERP0_PEEK_LANE0 at 0xd00000a0;

 type INTERP0_PEEK_LANE1_t {
	INTERP0_PEEK_LANE1 = uint32(0);          // 
 }

 // Read LANE1 result, without altering any internal state (PEEK).
 register INTERP0_PEEK_LANE1_t INTERP0_PEEK_LANE1 at 0xd00000a4;

 type INTERP0_PEEK_FULL_t {
	INTERP0_PEEK_FULL = uint32(0);          // 
 }

 // Read FULL result, without altering any internal state (PEEK).
 register INTERP0_PEEK_FULL_t INTERP0_PEEK_FULL at 0xd00000a8;

 type INTERP0_CTRL_LANE0_t {
	SHIFT        = uint5(0);           // Logical right-shift applied to accumulator before masking
	MASK_LSB     = uint5(0);           // The least-significant bit allowed to pass by the mask (inclusive)
	MASK_MSB     = uint5(0);           // The most-significant bit allowed to pass by the mask (inclusive) Setting MSB < LSB may cause chip to turn inside-out
	SIGNED       = false;              // If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read by processor.
	CROSS_INPUT  = false;              // If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware. Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)
	CROSS_RESULT = false;              // If 1, feed the opposite lane's result into this lane's accumulator on POP.
	ADD_RAW      = false;              // If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result.
	FORCE_MSB    = uint2(0);           // ORed into bits 29:28 of the lane result presented to the processor on the bus. No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence of pointers into flash or SRAM.
	BLEND        = false;              // Only present on INTERP0 on each core. If BLEND mode is enabled: - LANE1 result is a linear interpolation between BASE0 and BASE1, controlled by the 8 LSBs of lane 1 shift and mask value (a fractional number between 0 and 255/256ths) - LANE0 result does not have BASE0 added (yields only the 8 LSBs of lane 1 shift+mask value) - FULL result does not have lane 1 shift+mask value added (BASE2 + lane 0 shift+mask) LANE1 SIGNED flag controls whether the interpolation is signed or unsigned.
	_res1        = false;              // Reserved, 1 bits
	OVERF0       = false;              // Indicates if any masked-off MSBs in ACCUM0 are set.
	OVERF1       = false;              // Indicates if any masked-off MSBs in ACCUM1 are set.
	OVERF        = false;              // Set if either OVERF0 or OVERF1 is set.
 }

 // Control register for lane 0
 register INTERP0_CTRL_LANE0_t INTERP0_CTRL_LANE0 at 0xd00000ac;

 type INTERP0_CTRL_LANE1_t {
	SHIFT        = uint5(0);           // Logical right-shift applied to accumulator before masking
	MASK_LSB     = uint5(0);           // The least-significant bit allowed to pass by the mask (inclusive)
	MASK_MSB     = uint5(0);           // The most-significant bit allowed to pass by the mask (inclusive) Setting MSB < LSB may cause chip to turn inside-out
	SIGNED       = false;              // If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits before adding to BASE1, and LANE1 PEEK/POP appear extended to 32 bits when read by processor.
	CROSS_INPUT  = false;              // If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware. Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)
	CROSS_RESULT = false;              // If 1, feed the opposite lane's result into this lane's accumulator on POP.
	ADD_RAW      = false;              // If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL result.
	FORCE_MSB    = uint2(0);           // ORed into bits 29:28 of the lane result presented to the processor on the bus. No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence of pointers into flash or SRAM.
 }

 // Control register for lane 1
 register INTERP0_CTRL_LANE1_t INTERP0_CTRL_LANE1 at 0xd00000b0;

 type INTERP0_ACCUM0_ADD_t {
	INTERP0_ACCUM0_ADD = uint24(0);          // 
 }

 // Values written here are atomically added to ACCUM0 Reading yields lane 0's raw shift and mask value (BASE0 not added).
 register INTERP0_ACCUM0_ADD_t INTERP0_ACCUM0_ADD at 0xd00000b4;

 type INTERP0_ACCUM1_ADD_t {
	INTERP0_ACCUM1_ADD = uint24(0);          // 
 }

 // Values written here are atomically added to ACCUM1 Reading yields lane 1's raw shift and mask value (BASE1 not added).
 register INTERP0_ACCUM1_ADD_t INTERP0_ACCUM1_ADD at 0xd00000b8;

 type INTERP0_BASE_1AND0_t {
	INTERP0_BASE_1AND0 = uint32(0);          // 
 }

 // On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously. Each half is sign-extended to 32 bits if that lane's SIGNED flag is set.
 register INTERP0_BASE_1AND0_t INTERP0_BASE_1AND0 at 0xd00000bc;

 type INTERP1_ACCUM0_t {
	INTERP1_ACCUM0 = uint32(0);          // 
 }

 // Read/write access to accumulator 0
 register INTERP1_ACCUM0_t INTERP1_ACCUM0 at 0xd00000c0;

 type INTERP1_ACCUM1_t {
	INTERP1_ACCUM1 = uint32(0);          // 
 }

 // Read/write access to accumulator 1
 register INTERP1_ACCUM1_t INTERP1_ACCUM1 at 0xd00000c4;

 type INTERP1_BASE0_t {
	INTERP1_BASE0 = uint32(0);          // 
 }

 // Read/write access to BASE0 register.
 register INTERP1_BASE0_t INTERP1_BASE0 at 0xd00000c8;

 type INTERP1_BASE1_t {
	INTERP1_BASE1 = uint32(0);          // 
 }

 // Read/write access to BASE1 register.
 register INTERP1_BASE1_t INTERP1_BASE1 at 0xd00000cc;

 type INTERP1_BASE2_t {
	INTERP1_BASE2 = uint32(0);          // 
 }

 // Read/write access to BASE2 register.
 register INTERP1_BASE2_t INTERP1_BASE2 at 0xd00000d0;

 type INTERP1_POP_LANE0_t {
	INTERP1_POP_LANE0 = uint32(0);          // 
 }

 // Read LANE0 result, and simultaneously write lane results to both accumulators (POP).
 register INTERP1_POP_LANE0_t INTERP1_POP_LANE0 at 0xd00000d4;

 type INTERP1_POP_LANE1_t {
	INTERP1_POP_LANE1 = uint32(0);          // 
 }

 // Read LANE1 result, and simultaneously write lane results to both accumulators (POP).
 register INTERP1_POP_LANE1_t INTERP1_POP_LANE1 at 0xd00000d8;

 type INTERP1_POP_FULL_t {
	INTERP1_POP_FULL = uint32(0);          // 
 }

 // Read FULL result, and simultaneously write lane results to both accumulators (POP).
 register INTERP1_POP_FULL_t INTERP1_POP_FULL at 0xd00000dc;

 type INTERP1_PEEK_LANE0_t {
	INTERP1_PEEK_LANE0 = uint32(0);          // 
 }

 // Read LANE0 result, without altering any internal state (PEEK).
 register INTERP1_PEEK_LANE0_t INTERP1_PEEK_LANE0 at 0xd00000e0;

 type INTERP1_PEEK_LANE1_t {
	INTERP1_PEEK_LANE1 = uint32(0);          // 
 }

 // Read LANE1 result, without altering any internal state (PEEK).
 register INTERP1_PEEK_LANE1_t INTERP1_PEEK_LANE1 at 0xd00000e4;

 type INTERP1_PEEK_FULL_t {
	INTERP1_PEEK_FULL = uint32(0);          // 
 }

 // Read FULL result, without altering any internal state (PEEK).
 register INTERP1_PEEK_FULL_t INTERP1_PEEK_FULL at 0xd00000e8;

 type INTERP1_CTRL_LANE0_t {
	SHIFT        = uint5(0);           // Logical right-shift applied to accumulator before masking
	MASK_LSB     = uint5(0);           // The least-significant bit allowed to pass by the mask (inclusive)
	MASK_MSB     = uint5(0);           // The most-significant bit allowed to pass by the mask (inclusive) Setting MSB < LSB may cause chip to turn inside-out
	SIGNED       = false;              // If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read by processor.
	CROSS_INPUT  = false;              // If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware. Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)
	CROSS_RESULT = false;              // If 1, feed the opposite lane's result into this lane's accumulator on POP.
	ADD_RAW      = false;              // If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result.
	FORCE_MSB    = uint2(0);           // ORed into bits 29:28 of the lane result presented to the processor on the bus. No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence of pointers into flash or SRAM.
	_res1        = false;              // Reserved, 1 bits
	CLAMP        = false;              // Only present on INTERP1 on each core. If CLAMP mode is enabled: - LANE0 result is shifted and masked ACCUM0, clamped by a lower bound of BASE0 and an upper bound of BASE1. - Signedness of these comparisons is determined by LANE0_CTRL_SIGNED
	OVERF0       = false;              // Indicates if any masked-off MSBs in ACCUM0 are set.
	OVERF1       = false;              // Indicates if any masked-off MSBs in ACCUM1 are set.
	OVERF        = false;              // Set if either OVERF0 or OVERF1 is set.
 }

 // Control register for lane 0
 register INTERP1_CTRL_LANE0_t INTERP1_CTRL_LANE0 at 0xd00000ec;

 type INTERP1_CTRL_LANE1_t {
	SHIFT        = uint5(0);           // Logical right-shift applied to accumulator before masking
	MASK_LSB     = uint5(0);           // The least-significant bit allowed to pass by the mask (inclusive)
	MASK_MSB     = uint5(0);           // The most-significant bit allowed to pass by the mask (inclusive) Setting MSB < LSB may cause chip to turn inside-out
	SIGNED       = false;              // If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits before adding to BASE1, and LANE1 PEEK/POP appear extended to 32 bits when read by processor.
	CROSS_INPUT  = false;              // If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware. Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)
	CROSS_RESULT = false;              // If 1, feed the opposite lane's result into this lane's accumulator on POP.
	ADD_RAW      = false;              // If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL result.
	FORCE_MSB    = uint2(0);           // ORed into bits 29:28 of the lane result presented to the processor on the bus. No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence of pointers into flash or SRAM.
 }

 // Control register for lane 1
 register INTERP1_CTRL_LANE1_t INTERP1_CTRL_LANE1 at 0xd00000f0;

 type INTERP1_ACCUM0_ADD_t {
	INTERP1_ACCUM0_ADD = uint24(0);          // 
 }

 // Values written here are atomically added to ACCUM0 Reading yields lane 0's raw shift and mask value (BASE0 not added).
 register INTERP1_ACCUM0_ADD_t INTERP1_ACCUM0_ADD at 0xd00000f4;

 type INTERP1_ACCUM1_ADD_t {
	INTERP1_ACCUM1_ADD = uint24(0);          // 
 }

 // Values written here are atomically added to ACCUM1 Reading yields lane 1's raw shift and mask value (BASE1 not added).
 register INTERP1_ACCUM1_ADD_t INTERP1_ACCUM1_ADD at 0xd00000f8;

 type INTERP1_BASE_1AND0_t {
	INTERP1_BASE_1AND0 = uint32(0);          // 
 }

 // On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously. Each half is sign-extended to 32 bits if that lane's SIGNED flag is set.
 register INTERP1_BASE_1AND0_t INTERP1_BASE_1AND0 at 0xd00000fc;

 type SPINLOCK0_t {
	SPINLOCK0 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK0_t SPINLOCK0 at 0xd0000100;

 type SPINLOCK1_t {
	SPINLOCK1 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK1_t SPINLOCK1 at 0xd0000104;

 type SPINLOCK2_t {
	SPINLOCK2 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK2_t SPINLOCK2 at 0xd0000108;

 type SPINLOCK3_t {
	SPINLOCK3 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK3_t SPINLOCK3 at 0xd000010c;

 type SPINLOCK4_t {
	SPINLOCK4 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK4_t SPINLOCK4 at 0xd0000110;

 type SPINLOCK5_t {
	SPINLOCK5 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK5_t SPINLOCK5 at 0xd0000114;

 type SPINLOCK6_t {
	SPINLOCK6 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK6_t SPINLOCK6 at 0xd0000118;

 type SPINLOCK7_t {
	SPINLOCK7 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK7_t SPINLOCK7 at 0xd000011c;

 type SPINLOCK8_t {
	SPINLOCK8 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK8_t SPINLOCK8 at 0xd0000120;

 type SPINLOCK9_t {
	SPINLOCK9 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK9_t SPINLOCK9 at 0xd0000124;

 type SPINLOCK10_t {
	SPINLOCK10 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK10_t SPINLOCK10 at 0xd0000128;

 type SPINLOCK11_t {
	SPINLOCK11 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK11_t SPINLOCK11 at 0xd000012c;

 type SPINLOCK12_t {
	SPINLOCK12 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK12_t SPINLOCK12 at 0xd0000130;

 type SPINLOCK13_t {
	SPINLOCK13 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK13_t SPINLOCK13 at 0xd0000134;

 type SPINLOCK14_t {
	SPINLOCK14 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK14_t SPINLOCK14 at 0xd0000138;

 type SPINLOCK15_t {
	SPINLOCK15 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK15_t SPINLOCK15 at 0xd000013c;

 type SPINLOCK16_t {
	SPINLOCK16 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK16_t SPINLOCK16 at 0xd0000140;

 type SPINLOCK17_t {
	SPINLOCK17 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK17_t SPINLOCK17 at 0xd0000144;

 type SPINLOCK18_t {
	SPINLOCK18 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK18_t SPINLOCK18 at 0xd0000148;

 type SPINLOCK19_t {
	SPINLOCK19 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK19_t SPINLOCK19 at 0xd000014c;

 type SPINLOCK20_t {
	SPINLOCK20 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK20_t SPINLOCK20 at 0xd0000150;

 type SPINLOCK21_t {
	SPINLOCK21 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK21_t SPINLOCK21 at 0xd0000154;

 type SPINLOCK22_t {
	SPINLOCK22 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK22_t SPINLOCK22 at 0xd0000158;

 type SPINLOCK23_t {
	SPINLOCK23 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK23_t SPINLOCK23 at 0xd000015c;

 type SPINLOCK24_t {
	SPINLOCK24 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK24_t SPINLOCK24 at 0xd0000160;

 type SPINLOCK25_t {
	SPINLOCK25 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK25_t SPINLOCK25 at 0xd0000164;

 type SPINLOCK26_t {
	SPINLOCK26 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK26_t SPINLOCK26 at 0xd0000168;

 type SPINLOCK27_t {
	SPINLOCK27 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK27_t SPINLOCK27 at 0xd000016c;

 type SPINLOCK28_t {
	SPINLOCK28 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK28_t SPINLOCK28 at 0xd0000170;

 type SPINLOCK29_t {
	SPINLOCK29 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK29_t SPINLOCK29 at 0xd0000174;

 type SPINLOCK30_t {
	SPINLOCK30 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK30_t SPINLOCK30 at 0xd0000178;

 type SPINLOCK31_t {
	SPINLOCK31 = uint32(0);          // 
 }

 // Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
 register SPINLOCK31_t SPINLOCK31 at 0xd000017c;


/* Types and registers for USB 
  USB FS/LS controller device registers
 */

 type ADDR_ENDP_t {
	ADDRESS  = uint7(0);           // In device mode, the address that the device should respond to. Set in response to a SET_ADDR setup packet from the host. In host mode set to the address of the device to communicate with.
	_res1    = uint8(0);           // Reserved, 9 bits
	_res2    = false;              // 
	ENDPOINT = uint4(0);           // Device endpoint to send data to. Only valid for HOST mode.
 }

 // Device address and endpoint control
 register ADDR_ENDP_t ADDR_ENDP at 0x50110000;

 type ADDR_ENDP1_t {
	ADDRESS        = uint7(0);           // Device address
	_res1          = uint8(0);           // Reserved, 9 bits
	_res2          = false;              // 
	ENDPOINT       = uint4(0);           // Endpoint number of the interrupt endpoint
	_res3          = uint5(0);           // Reserved, 5 bits
	INTEP_DIR      = false;              // Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE = false;              // Interrupt EP requires preamble (is a low speed device on a full speed hub)
 }

 // Interrupt endpoint 1. Only valid for HOST mode.
 register ADDR_ENDP1_t ADDR_ENDP1 at 0x50110004;

 type ADDR_ENDP2_t {
	ADDRESS        = uint7(0);           // Device address
	_res1          = uint8(0);           // Reserved, 9 bits
	_res2          = false;              // 
	ENDPOINT       = uint4(0);           // Endpoint number of the interrupt endpoint
	_res3          = uint5(0);           // Reserved, 5 bits
	INTEP_DIR      = false;              // Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE = false;              // Interrupt EP requires preamble (is a low speed device on a full speed hub)
 }

 // Interrupt endpoint 2. Only valid for HOST mode.
 register ADDR_ENDP2_t ADDR_ENDP2 at 0x50110008;

 type ADDR_ENDP3_t {
	ADDRESS        = uint7(0);           // Device address
	_res1          = uint8(0);           // Reserved, 9 bits
	_res2          = false;              // 
	ENDPOINT       = uint4(0);           // Endpoint number of the interrupt endpoint
	_res3          = uint5(0);           // Reserved, 5 bits
	INTEP_DIR      = false;              // Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE = false;              // Interrupt EP requires preamble (is a low speed device on a full speed hub)
 }

 // Interrupt endpoint 3. Only valid for HOST mode.
 register ADDR_ENDP3_t ADDR_ENDP3 at 0x5011000c;

 type ADDR_ENDP4_t {
	ADDRESS        = uint7(0);           // Device address
	_res1          = uint8(0);           // Reserved, 9 bits
	_res2          = false;              // 
	ENDPOINT       = uint4(0);           // Endpoint number of the interrupt endpoint
	_res3          = uint5(0);           // Reserved, 5 bits
	INTEP_DIR      = false;              // Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE = false;              // Interrupt EP requires preamble (is a low speed device on a full speed hub)
 }

 // Interrupt endpoint 4. Only valid for HOST mode.
 register ADDR_ENDP4_t ADDR_ENDP4 at 0x50110010;

 type ADDR_ENDP5_t {
	ADDRESS        = uint7(0);           // Device address
	_res1          = uint8(0);           // Reserved, 9 bits
	_res2          = false;              // 
	ENDPOINT       = uint4(0);           // Endpoint number of the interrupt endpoint
	_res3          = uint5(0);           // Reserved, 5 bits
	INTEP_DIR      = false;              // Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE = false;              // Interrupt EP requires preamble (is a low speed device on a full speed hub)
 }

 // Interrupt endpoint 5. Only valid for HOST mode.
 register ADDR_ENDP5_t ADDR_ENDP5 at 0x50110014;

 type ADDR_ENDP6_t {
	ADDRESS        = uint7(0);           // Device address
	_res1          = uint8(0);           // Reserved, 9 bits
	_res2          = false;              // 
	ENDPOINT       = uint4(0);           // Endpoint number of the interrupt endpoint
	_res3          = uint5(0);           // Reserved, 5 bits
	INTEP_DIR      = false;              // Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE = false;              // Interrupt EP requires preamble (is a low speed device on a full speed hub)
 }

 // Interrupt endpoint 6. Only valid for HOST mode.
 register ADDR_ENDP6_t ADDR_ENDP6 at 0x50110018;

 type ADDR_ENDP7_t {
	ADDRESS        = uint7(0);           // Device address
	_res1          = uint8(0);           // Reserved, 9 bits
	_res2          = false;              // 
	ENDPOINT       = uint4(0);           // Endpoint number of the interrupt endpoint
	_res3          = uint5(0);           // Reserved, 5 bits
	INTEP_DIR      = false;              // Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE = false;              // Interrupt EP requires preamble (is a low speed device on a full speed hub)
 }

 // Interrupt endpoint 7. Only valid for HOST mode.
 register ADDR_ENDP7_t ADDR_ENDP7 at 0x5011001c;

 type ADDR_ENDP8_t {
	ADDRESS        = uint7(0);           // Device address
	_res1          = uint8(0);           // Reserved, 9 bits
	_res2          = false;              // 
	ENDPOINT       = uint4(0);           // Endpoint number of the interrupt endpoint
	_res3          = uint5(0);           // Reserved, 5 bits
	INTEP_DIR      = false;              // Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE = false;              // Interrupt EP requires preamble (is a low speed device on a full speed hub)
 }

 // Interrupt endpoint 8. Only valid for HOST mode.
 register ADDR_ENDP8_t ADDR_ENDP8 at 0x50110020;

 type ADDR_ENDP9_t {
	ADDRESS        = uint7(0);           // Device address
	_res1          = uint8(0);           // Reserved, 9 bits
	_res2          = false;              // 
	ENDPOINT       = uint4(0);           // Endpoint number of the interrupt endpoint
	_res3          = uint5(0);           // Reserved, 5 bits
	INTEP_DIR      = false;              // Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE = false;              // Interrupt EP requires preamble (is a low speed device on a full speed hub)
 }

 // Interrupt endpoint 9. Only valid for HOST mode.
 register ADDR_ENDP9_t ADDR_ENDP9 at 0x50110024;

 type ADDR_ENDP10_t {
	ADDRESS        = uint7(0);           // Device address
	_res1          = uint8(0);           // Reserved, 9 bits
	_res2          = false;              // 
	ENDPOINT       = uint4(0);           // Endpoint number of the interrupt endpoint
	_res3          = uint5(0);           // Reserved, 5 bits
	INTEP_DIR      = false;              // Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE = false;              // Interrupt EP requires preamble (is a low speed device on a full speed hub)
 }

 // Interrupt endpoint 10. Only valid for HOST mode.
 register ADDR_ENDP10_t ADDR_ENDP10 at 0x50110028;

 type ADDR_ENDP11_t {
	ADDRESS        = uint7(0);           // Device address
	_res1          = uint8(0);           // Reserved, 9 bits
	_res2          = false;              // 
	ENDPOINT       = uint4(0);           // Endpoint number of the interrupt endpoint
	_res3          = uint5(0);           // Reserved, 5 bits
	INTEP_DIR      = false;              // Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE = false;              // Interrupt EP requires preamble (is a low speed device on a full speed hub)
 }

 // Interrupt endpoint 11. Only valid for HOST mode.
 register ADDR_ENDP11_t ADDR_ENDP11 at 0x5011002c;

 type ADDR_ENDP12_t {
	ADDRESS        = uint7(0);           // Device address
	_res1          = uint8(0);           // Reserved, 9 bits
	_res2          = false;              // 
	ENDPOINT       = uint4(0);           // Endpoint number of the interrupt endpoint
	_res3          = uint5(0);           // Reserved, 5 bits
	INTEP_DIR      = false;              // Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE = false;              // Interrupt EP requires preamble (is a low speed device on a full speed hub)
 }

 // Interrupt endpoint 12. Only valid for HOST mode.
 register ADDR_ENDP12_t ADDR_ENDP12 at 0x50110030;

 type ADDR_ENDP13_t {
	ADDRESS        = uint7(0);           // Device address
	_res1          = uint8(0);           // Reserved, 9 bits
	_res2          = false;              // 
	ENDPOINT       = uint4(0);           // Endpoint number of the interrupt endpoint
	_res3          = uint5(0);           // Reserved, 5 bits
	INTEP_DIR      = false;              // Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE = false;              // Interrupt EP requires preamble (is a low speed device on a full speed hub)
 }

 // Interrupt endpoint 13. Only valid for HOST mode.
 register ADDR_ENDP13_t ADDR_ENDP13 at 0x50110034;

 type ADDR_ENDP14_t {
	ADDRESS        = uint7(0);           // Device address
	_res1          = uint8(0);           // Reserved, 9 bits
	_res2          = false;              // 
	ENDPOINT       = uint4(0);           // Endpoint number of the interrupt endpoint
	_res3          = uint5(0);           // Reserved, 5 bits
	INTEP_DIR      = false;              // Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE = false;              // Interrupt EP requires preamble (is a low speed device on a full speed hub)
 }

 // Interrupt endpoint 14. Only valid for HOST mode.
 register ADDR_ENDP14_t ADDR_ENDP14 at 0x50110038;

 type ADDR_ENDP15_t {
	ADDRESS        = uint7(0);           // Device address
	_res1          = uint8(0);           // Reserved, 9 bits
	_res2          = false;              // 
	ENDPOINT       = uint4(0);           // Endpoint number of the interrupt endpoint
	_res3          = uint5(0);           // Reserved, 5 bits
	INTEP_DIR      = false;              // Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE = false;              // Interrupt EP requires preamble (is a low speed device on a full speed hub)
 }

 // Interrupt endpoint 15. Only valid for HOST mode.
 register ADDR_ENDP15_t ADDR_ENDP15 at 0x5011003c;

 type MAIN_CTRL_t {
	CONTROLLER_EN = false;              // Enable controller
	HOST_NDEVICE  = false;              // Device mode = 0, Host mode = 1
	_res1         = uint16(0);          // Reserved, 29 bits
	_res2         = uint8(0);           // 
	_res3         = uint5(0);           // 
	SIM_TIMING    = false;              // Reduced timings for simulation
 }

 // Main control register
 register MAIN_CTRL_t MAIN_CTRL at 0x50110040;

 type SOF_WR_t {
	COUNT = uint11(0);          // 
 }

 // Set the SOF (Start of Frame) frame number in the host controller. The SOF packet is sent every 1ms and the host will increment the frame number by 1 each time.
 register SOF_WR_t SOF_WR at 0x50110044;

 type SOF_RD_t {
	COUNT = uint11(0);          // 
 }

 // Read the last SOF (Start of Frame) frame number seen. In device mode the last SOF received from the host. In host mode the last SOF sent by the host.
 register SOF_RD_t SOF_RD at 0x50110048;

 type SIE_CTRL_t {
	START_TRANS    = false;              // Host: Start transaction
	SEND_SETUP     = false;              // Host: Send Setup packet
	SEND_DATA      = false;              // Host: Send transaction (OUT from host)
	RECEIVE_DATA   = false;              // Host: Receive transaction (IN to host)
	STOP_TRANS     = false;              // Host: Stop transaction
	_res1          = false;              // Reserved, 1 bits
	PREAMBLE_EN    = false;              // Host: Preable enable for LS device on FS hub
	_res2          = false;              // Reserved, 1 bits
	SOF_SYNC       = false;              // Host: Delay packet(s) until after SOF
	SOF_EN         = false;              // Host: Enable SOF generation (for full speed bus)
	KEEP_ALIVE_EN  = false;              // Host: Enable keep alive packet (for low speed bus)
	VBUS_EN        = false;              // Host: Enable VBUS
	RESUME         = false;              // Device: Remote wakeup. Device can initiate its own resume after suspend.
	RESET_BUS      = false;              // Host: Reset bus
	_res3          = false;              // Reserved, 1 bits
	PULLDOWN_EN    = false;              // Host: Enable pull down resistors
	PULLUP_EN      = false;              // Device: Enable pull up resistor
	RPU_OPT        = false;              // Device: Pull-up strength (0=1K2, 1=2k3)
	TRANSCEIVER_PD = false;              // Power down bus transceiver
	_res4          = uint5(0);           // Reserved, 5 bits
	DIRECT_DM      = false;              // Direct control of DM
	DIRECT_DP      = false;              // Direct control of DP
	DIRECT_EN      = false;              // Direct bus drive enable
	EP0_INT_NAK    = false;              // Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a NAK
	EP0_INT_2BUF   = false;              // Device: Set bit in BUFF_STATUS for every 2 buffers completed on EP0
	EP0_INT_1BUF   = false;              // Device: Set bit in BUFF_STATUS for every buffer completed on EP0
	EP0_DOUBLE_BUF = false;              // Device: EP0 single buffered = 0, double buffered = 1
	EP0_INT_STALL  = false;              // Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a STALL
 }

 // SIE control register
 register SIE_CTRL_t SIE_CTRL at 0x5011004c;

 type SIE_STATUS_t {
	VBUS_DETECTED   = false;              // Device: VBUS Detected
	_res1           = false;              // Reserved, 1 bits
	LINE_STATE      = uint2(0);           // USB bus line state
	SUSPENDED       = false;              // Bus in suspended state. Valid for device and host. Host and device will go into suspend if neither Keep Alive / SOF frames are enabled.
	_res2           = uint3(0);           // Reserved, 3 bits
	SPEED           = uint2(0);           // Host: device speed. Disconnected = 00, LS = 01, FS = 10
	VBUS_OVER_CURR  = false;              // VBUS over current detected
	RESUME          = false;              // Host: Device has initiated a remote resume. Device: host has initiated a resume.
	_res3           = uint4(0);           // Reserved, 4 bits
	CONNECTED       = false;              // Device: connected
	SETUP_REC       = false;              // Device: Setup packet received
	TRANS_COMPLETE  = false;              // Transaction complete. Raised by device if: * An IN or OUT packet is sent with the `LAST_BUFF` bit set in the buffer control register Raised by host if: * A setup packet is sent when no data in or data out transaction follows * An IN packet is received and the `LAST_BUFF` bit is set in the buffer control register * An IN packet is received with zero length * An OUT packet is sent and the `LAST_BUFF` bit is set
	BUS_RESET       = false;              // Device: bus reset received
	_res4           = uint4(0);           // Reserved, 4 bits
	CRC_ERROR       = false;              // CRC Error. Raised by the Serial RX engine.
	BIT_STUFF_ERROR = false;              // Bit Stuff Error. Raised by the Serial RX engine.
	RX_OVERFLOW     = false;              // RX overflow is raised by the Serial RX engine if the incoming data is too fast.
	RX_TIMEOUT      = false;              // RX timeout is raised by both the host and device if an ACK is not received in the maximum time specified by the USB spec.
	NAK_REC         = false;              // Host: NAK received
	STALL_REC       = false;              // Host: STALL received
	ACK_REC         = false;              // ACK received. Raised by both host and device.
	DATA_SEQ_ERROR  = false;              // Data Sequence Error. The device can raise a sequence error in the following conditions: * A SETUP packet is received followed by a DATA1 packet (data phase should always be DATA0) * An OUT packet is received from the host but doesn't match the data pid in the buffer control register read from DPSRAM The host can raise a data sequence error in the following conditions: * An IN packet from the device has the wrong data PID
 }

 // SIE status register
 register SIE_STATUS_t SIE_STATUS at 0x50110050;

 type INT_EP_CTRL_t {
	_res1         = false;              // Reserved, 1 bits
	INT_EP_ACTIVE = uint15(0);          // Host: Enable interrupt endpoint 1 => 15
 }

 // interrupt endpoint control register
 register INT_EP_CTRL_t INT_EP_CTRL at 0x50110054;

 type BUFF_STATUS_t {
	EP0_IN   = false;              // 
	EP0_OUT  = false;              // 
	EP1_IN   = false;              // 
	EP1_OUT  = false;              // 
	EP2_IN   = false;              // 
	EP2_OUT  = false;              // 
	EP3_IN   = false;              // 
	EP3_OUT  = false;              // 
	EP4_IN   = false;              // 
	EP4_OUT  = false;              // 
	EP5_IN   = false;              // 
	EP5_OUT  = false;              // 
	EP6_IN   = false;              // 
	EP6_OUT  = false;              // 
	EP7_IN   = false;              // 
	EP7_OUT  = false;              // 
	EP8_IN   = false;              // 
	EP8_OUT  = false;              // 
	EP9_IN   = false;              // 
	EP9_OUT  = false;              // 
	EP10_IN  = false;              // 
	EP10_OUT = false;              // 
	EP11_IN  = false;              // 
	EP11_OUT = false;              // 
	EP12_IN  = false;              // 
	EP12_OUT = false;              // 
	EP13_IN  = false;              // 
	EP13_OUT = false;              // 
	EP14_IN  = false;              // 
	EP14_OUT = false;              // 
	EP15_IN  = false;              // 
	EP15_OUT = false;              // 
 }

 // Buffer status register. A bit set here indicates that a buffer has completed on the endpoint (if the buffer interrupt is enabled). It is possible for 2 buffers to be completed, so clearing the buffer status bit may instantly re set it on the next clock cycle.
 register BUFF_STATUS_t BUFF_STATUS at 0x50110058;

 type BUFF_CPU_SHOULD_HANDLE_t {
	EP0_IN   = false;              // 
	EP0_OUT  = false;              // 
	EP1_IN   = false;              // 
	EP1_OUT  = false;              // 
	EP2_IN   = false;              // 
	EP2_OUT  = false;              // 
	EP3_IN   = false;              // 
	EP3_OUT  = false;              // 
	EP4_IN   = false;              // 
	EP4_OUT  = false;              // 
	EP5_IN   = false;              // 
	EP5_OUT  = false;              // 
	EP6_IN   = false;              // 
	EP6_OUT  = false;              // 
	EP7_IN   = false;              // 
	EP7_OUT  = false;              // 
	EP8_IN   = false;              // 
	EP8_OUT  = false;              // 
	EP9_IN   = false;              // 
	EP9_OUT  = false;              // 
	EP10_IN  = false;              // 
	EP10_OUT = false;              // 
	EP11_IN  = false;              // 
	EP11_OUT = false;              // 
	EP12_IN  = false;              // 
	EP12_OUT = false;              // 
	EP13_IN  = false;              // 
	EP13_OUT = false;              // 
	EP14_IN  = false;              // 
	EP14_OUT = false;              // 
	EP15_IN  = false;              // 
	EP15_OUT = false;              // 
 }

 // Which of the double buffers should be handled. Only valid if using an interrupt per buffer (i.e. not per 2 buffers). Not valid for host interrupt endpoint polling because they are only single buffered.
 register BUFF_CPU_SHOULD_HANDLE_t BUFF_CPU_SHOULD_HANDLE at 0x5011005c;

 type EP_ABORT_t {
	EP0_IN   = false;              // 
	EP0_OUT  = false;              // 
	EP1_IN   = false;              // 
	EP1_OUT  = false;              // 
	EP2_IN   = false;              // 
	EP2_OUT  = false;              // 
	EP3_IN   = false;              // 
	EP3_OUT  = false;              // 
	EP4_IN   = false;              // 
	EP4_OUT  = false;              // 
	EP5_IN   = false;              // 
	EP5_OUT  = false;              // 
	EP6_IN   = false;              // 
	EP6_OUT  = false;              // 
	EP7_IN   = false;              // 
	EP7_OUT  = false;              // 
	EP8_IN   = false;              // 
	EP8_OUT  = false;              // 
	EP9_IN   = false;              // 
	EP9_OUT  = false;              // 
	EP10_IN  = false;              // 
	EP10_OUT = false;              // 
	EP11_IN  = false;              // 
	EP11_OUT = false;              // 
	EP12_IN  = false;              // 
	EP12_OUT = false;              // 
	EP13_IN  = false;              // 
	EP13_OUT = false;              // 
	EP14_IN  = false;              // 
	EP14_OUT = false;              // 
	EP15_IN  = false;              // 
	EP15_OUT = false;              // 
 }

 // Device only: Can be set to ignore the buffer control register for this endpoint in case you would like to revoke a buffer. A NAK will be sent for every access to the endpoint until this bit is cleared. A corresponding bit in `EP_ABORT_DONE` is set when it is safe to modify the buffer control register.
 register EP_ABORT_t EP_ABORT at 0x50110060;

 type EP_ABORT_DONE_t {
	EP0_IN   = false;              // 
	EP0_OUT  = false;              // 
	EP1_IN   = false;              // 
	EP1_OUT  = false;              // 
	EP2_IN   = false;              // 
	EP2_OUT  = false;              // 
	EP3_IN   = false;              // 
	EP3_OUT  = false;              // 
	EP4_IN   = false;              // 
	EP4_OUT  = false;              // 
	EP5_IN   = false;              // 
	EP5_OUT  = false;              // 
	EP6_IN   = false;              // 
	EP6_OUT  = false;              // 
	EP7_IN   = false;              // 
	EP7_OUT  = false;              // 
	EP8_IN   = false;              // 
	EP8_OUT  = false;              // 
	EP9_IN   = false;              // 
	EP9_OUT  = false;              // 
	EP10_IN  = false;              // 
	EP10_OUT = false;              // 
	EP11_IN  = false;              // 
	EP11_OUT = false;              // 
	EP12_IN  = false;              // 
	EP12_OUT = false;              // 
	EP13_IN  = false;              // 
	EP13_OUT = false;              // 
	EP14_IN  = false;              // 
	EP14_OUT = false;              // 
	EP15_IN  = false;              // 
	EP15_OUT = false;              // 
 }

 // Device only: Used in conjunction with `EP_ABORT`. Set once an endpoint is idle so the programmer knows it is safe to modify the buffer control register.
 register EP_ABORT_DONE_t EP_ABORT_DONE at 0x50110064;

 type EP_STALL_ARM_t {
	EP0_IN  = false;              // 
	EP0_OUT = false;              // 
 }

 // Device: this bit must be set in conjunction with the `STALL` bit in the buffer control register to send a STALL on EP0. The device controller clears these bits when a SETUP packet is received because the USB spec requires that a STALL condition is cleared when a SETUP packet is received.
 register EP_STALL_ARM_t EP_STALL_ARM at 0x50110068;

 type NAK_POLL_t {
	DELAY_LS = uint10(0);          // NAK polling interval for a low speed device
	_res1    = uint6(0);           // Reserved, 6 bits
	DELAY_FS = uint10(0);          // NAK polling interval for a full speed device
 }

 // Used by the host controller. Sets the wait time in microseconds before trying again if the device replies with a NAK.
 register NAK_POLL_t NAK_POLL at 0x5011006c;

 type EP_STATUS_STALL_NAK_t {
	EP0_IN   = false;              // 
	EP0_OUT  = false;              // 
	EP1_IN   = false;              // 
	EP1_OUT  = false;              // 
	EP2_IN   = false;              // 
	EP2_OUT  = false;              // 
	EP3_IN   = false;              // 
	EP3_OUT  = false;              // 
	EP4_IN   = false;              // 
	EP4_OUT  = false;              // 
	EP5_IN   = false;              // 
	EP5_OUT  = false;              // 
	EP6_IN   = false;              // 
	EP6_OUT  = false;              // 
	EP7_IN   = false;              // 
	EP7_OUT  = false;              // 
	EP8_IN   = false;              // 
	EP8_OUT  = false;              // 
	EP9_IN   = false;              // 
	EP9_OUT  = false;              // 
	EP10_IN  = false;              // 
	EP10_OUT = false;              // 
	EP11_IN  = false;              // 
	EP11_OUT = false;              // 
	EP12_IN  = false;              // 
	EP12_OUT = false;              // 
	EP13_IN  = false;              // 
	EP13_OUT = false;              // 
	EP14_IN  = false;              // 
	EP14_OUT = false;              // 
	EP15_IN  = false;              // 
	EP15_OUT = false;              // 
 }

 // Device: bits are set when the `IRQ_ON_NAK` or `IRQ_ON_STALL` bits are set. For EP0 this comes from `SIE_CTRL`. For all other endpoints it comes from the endpoint control register.
 register EP_STATUS_STALL_NAK_t EP_STATUS_STALL_NAK at 0x50110070;

 type USB_MUXING_t {
	TO_PHY         = false;              // 
	TO_EXTPHY      = false;              // 
	TO_DIGITAL_PAD = false;              // 
	SOFTCON        = false;              // 
 }

 // Where to connect the USB controller. Should be to_phy by default.
 register USB_MUXING_t USB_MUXING at 0x50110074;

 type USB_PWR_t {
	VBUS_EN                 = false;              // 
	VBUS_EN_OVERRIDE_EN     = false;              // 
	VBUS_DETECT             = false;              // 
	VBUS_DETECT_OVERRIDE_EN = false;              // 
	OVERCURR_DETECT         = false;              // 
	OVERCURR_DETECT_EN      = false;              // 
 }

 // Overrides for the power signals in the event that the VBUS signals are not hooked up to GPIO. Set the value of the override and then the override enable so switch over to the override value.
 register USB_PWR_t USB_PWR at 0x50110078;

 type USBPHY_DIRECT_t {
	DP_PULLUP_HISEL = false;              // when dp_pullup_en is set high, this enables second resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2
	DP_PULLUP_EN    = false;              // Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller
	DP_PULLDN_EN    = false;              // Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller 1 - Enable Rpd on DPP
	_res1           = false;              // Reserved, 1 bits
	DM_PULLUP_HISEL = false;              // when dm_pullup_en is set high, this enables second resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2
	DM_PULLUP_EN    = false;              // Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller 1 - Enable Rpu on DPM
	DM_PULLDN_EN    = false;              // Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller 1 - Enable Rpd on DPM
	_res2           = false;              // Reserved, 1 bits
	TX_DP_OE        = false;              // Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller TX_SEMODE=0, OE for DPP/DPM diff pair. 0 - DPP/DPM in Hi-Z state; 1 - DPP/DPM driving TX_SEMODE=1, OE for DPP only. 0 - DPP in Hi-Z state; 1 - DPP driving
	TX_DM_OE        = false;              // Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller TX_SEMODE=0, Ignored. TX_SEMODE=1, OE for DPM only. 0 - DPM in Hi-Z state; 1 - DPM driving
	TX_DP           = false;              // Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller TX_SEMODE=0, Drives DPP/DPM diff pair. TX_DP_OE=1 to enable drive. DPP=TX_DP, DPM=~TX_DP TX_SEMODE=1, Drives DPP only. TX_DP_OE=1 to enable drive. DPP=TX_DP
	TX_DM           = false;              // Value to drive to USB PHY when override enable is set (which will override the default value or value driven from USB controller TX_SEMODE=0, Ignored TX_SEMODE=1, Drives DPM only. TX_DM_OE=1 to enable drive. DPM=TX_DM
	RX_PD           = false;              // 
	TX_PD           = false;              // 
	TX_FSSLEW       = false;              // 
	TX_DIFFMODE     = false;              // 
	RX_DD           = false;              // Status bit from USB PHY RX Diff data
	RX_DP           = false;              // Status bit from USB PHY DPP pin state
	RX_DM           = false;              // Status bit from USB PHY DPM pin state
	DP_OVCN         = false;              // Status bit from USB PHY
	DM_OVCN         = false;              // Status bit from USB PHY
	DP_OVV          = false;              // Status bit from USB PHY
	DM_OVV          = false;              // Status bit from USB PHY
 }

 // Note that most functions are driven directly from usb_fsls controller. This register allows more detailed control/status from the USB PHY. Useful for debug but not expected to be used in normal operation Use in conjunction with usbphy_direct_override register
 register USBPHY_DIRECT_t USBPHY_DIRECT at 0x5011007c;

 type USBPHY_DIRECT_OVERRIDE_t {
	DP_PULLUP_HISEL_OVERRIDE_EN = false;              // 
	DM_PULLUP_HISEL_OVERRIDE_EN = false;              // 
	DP_PULLUP_EN_OVERRIDE_EN    = false;              // Override default value or value driven from USB Controller to PHY
	DP_PULLDN_EN_OVERRIDE_EN    = false;              // Override default value or value driven from USB Controller to PHY
	DM_PULLDN_EN_OVERRIDE_EN    = false;              // Override default value or value driven from USB Controller to PHY
	TX_DP_OE_OVERRIDE_EN        = false;              // Override default value or value driven from USB Controller to PHY
	TX_DM_OE_OVERRIDE_EN        = false;              // Override default value or value driven from USB Controller to PHY
	TX_DP_OVERRIDE_EN           = false;              // Override default value or value driven from USB Controller to PHY
	TX_DM_OVERRIDE_EN           = false;              // Override default value or value driven from USB Controller to PHY
	RX_PD_OVERRIDE_EN           = false;              // 
	TX_PD_OVERRIDE_EN           = false;              // 
	TX_FSSLEW_OVERRIDE_EN       = false;              // 
	DM_PULLUP_OVERRIDE_EN       = false;              // 
	_res1                       = uint2(0);           // Reserved, 2 bits
	TX_DIFFMODE_OVERRIDE_EN     = false;              // 
 }

 // 
 register USBPHY_DIRECT_OVERRIDE_t USBPHY_DIRECT_OVERRIDE at 0x50110080;

 type USBPHY_TRIM_t {
	DP_PULLDN_TRIM = uint5(0);           // Value to drive to USB PHY DP pulldown resistor trim control Experimental data suggests that the reset value will work, but this register allows adjustment if required
	_res1          = uint3(0);           // Reserved, 3 bits
	DM_PULLDN_TRIM = uint5(0);           // Value to drive to USB PHY DM pulldown resistor trim control Experimental data suggests that the reset value will work, but this register allows adjustment if required
 }

 // Note that most functions are driven directly from usb_fsls controller. This register allows more detailed control/status from the USB PHY. Useful for debug but not expected to be used in normal operation
 register USBPHY_TRIM_t USBPHY_TRIM at 0x50110084;

 type USB_INTR_t {
	HOST_CONN_DIS        = false;              // Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
	HOST_RESUME          = false;              // Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE
	HOST_SOF             = false;              // Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
	TRANS_COMPLETE       = false;              // Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
	BUFF_STATUS          = false;              // Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
	ERROR_DATA_SEQ       = false;              // Source: SIE_STATUS.DATA_SEQ_ERROR
	ERROR_RX_TIMEOUT     = false;              // Source: SIE_STATUS.RX_TIMEOUT
	ERROR_RX_OVERFLOW    = false;              // Source: SIE_STATUS.RX_OVERFLOW
	ERROR_BIT_STUFF      = false;              // Source: SIE_STATUS.BIT_STUFF_ERROR
	ERROR_CRC            = false;              // Source: SIE_STATUS.CRC_ERROR
	STALL                = false;              // Source: SIE_STATUS.STALL_REC
	VBUS_DETECT          = false;              // Source: SIE_STATUS.VBUS_DETECT
	BUS_RESET            = false;              // Source: SIE_STATUS.BUS_RESET
	DEV_CONN_DIS         = false;              // Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
	DEV_SUSPEND          = false;              // Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
	DEV_RESUME_FROM_HOST = false;              // Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE
	SETUP_REQ            = false;              // Device. Source: SIE_STATUS.SETUP_REC
	DEV_SOF              = false;              // Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
	ABORT_DONE           = false;              // Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
	EP_STALL_NAK         = false;              // Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
 }

 // Raw Interrupts
 register USB_INTR_t USB_INTR at 0x5011008c;

 type USB_INTE_t {
	HOST_CONN_DIS        = false;              // Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
	HOST_RESUME          = false;              // Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE
	HOST_SOF             = false;              // Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
	TRANS_COMPLETE       = false;              // Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
	BUFF_STATUS          = false;              // Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
	ERROR_DATA_SEQ       = false;              // Source: SIE_STATUS.DATA_SEQ_ERROR
	ERROR_RX_TIMEOUT     = false;              // Source: SIE_STATUS.RX_TIMEOUT
	ERROR_RX_OVERFLOW    = false;              // Source: SIE_STATUS.RX_OVERFLOW
	ERROR_BIT_STUFF      = false;              // Source: SIE_STATUS.BIT_STUFF_ERROR
	ERROR_CRC            = false;              // Source: SIE_STATUS.CRC_ERROR
	STALL                = false;              // Source: SIE_STATUS.STALL_REC
	VBUS_DETECT          = false;              // Source: SIE_STATUS.VBUS_DETECT
	BUS_RESET            = false;              // Source: SIE_STATUS.BUS_RESET
	DEV_CONN_DIS         = false;              // Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
	DEV_SUSPEND          = false;              // Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
	DEV_RESUME_FROM_HOST = false;              // Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE
	SETUP_REQ            = false;              // Device. Source: SIE_STATUS.SETUP_REC
	DEV_SOF              = false;              // Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
	ABORT_DONE           = false;              // Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
	EP_STALL_NAK         = false;              // Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
 }

 // Interrupt Enable
 register USB_INTE_t USB_INTE at 0x50110090;

 type USB_INTF_t {
	HOST_CONN_DIS        = false;              // Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
	HOST_RESUME          = false;              // Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE
	HOST_SOF             = false;              // Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
	TRANS_COMPLETE       = false;              // Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
	BUFF_STATUS          = false;              // Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
	ERROR_DATA_SEQ       = false;              // Source: SIE_STATUS.DATA_SEQ_ERROR
	ERROR_RX_TIMEOUT     = false;              // Source: SIE_STATUS.RX_TIMEOUT
	ERROR_RX_OVERFLOW    = false;              // Source: SIE_STATUS.RX_OVERFLOW
	ERROR_BIT_STUFF      = false;              // Source: SIE_STATUS.BIT_STUFF_ERROR
	ERROR_CRC            = false;              // Source: SIE_STATUS.CRC_ERROR
	STALL                = false;              // Source: SIE_STATUS.STALL_REC
	VBUS_DETECT          = false;              // Source: SIE_STATUS.VBUS_DETECT
	BUS_RESET            = false;              // Source: SIE_STATUS.BUS_RESET
	DEV_CONN_DIS         = false;              // Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
	DEV_SUSPEND          = false;              // Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
	DEV_RESUME_FROM_HOST = false;              // Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE
	SETUP_REQ            = false;              // Device. Source: SIE_STATUS.SETUP_REC
	DEV_SOF              = false;              // Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
	ABORT_DONE           = false;              // Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
	EP_STALL_NAK         = false;              // Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
 }

 // Interrupt Force
 register USB_INTF_t USB_INTF at 0x50110094;

 type USB_INTS_t {
	HOST_CONN_DIS        = false;              // Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
	HOST_RESUME          = false;              // Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE
	HOST_SOF             = false;              // Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
	TRANS_COMPLETE       = false;              // Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
	BUFF_STATUS          = false;              // Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
	ERROR_DATA_SEQ       = false;              // Source: SIE_STATUS.DATA_SEQ_ERROR
	ERROR_RX_TIMEOUT     = false;              // Source: SIE_STATUS.RX_TIMEOUT
	ERROR_RX_OVERFLOW    = false;              // Source: SIE_STATUS.RX_OVERFLOW
	ERROR_BIT_STUFF      = false;              // Source: SIE_STATUS.BIT_STUFF_ERROR
	ERROR_CRC            = false;              // Source: SIE_STATUS.CRC_ERROR
	STALL                = false;              // Source: SIE_STATUS.STALL_REC
	VBUS_DETECT          = false;              // Source: SIE_STATUS.VBUS_DETECT
	BUS_RESET            = false;              // Source: SIE_STATUS.BUS_RESET
	DEV_CONN_DIS         = false;              // Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
	DEV_SUSPEND          = false;              // Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
	DEV_RESUME_FROM_HOST = false;              // Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME_REMOTE
	SETUP_REQ            = false;              // Device. Source: SIE_STATUS.SETUP_REC
	DEV_SOF              = false;              // Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
	ABORT_DONE           = false;              // Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
	EP_STALL_NAK         = false;              // Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
 }

 // Interrupt status after masking & forcing
 register USB_INTS_t USB_INTS at 0x50110098;


/* Types and registers for USB_DPRAM 
  DPRAM layout for USB device.
 */

 type SETUP_PACKET_LOW_t {
	BMREQUESTTYPE = uint8(0);           // 
	BREQUEST      = uint8(0);           // 
	WVALUE        = uint16(0);          // 
 }

 // Bytes 0-3 of the SETUP packet from the host.
 register SETUP_PACKET_LOW_t SETUP_PACKET_LOW at 0x50100000;

 type SETUP_PACKET_HIGH_t {
	WINDEX  = uint16(0);          // 
	WLENGTH = uint16(0);          // 
 }

 // Bytes 4-7 of the setup packet from the host.
 register SETUP_PACKET_HIGH_t SETUP_PACKET_HIGH at 0x50100004;

 type EP1_IN_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP1_IN_CONTROL_t EP1_IN_CONTROL at 0x50100008;

 type EP1_OUT_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP1_OUT_CONTROL_t EP1_OUT_CONTROL at 0x5010000c;

 type EP2_IN_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP2_IN_CONTROL_t EP2_IN_CONTROL at 0x50100010;

 type EP2_OUT_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP2_OUT_CONTROL_t EP2_OUT_CONTROL at 0x50100014;

 type EP3_IN_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP3_IN_CONTROL_t EP3_IN_CONTROL at 0x50100018;

 type EP3_OUT_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP3_OUT_CONTROL_t EP3_OUT_CONTROL at 0x5010001c;

 type EP4_IN_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP4_IN_CONTROL_t EP4_IN_CONTROL at 0x50100020;

 type EP4_OUT_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP4_OUT_CONTROL_t EP4_OUT_CONTROL at 0x50100024;

 type EP5_IN_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP5_IN_CONTROL_t EP5_IN_CONTROL at 0x50100028;

 type EP5_OUT_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP5_OUT_CONTROL_t EP5_OUT_CONTROL at 0x5010002c;

 type EP6_IN_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP6_IN_CONTROL_t EP6_IN_CONTROL at 0x50100030;

 type EP6_OUT_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP6_OUT_CONTROL_t EP6_OUT_CONTROL at 0x50100034;

 type EP7_IN_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP7_IN_CONTROL_t EP7_IN_CONTROL at 0x50100038;

 type EP7_OUT_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP7_OUT_CONTROL_t EP7_OUT_CONTROL at 0x5010003c;

 type EP8_IN_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP8_IN_CONTROL_t EP8_IN_CONTROL at 0x50100040;

 type EP8_OUT_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP8_OUT_CONTROL_t EP8_OUT_CONTROL at 0x50100044;

 type EP9_IN_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP9_IN_CONTROL_t EP9_IN_CONTROL at 0x50100048;

 type EP9_OUT_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP9_OUT_CONTROL_t EP9_OUT_CONTROL at 0x5010004c;

 type EP10_IN_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP10_IN_CONTROL_t EP10_IN_CONTROL at 0x50100050;

 type EP10_OUT_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP10_OUT_CONTROL_t EP10_OUT_CONTROL at 0x50100054;

 type EP11_IN_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP11_IN_CONTROL_t EP11_IN_CONTROL at 0x50100058;

 type EP11_OUT_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP11_OUT_CONTROL_t EP11_OUT_CONTROL at 0x5010005c;

 type EP12_IN_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP12_IN_CONTROL_t EP12_IN_CONTROL at 0x50100060;

 type EP12_OUT_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP12_OUT_CONTROL_t EP12_OUT_CONTROL at 0x50100064;

 type EP13_IN_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP13_IN_CONTROL_t EP13_IN_CONTROL at 0x50100068;

 type EP13_OUT_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP13_OUT_CONTROL_t EP13_OUT_CONTROL at 0x5010006c;

 type EP14_IN_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP14_IN_CONTROL_t EP14_IN_CONTROL at 0x50100070;

 type EP14_OUT_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP14_OUT_CONTROL_t EP14_OUT_CONTROL at 0x50100074;

 type EP15_IN_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP15_IN_CONTROL_t EP15_IN_CONTROL at 0x50100078;

 type EP15_OUT_CONTROL_t {
	BUFFER_ADDRESS            = uint16(0);          // 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM.
	INTERRUPT_ON_NAK          = false;              // Trigger an interrupt if a NAK is sent. Intended for debug only.
	INTERRUPT_ON_STALL        = false;              // Trigger an interrupt if a STALL is sent. Intended for debug only.
	_res1                     = uint8(0);           // Reserved, 8 bits
	ENDPOINT_TYPE             = uint2(0);           // 
	INTERRUPT_PER_DOUBLE_BUFF = false;              // Trigger an interrupt each time both buffers are done. Only valid in double buffered mode.
	INTERRUPT_PER_BUFF        = false;              // Trigger an interrupt each time a buffer is done.
	DOUBLE_BUFFERED           = false;              // This endpoint is double buffered.
	ENABLE                    = false;              // Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set.
 }

 // 
 register EP15_OUT_CONTROL_t EP15_OUT_CONTROL at 0x5010007c;

 type EP0_IN_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP0_IN_BUFFER_CONTROL_t EP0_IN_BUFFER_CONTROL at 0x50100080;

 type EP0_OUT_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP0_OUT_BUFFER_CONTROL_t EP0_OUT_BUFFER_CONTROL at 0x50100084;

 type EP1_IN_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP1_IN_BUFFER_CONTROL_t EP1_IN_BUFFER_CONTROL at 0x50100088;

 type EP1_OUT_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP1_OUT_BUFFER_CONTROL_t EP1_OUT_BUFFER_CONTROL at 0x5010008c;

 type EP2_IN_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP2_IN_BUFFER_CONTROL_t EP2_IN_BUFFER_CONTROL at 0x50100090;

 type EP2_OUT_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP2_OUT_BUFFER_CONTROL_t EP2_OUT_BUFFER_CONTROL at 0x50100094;

 type EP3_IN_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP3_IN_BUFFER_CONTROL_t EP3_IN_BUFFER_CONTROL at 0x50100098;

 type EP3_OUT_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP3_OUT_BUFFER_CONTROL_t EP3_OUT_BUFFER_CONTROL at 0x5010009c;

 type EP4_IN_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP4_IN_BUFFER_CONTROL_t EP4_IN_BUFFER_CONTROL at 0x501000a0;

 type EP4_OUT_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP4_OUT_BUFFER_CONTROL_t EP4_OUT_BUFFER_CONTROL at 0x501000a4;

 type EP5_IN_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP5_IN_BUFFER_CONTROL_t EP5_IN_BUFFER_CONTROL at 0x501000a8;

 type EP5_OUT_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP5_OUT_BUFFER_CONTROL_t EP5_OUT_BUFFER_CONTROL at 0x501000ac;

 type EP6_IN_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP6_IN_BUFFER_CONTROL_t EP6_IN_BUFFER_CONTROL at 0x501000b0;

 type EP6_OUT_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP6_OUT_BUFFER_CONTROL_t EP6_OUT_BUFFER_CONTROL at 0x501000b4;

 type EP7_IN_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP7_IN_BUFFER_CONTROL_t EP7_IN_BUFFER_CONTROL at 0x501000b8;

 type EP7_OUT_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP7_OUT_BUFFER_CONTROL_t EP7_OUT_BUFFER_CONTROL at 0x501000bc;

 type EP8_IN_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP8_IN_BUFFER_CONTROL_t EP8_IN_BUFFER_CONTROL at 0x501000c0;

 type EP8_OUT_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP8_OUT_BUFFER_CONTROL_t EP8_OUT_BUFFER_CONTROL at 0x501000c4;

 type EP9_IN_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP9_IN_BUFFER_CONTROL_t EP9_IN_BUFFER_CONTROL at 0x501000c8;

 type EP9_OUT_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP9_OUT_BUFFER_CONTROL_t EP9_OUT_BUFFER_CONTROL at 0x501000cc;

 type EP10_IN_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP10_IN_BUFFER_CONTROL_t EP10_IN_BUFFER_CONTROL at 0x501000d0;

 type EP10_OUT_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP10_OUT_BUFFER_CONTROL_t EP10_OUT_BUFFER_CONTROL at 0x501000d4;

 type EP11_IN_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP11_IN_BUFFER_CONTROL_t EP11_IN_BUFFER_CONTROL at 0x501000d8;

 type EP11_OUT_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP11_OUT_BUFFER_CONTROL_t EP11_OUT_BUFFER_CONTROL at 0x501000dc;

 type EP12_IN_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP12_IN_BUFFER_CONTROL_t EP12_IN_BUFFER_CONTROL at 0x501000e0;

 type EP12_OUT_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP12_OUT_BUFFER_CONTROL_t EP12_OUT_BUFFER_CONTROL at 0x501000e4;

 type EP13_IN_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP13_IN_BUFFER_CONTROL_t EP13_IN_BUFFER_CONTROL at 0x501000e8;

 type EP13_OUT_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP13_OUT_BUFFER_CONTROL_t EP13_OUT_BUFFER_CONTROL at 0x501000ec;

 type EP14_IN_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP14_IN_BUFFER_CONTROL_t EP14_IN_BUFFER_CONTROL at 0x501000f0;

 type EP14_OUT_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP14_OUT_BUFFER_CONTROL_t EP14_OUT_BUFFER_CONTROL at 0x501000f4;

 type EP15_IN_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP15_IN_BUFFER_CONTROL_t EP15_IN_BUFFER_CONTROL at 0x501000f8;

 type EP15_OUT_BUFFER_CONTROL_t {
	LENGTH_0                 = uint10(0);          // The length of the data in buffer 0.
	AVAILABLE_0              = false;              // Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	STALL                    = false;              // Reply with a stall (valid for both buffers).
	RESET                    = false;              // Reset the buffer selector to buffer 0.
	PID_0                    = false;              // The data pid of buffer 0.
	LAST_0                   = false;              // Buffer 0 is the last buffer of the transfer.
	FULL_0                   = false;              // Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
	LENGTH_1                 = uint10(0);          // The length of the data in buffer 1.
	AVAILABLE_1              = false;              // Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back.
	DOUBLE_BUFFER_ISO_OFFSET = uint2(0);           // The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes.
	PID_1                    = false;              // The data pid of buffer 1.
	LAST_1                   = false;              // Buffer 1 is the last buffer of the transfer.
	FULL_1                   = false;              // Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data.
 }

 // Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
 register EP15_OUT_BUFFER_CONTROL_t EP15_OUT_BUFFER_CONTROL at 0x501000fc;


/* Types and registers for TBMAN 
  Testbench manager. Allows the programmer to know what platform their software is running on.
 */

 type TBMAN_PLATFORM_t {
	ASIC = false;              // Indicates the platform is an ASIC
	FPGA = false;              // Indicates the platform is an FPGA
 }

 // Indicates the type of platform in use
 register TBMAN_PLATFORM_t TBMAN_PLATFORM at 0x4006c000;


/* Types and registers for VREG_AND_CHIP_RESET 
  control and status for on-chip voltage regulator and chip level reset subsystem
 */

 type VREG_t {
	EN    = false;              // enable 0=not enabled, 1=enabled
	HIZ   = false;              // high impedance mode select 0=not in high impedance mode, 1=in high impedance mode
	_res1 = uint2(0);           // Reserved, 2 bits
	VSEL  = uint4(0);           // output voltage select 0000 to 0101 - 0.80V 0110 - 0.85V 0111 - 0.90V 1000 - 0.95V 1001 - 1.00V 1010 - 1.05V 1011 - 1.10V (default) 1100 - 1.15V 1101 - 1.20V 1110 - 1.25V 1111 - 1.30V
	_res2 = uint4(0);           // Reserved, 4 bits
	ROK   = false;              // regulation status 0=not in regulation, 1=in regulation
 }

 // Voltage regulator control and status
 register VREG_t VREG at 0x40064000;

 type BOD_t {
	EN    = false;              // enable 0=not enabled, 1=enabled
	_res1 = uint3(0);           // Reserved, 3 bits
	VSEL  = uint4(0);           // threshold select 0000 - 0.473V 0001 - 0.516V 0010 - 0.559V 0011 - 0.602V 0100 - 0.645V 0101 - 0.688V 0110 - 0.731V 0111 - 0.774V 1000 - 0.817V 1001 - 0.860V (default) 1010 - 0.903V 1011 - 0.946V 1100 - 0.989V 1101 - 1.032V 1110 - 1.075V 1111 - 1.118V
 }

 // brown-out detection control
 register BOD_t BOD at 0x40064004;

 type CHIP_RESET_t {
	_res1            = uint8(0);           // Reserved, 8 bits
	HAD_POR          = false;              // Last reset was from the power-on reset or brown-out detection blocks
	_res2            = uint7(0);           // Reserved, 7 bits
	HAD_RUN          = false;              // Last reset was from the RUN pin
	_res3            = uint3(0);           // Reserved, 3 bits
	HAD_PSM_RESTART  = false;              // Last reset was from the debug port
	_res4            = uint3(0);           // Reserved, 3 bits
	PSM_RESTART_FLAG = false;              // This is set by psm_restart from the debugger. Its purpose is to branch bootcode to a safe mode when the debugger has issued a psm_restart in order to recover from a boot lock-up. In the safe mode the debugger can repair the boot code, clear this flag then reboot the processor.
 }

 // Chip reset control and status
 register CHIP_RESET_t CHIP_RESET at 0x40064008;


/* Types and registers for RTC 
  Register block to control RTC
 */

 type CLKDIV_M1_t {
	CLKDIV_M1 = uint16(0);          // 
 }

 // Divider minus 1 for the 1 second counter. Safe to change the value when RTC is not enabled.
 register CLKDIV_M1_t CLKDIV_M1 at 0x4005c000;

 type SETUP_0_t {
	DAY   = uint5(0);           // Day of the month (1..31)
	_res1 = uint3(0);           // Reserved, 3 bits
	MONTH = uint4(0);           // Month (1..12)
	YEAR  = uint12(0);          // Year
 }

 // RTC setup register 0
 register SETUP_0_t SETUP_0 at 0x4005c004;

 type SETUP_1_t {
	SEC   = uint6(0);           // Seconds
	_res1 = uint2(0);           // Reserved, 2 bits
	MIN   = uint6(0);           // Minutes
	_res2 = uint2(0);           // Reserved, 2 bits
	HOUR  = uint5(0);           // Hours
	_res3 = uint3(0);           // Reserved, 3 bits
	DOTW  = uint3(0);           // Day of the week: 1-Monday...0-Sunday ISO 8601 mod 7
 }

 // RTC setup register 1
 register SETUP_1_t SETUP_1 at 0x4005c008;

 type RTC_CTRL_t {
	RTC_ENABLE        = false;              // Enable RTC
	RTC_ACTIVE        = false;              // RTC enabled (running)
	_res1             = uint2(0);           // Reserved, 2 bits
	LOAD              = false;              // Load RTC
	_res2             = uint3(0);           // Reserved, 3 bits
	FORCE_NOTLEAPYEAR = false;              // If set, leapyear is forced off. Useful for years divisible by 100 but not by 400
 }

 // RTC Control and status
 register RTC_CTRL_t RTC_CTRL at 0x4005c00c;

 type IRQ_SETUP_0_t {
	DAY          = uint5(0);           // Day of the month (1..31)
	_res1        = uint3(0);           // Reserved, 3 bits
	MONTH        = uint4(0);           // Month (1..12)
	YEAR         = uint12(0);          // Year
	DAY_ENA      = false;              // Enable day matching
	MONTH_ENA    = false;              // Enable month matching
	YEAR_ENA     = false;              // Enable year matching
	_res2        = false;              // Reserved, 1 bits
	MATCH_ENA    = false;              // Global match enable. Don't change any other value while this one is enabled
	MATCH_ACTIVE = false;              // 
 }

 // Interrupt setup register 0
 register IRQ_SETUP_0_t IRQ_SETUP_0 at 0x4005c010;

 type IRQ_SETUP_1_t {
	SEC      = uint6(0);           // Seconds
	_res1    = uint2(0);           // Reserved, 2 bits
	MIN      = uint6(0);           // Minutes
	_res2    = uint2(0);           // Reserved, 2 bits
	HOUR     = uint5(0);           // Hours
	_res3    = uint3(0);           // Reserved, 3 bits
	DOTW     = uint3(0);           // Day of the week
	_res4    = false;              // Reserved, 1 bits
	SEC_ENA  = false;              // Enable second matching
	MIN_ENA  = false;              // Enable minute matching
	HOUR_ENA = false;              // Enable hour matching
	DOTW_ENA = false;              // Enable day of the week matching
 }

 // Interrupt setup register 1
 register IRQ_SETUP_1_t IRQ_SETUP_1 at 0x4005c014;

 type RTC_1_t {
	DAY   = uint5(0);           // Day of the month (1..31)
	_res1 = uint3(0);           // Reserved, 3 bits
	MONTH = uint4(0);           // Month (1..12)
	YEAR  = uint12(0);          // Year
 }

 // RTC register 1.
 register RTC_1_t RTC_1 at 0x4005c018;

 type RTC_0_t {
	SEC   = uint6(0);           // Seconds
	_res1 = uint2(0);           // Reserved, 2 bits
	MIN   = uint6(0);           // Minutes
	_res2 = uint2(0);           // Reserved, 2 bits
	HOUR  = uint5(0);           // Hours
	_res3 = uint3(0);           // Reserved, 3 bits
	DOTW  = uint3(0);           // Day of the week
 }

 // RTC register 0 Read this before RTC 1!
 register RTC_0_t RTC_0 at 0x4005c01c;

 type RTC_INTR_t {
	RTC = false;              // 
 }

 // Raw Interrupts
 register RTC_INTR_t RTC_INTR at 0x4005c020;

 type RTC_INTE_t {
	RTC = false;              // 
 }

 // Interrupt Enable
 register RTC_INTE_t RTC_INTE at 0x4005c024;

 type RTC_INTF_t {
	RTC = false;              // 
 }

 // Interrupt Force
 register RTC_INTF_t RTC_INTF at 0x4005c028;

 type RTC_INTS_t {
	RTC = false;              // 
 }

 // Interrupt status after masking & forcing
 register RTC_INTS_t RTC_INTS at 0x4005c02c;

