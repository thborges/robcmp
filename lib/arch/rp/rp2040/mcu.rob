
use intfs.mcu;
use intfs.ports;
use intfs.databus;

use regs;

type rp2040mcu implements mcu {
	
	uint32 clock() inline {
		// 200Mhz set by init
		return 200E6;
	}

	void set_interruptions(bool enabled) {
        return;
	}

	io24 implements digitalport {
		void mode(port_mode m) {
			GPIO24_CTRL.FUNCSEL = 5;
			GPIO24.SLEWFAST = true;
			GPIO24.SCHMITT = true;
			GPIO24.OD = false;
			if m == port_mode.input {
				GPIO_OE.IO24 = false;
				GPIO24.IE = true;
				GPIO24.DRIVE = 0;
			} else {
				GPIO_OE.IO24 = true;
				GPIO24.IE = false;
				GPIO24.DRIVE = 3;
			}
        }
		void set(bool v) {
			x = uint32(1) << 24;
			if (v) { GPIO_OUT_SET_raw = x; }
			else { GPIO_OUT_CLR_raw = x; } 
		}
		bool get() { return GPIO_IN.IO24; }
	}

	io25 implements digitalport {
		void mode(port_mode m) {
			GPIO25_CTRL.FUNCSEL = 5;
			GPIO25.SLEWFAST = true;
			GPIO25.SCHMITT = true;
			GPIO25.OD = false;
			if m == port_mode.input {
				GPIO_OE.IO25 = false;
				GPIO25.IE = true;
				GPIO25.DRIVE = 0;
			} else {
				GPIO_OE.IO25 = true;
				GPIO25.IE = false;
				GPIO25.DRIVE = 3;
			}
        }
		void set(bool v) {
			x = uint32(1) << 25;
			if (v) { GPIO_OUT_SET_raw = x; }
			else { GPIO_OUT_CLR_raw = x; } 
		}
		bool get() { return GPIO_IN.IO25; }
	}

	uint64 micros() {
		timeLR = TIMELR_raw;
    	timeHR = TIMEHR_raw;
    	return (uint64(timeHR) << 32) | timeLR;
	}

	uint64 millis() {
		return micros() / 1000;
	}

    void wait_us(uint16 us) {
		old = micros();
		while micros() - old < us;
	}

	void wait_ms(uint16 ms) {
		old = millis();
		while millis() - old < ms;
	}

	uart0 implements databus {

		void setup(uint32 baud) {
			// set uart0 in IO0 (tx) and IO1 (rx)
			GPIO0_CTRL.FUNCSEL = GPIO0_CTRL_FUNCSEL.uart0_tx;
			GPIO1_CTRL.FUNCSEL = GPIO1_CTRL_FUNCSEL.uart0_rx;
			
			// set baudrate integer and fraction
			// for clock = 133E6 > 125E6, clk_peri automatically switches to 48E6
			common_denominator = baud * 16;
			baud_rate_integer = 48E6 / common_denominator;
			baud_rate_frac = ((48E6 % common_denominator) * 64) / common_denominator;
			UART0_UARTIBRD.BAUD_DIVINT = uint16(baud_rate_integer);
			UART0_UARTFBRD.BAUD_DIVFRAC = uint6(baud_rate_frac);

			// 8 bit
			UART0_UARTLCR_H.WLEN = 0b11;  // 8 bit
			UART0_UARTLCR_H.FEN = true;  // enable FIFO buffers
			UART0_UARTLCR_H.STP2 = false; // 1 stop bit
			UART0_UARTLCR_H.PEN = false;  // no parity
			UART0_UARTLCR_H.BRK = false;  // don't send break

			// enable TX and RX
			UART0_UARTCR.TXE = true;
			UART0_UARTCR.RXE = true;
		}

		void async_read_to(interrupt_i8 i) {
			//int_usart_rx = i;
			//UCSR0B.RXCIE0 = true;
		}

		void enable() {
			UART0_UARTCR.UARTEN = true;
		}

		void disable() {
			UART0_UARTCR.UARTEN = false;
		}

		void write(uint8 b) inline {
			while UART0_UARTFR.TXFF; // wait if transmit fifo is full
			UART0_UARTDR.DATA = b;
		}

		void write_array(int8[] data) {
			i = 0u;
			while i < data.size {
				write(uint8(data[i]));
				i++;
			}
		}

		uint8 read() inline {
			while UART0_UARTFR.RXFE; // wait if receive fifo is empty
			return UART0_UARTDR.DATA;    
		}

		bool has_data() inline {
			return !UART0_UARTFR.RXFE;
		}

		bool start_transaction(uint16 address) inline { return true; }
		void end_transaction() { }
		
		databus_protocol get_protocol() inline {
			return databus_protocol.UART;
		}
	}

}
